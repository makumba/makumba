package org.makumba.providers.datadefinition.mdd;

import java.util.HashMap;
import java.util.Vector;

import org.makumba.DataDefinitionNotFoundError;

import antlr.TokenStream;
import antlr.collections.AST;

/**
 * MDD Parser extending the parser generated by ANTLR for performing specific pre-processing operations
 * @author Manuel Gay
 * 
 * @version $Id: MDDParser.java,v 1.1 May 12, 2009 11:37:36 AM manu Exp $
 */
public class MDDParser extends MDDBaseParser {

    private MDDFactory factory = null;
    
    private String typeName = null;

    
    public MDDParser(TokenStream lexer, MDDFactory factory, String typeName, boolean included) {
        super(lexer);
        this.factory = factory;
        this.typeName = typeName;
        this.included = included;
    }
    
    
    protected Vector<String> includedFieldNames = new Vector<String>();
    
    @Override
    protected AST include(AST type) {
        AST included = null;
        try {
            included = factory.parseIncludedDataDefinition(type.getText()).getAST();
        } catch(DataDefinitionNotFoundError e) {
            factory.doThrow(type.getText(), "Could not find included data definition", type);
        }
        
        return included;
        
    }
    
    @Override
    protected AST includeSubField(AST type, AST parentField) {
        AST included = include(type);
        return transformToSubfield(parentField, included);
    }
    
    private AST transformToSubfield(AST parentField, AST included) {
        // process the included AST so that it fits the subField structure parentName -> field = type
        AST t = included;
        AST result = null;
        
        while(t != null) {
            
            //  subfield
            //  |
            //  |-- parentFieldName
            //  |   |
            //  |   subFieldName
            //  |   |
            //  |   subFieldType
            //  |
            //  subfield2
            //  ...
            MDDAST subfield = new MDDAST();
            subfield.setText("->!");
            subfield.setType(MDDTokenTypes.SUBFIELD);
            subfield.setLine(parentField.getLine());
            
            MDDAST parentFieldName = new MDDAST();
            parentFieldName.setText(parentField.getText());
            parentFieldName.setType(MDDTokenTypes.PARENTFIELDNAME);
            parentFieldName.setLine(parentField.getLine());
            
            subfield.setFirstChild(parentFieldName);
            
            // build tree
            t.getFirstChild().setType(MDDTokenTypes.SUBFIELDNAME);
            
            includedFieldNames.add(t.getText());
            
            subfield.getFirstChild().setNextSibling(t.getFirstChild());
            
            if(result == null) {
                result = subfield;
            } else {
                getLastSibling(result).setNextSibling(subfield);
            }
           
           t = t.getNextSibling();
        }
        return result;
    }
    
    private AST getLastSibling(AST t) {
        while(t.getNextSibling() != null) {
            t = t.getNextSibling();
        }
        return t;
    }
    
    private HashMap<String, AST> fieldsToDisable = new HashMap<String, AST>();
    
    @Override
    protected void disableField(AST field) {
        fieldsToDisable.put(field.getText(), field);
    }
    
    /**
     * performs post-processing tasks of parsing:<br>
     * - deactivates disabled fields from inclusions<br>
     */
    protected void postProcess() {
        AST t = getAST();
        AST prec = null;
        while(t!= null && t.getNextSibling() != null) {
            prec = t;
            t = t.getNextSibling();
            // FIXME should warn if a field without body is not overriding another one
            if(t.getType() == MDDTokenTypes.FIELD && fieldsToDisable.containsKey(t.getText())) {
                prec.setNextSibling(t.getNextSibling());
            }
        }
    }
    
 
}
