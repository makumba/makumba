package org.makumba.providers.datadefinition.mdd;

import java.util.HashMap;

import org.makumba.DataDefinitionNotFoundError;

import antlr.TokenStream;
import antlr.collections.AST;

/**
 * MDD Parser extending the parser generated by ANTLR for performing specific pre-processing operations
 * @author Manuel Gay
 * 
 * @version $Id: MDDParser.java,v 1.1 May 12, 2009 11:37:36 AM manu Exp $
 */
public class MDDParser extends MDDBaseParser {

    private MDDFactory factory = null;

    
    public MDDParser(TokenStream lexer, MDDFactory factory) {
        super(lexer);
        this.factory = factory;
    }
    
    @Override
    protected AST include(AST type) {
        AST included = null;
        try {
            included = factory.parseIncludedDataDefinition(type.getText());
        } catch(DataDefinitionNotFoundError e) {
            factory.doThrow(type.getText(), "Could not find included data definition", type);
        }
        
        // TODO fix line number
        /*
        MDDAST t = (MDDAST)included;
        while(t.getNextSibling() != null) {
            ((MDDAST)t.getFirstChild()).setLine(type.getLine());
            t = (MDDAST) t.getNextSibling();
        }
        */
        
        return included;
        
    }
    
    @Override
    protected AST includeSubField(AST type, AST parentField, AST subField) {
        AST included = include(type);
        AST result = null;
        
        // process the included AST so that it fits the subField structure parentName -> field = type
        AST t = included;
        
        while(t != null) {
            System.out.println(t);
            
            
            //  subfield
            //  |
            //  |-- parentFieldName
            //  |   |
            //  |   subFieldName
            //  |   |
            //  |   subFieldType
            //  |
            //  subfield2
            //  ...
            MDDAST subfield = new MDDAST();
            subfield.setText("->!");
            subfield.setType(MDDTokenTypes.SUBFIELD);
            subfield.setLine(parentField.getLine());
            
            MDDAST parentFieldName = new MDDAST();
            parentFieldName.setText(parentField.getText());
            parentFieldName.setType(MDDTokenTypes.PARENTFIELDNAME);
            parentFieldName.setLine(parentField.getLine());
            
            subfield.setFirstChild(parentFieldName);
            
            // build tree
            t.getFirstChild().setType(MDDTokenTypes.SUBFIELDNAME);
            
            subfield.getFirstChild().setNextSibling(t.getFirstChild());
            
            if(result == null) {
                result = subfield;
            } else {
                getLastSibling(result).setNextSibling(subfield);
                
                
            }
           
           t = t.getNextSibling();
        }
        
        return result;
    }
    
    private AST getLastSibling(AST t) {
        while(t.getNextSibling() != null) {
            t = t.getNextSibling();
        }
        return t;
    }
    
    private HashMap<String, AST> fieldsToDisable = new HashMap<String, AST>();

    @Override
    protected void disableField(AST field) {
        fieldsToDisable.put(field.getText(), field);
    }
    
    protected void postProcess() {
        AST t = getAST();
        AST prec = null;
        while(t.getNextSibling() != null) {
            prec = t;
            t = t.getNextSibling();
            if(t.getType() == MDDTokenTypes.FIELD && fieldsToDisable.containsKey(t.getText())) {
                prec.setNextSibling(t.getNextSibling());
            }
        }
    
    }

}
