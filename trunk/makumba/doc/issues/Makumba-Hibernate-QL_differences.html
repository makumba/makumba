<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Makumba-Hibernate QL differences</title>
</head>
<body>
Here are the presently known issues with the makumba - HQL query
transition.<br>
Note that all the indicated Makumba queries do pass the HQL parser.
They will not however pass the HQL-SQL translator (in the first 2
cases) or have a different semantic (in the next 3). The rightmost
column suggests ways to automatically translate the Makumba OQL (once
passed by the HQL parser) into HQL that would pass the HQL-SQL
translator.<br>
It is interesting to note that a label means different things in the
Hibernate FROM and SELECT sections. In FROM, it is a pointer/reference,
in SELECT it is a whole object. Makumba is more consistent in this area
so the suggested resolutions for projections below seem to make sense.<br>
<br>
<table style="text-align: left; width: 100%;" border="1" cellspacing="2"
 cellpadding="2">
  <tbody>
    <tr>
      <td style="vertical-align: top; text-align: center;">Makumba OQL<br>
      </td>
      <td style="vertical-align: top; text-align: center;">Hibernate HQL<br>
      </td>
      <td style="vertical-align: top;">problem<br>
      </td>
      <td style="vertical-align: top;">comment<br>
      </td>
      <td style="vertical-align: top;">suggested resolution<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">SELECT i.surname, p.weight FROM
test.Person p, <span style="font-weight: bold;">p.indiv i</span> WHERE
i.name = 'Bart'<br>
      </td>
      <td style="vertical-align: top;">SELECT i.surname, p.weight FROM
test.Person p,<span style="font-weight: bold;"> IN(p.indiv) i</span>
WHERE i.name = 'Bart'<br>
      </td>
      <td style="vertical-align: top;">ptr joining<br>
      </td>
      <td style="vertical-align: top;">Hibernate pointer joining is not
as obvious as in Makumba but most probably more flexible (IN operator
more powerful)<br>
      </td>
      <td style="vertical-align: top;">Accept at JSP level but
recommend the Hibernate form<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">SELECT s.name FROM test.Person p<span
 style="font-weight: bold;">, p.speaks s</span> WHERE p.indiv.name =
'Bart'<br>
SELECT a.streetno FROM test.Person p<span style="font-weight: bold;">,
p.address a</span><br>
      </td>
      <td style="vertical-align: top;">SELECT s.name FROM test.Person p
      <span style="font-weight: bold;">JOIN p.speaks s</span> WHERE
p.indiv.name = 'Bart'<br>
      <br>
SELECT a.streetno FROM test.Person p, <span style="font-weight: bold;">JOIN
p.address a</span><br>
      </td>
      <td style="vertical-align: top;">set joining<br>
      </td>
      <td style="vertical-align: top;">Hibernate pointer joining is not
as obvious as in Makumba but most probably more flexible (JOIN more
powerful). Generated Hibernate SQL uses JOIN... ON (while&nbsp;
makumba's will use two supplementary WHERE conditions). <br>
Note that this is the case for all kinds of Makumba sets.<br>
      </td>
      <td style="vertical-align: top;">Accept at JSP level but
recommend the Hibernate form. <span style="font-style: italic;"></span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">SELECT <span
 style="font-weight: bold;">p.indiv</span> FROM test.Person p<br>
      </td>
      <td style="vertical-align: top;">SELECT <span
 style="font-weight: bold;">p.hibernate_indiv</span> FROM test.Person p<br>
      </td>
      <td style="vertical-align: top;">ptr projection<br>
      </td>
      <td style="vertical-align: top;">In Hibernate, p.indiv would
select the whole test.Individual because Hibernate is oriented towards
selecting whole objects, not just fields. The current solution is to
map (in the test.Person mapping file) pointers like indiv twice: once
as a relation to test.Individual (which allows selection of the whole
object) and second as a value with the name hibernate_indiv (which
allows selection of the pointer value without joining the
test.Individual table). Maybe a better name can be chosen (e.g.
indivPtr instead of hibernate_indiv).<br>
      </td>
      <td style="vertical-align: top;">Selecting whole objects<br>
(&lt;mak:value expr="p.indiv" /&gt;) makes little sense at JSP level.
Accept the current makumba form and translate into the Hibernate form.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">SELECT <span
 style="font-weight: bold;">p</span> FROM test.Person p<br>
      </td>
      <td style="vertical-align: top;">SELECT <span
 style="font-weight: bold;">p.id</span> FROM test.Person p<br>
      </td>
      <td style="vertical-align: top;">primary key projection<br>
      </td>
      <td style="vertical-align: top;">In Hibernate, p would select the
whole test.Person because
Hibernate is oriented towards selecting whole objects, not just fields.
The current solution is to use the Hibernate-level field name (id) of
the Makumba primary key<br>
      </td>
      <td style="vertical-align: top;">Selecting whole objects <br>
(&lt;mak:value expr="p" /&gt;) makes little sense at JSP level. Accept
the current makumba form and translate into the Hibernate form.</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">SELECT <span
 style="font-weight: bold;">s </span>FROM test.Person p, <span
 style="font-weight: bold;">p.intSet s</span><br>
      </td>
      <td style="vertical-align: top;">SELECT<span
 style="font-weight: bold;"> s.enum </span>FROM test.Person p <span
 style="font-weight: bold;">JOIN p.intSet s</span></td>
      <td style="vertical-align: top;">int/charEnum projection<br>
      </td>
      <td style="vertical-align: top;">A combination of set joining and
label projection. Selecting s would select the whole enumerator object,
which is typically useless.<br>
      </td>
      <td style="vertical-align: top;">Accept the current makumba form
and translate into the Hibernate form.</td>
    </tr>
  </tbody>
</table>
<br>
</body>
</html>
