package org.makumba.providers.datadefinition.mdd;

import java.io.Reader;
import java.io.StringReader;
import java.util.HashMap;
import java.util.Vector;

import org.makumba.DataDefinitionNotFoundError;

import antlr.RecognitionException;
import antlr.TokenStream;
import antlr.TokenStreamException;
import antlr.collections.AST;

/**
 * MDD Parser extending the parser generated by ANTLR for performing specific pre-processing operations
 * @author Manuel Gay
 * 
 * @version $Id: MDDParser.java,v 1.1 May 12, 2009 11:37:36 AM manu Exp $
 */
public class MDDParser extends MDDBaseParser {

    private MDDFactory factory = null;
    
    public MDDParser(TokenStream lexer, MDDFactory factory, String typeName, boolean included) {
        super(lexer);
        this.factory = factory;
        this.typeName = typeName;
        this.included = included;
    }
    
    
    protected Vector<String> includedFieldNames = new Vector<String>();
    
    @Override
    protected AST include(AST type) {
        AST included = null;
        try {
            included = factory.parseIncludedDataDefinition(type.getText()).getAST();
        } catch(DataDefinitionNotFoundError e) {
            factory.doThrow(type.getText(), "Could not find included data definition", type);
        }
        
        return included;
        
    }
    
    @Override
    protected AST includeSubField(AST type, AST parentField) {
        AST included = include(type);
        return transformToSubfield(parentField, included);
    }
    
    private AST transformToSubfield(AST parentField, AST included) {
        // process the included AST so that it fits the subField structure parentName -> field = type
        AST t = included;
        AST result = null;
        
        while(t != null) {
            
            //  subfield
            //  |
            //  |-- parentFieldName
            //  |   |
            //  |   subFieldName
            //  |   |
            //  |   subFieldType
            //  |
            //  subfield2
            //  ...
            MDDAST subfield = new MDDAST();
            subfield.setText("->!");
            subfield.setType(MDDTokenTypes.SUBFIELD);
            subfield.setLine(parentField.getLine());
            
            MDDAST parentFieldName = new MDDAST();
            parentFieldName.setText(parentField.getText());
            parentFieldName.setType(MDDTokenTypes.PARENTFIELDNAME);
            parentFieldName.setLine(parentField.getLine());
            
            subfield.setFirstChild(parentFieldName);
            
            // build tree
            t.getFirstChild().setType(MDDTokenTypes.SUBFIELDNAME);
            
            includedFieldNames.add(t.getText());
            
            subfield.getFirstChild().setNextSibling(t.getFirstChild());
            
            if(result == null) {
                result = subfield;
            } else {
                getLastSibling(result).setNextSibling(subfield);
            }
           
           t = t.getNextSibling();
        }
        return result;
    }
    
    private AST getLastSibling(AST t) {
        while(t.getNextSibling() != null) {
            t = t.getNextSibling();
        }
        return t;
    }
    
    private HashMap<String, AST> fieldsToDisable = new HashMap<String, AST>();
    
    @Override
    protected void disableField(AST field) {
        fieldsToDisable.put(field.getText(), field);
    }
    
    /**
     * performs post-processing tasks of parsing:<br>
     * - deactivates disabled fields from inclusions<br>
     */
    protected void postProcess() {
        AST t = getAST();
        AST prec = null;
        while(t!= null && t.getNextSibling() != null) {
            prec = t;
            t = t.getNextSibling();
            // FIXME should warn if a field without body is not overriding another one
            if(t.getType() == MDDTokenTypes.FIELD && fieldsToDisable.containsKey(t.getText())) {
                prec.setNextSibling(t.getNextSibling());
            }
        }
    }
    
    protected AST parseExpression(AST expression) {
            
            Reader in = new StringReader(expression.getText());
            MDDExpressionLexer lexer = new MDDExpressionLexer(in);
            MDDExpressionParser parser = new MDDExpressionParser(lexer);
            parser.setASTNodeClass("org.makumba.providers.datadefinition.mdd.MDDAST");
            try {
                parser.expression();
            } catch (RecognitionException e) {
                e.column = expression.getColumn() + e.column;
                e.line = expression.getLine();
                factory.doThrow(e, expression, typeName);
            } catch (TokenStreamException e) {
                factory.doThrow(e, expression, typeName);
            }
            
            AST tree = parser.getAST();
            if(tree != null)
                shift(tree, expression);
            
            
            //System.out.println("/////////////// Expression parser");
            //MakumbaDumpASTVisitor visitor = new MakumbaDumpASTVisitor(false);
            //visitor.visit(parser.getAST());
            
            return parser.getAST();
    }
    
    private void shift(AST toShift, AST parent) {
        ((MDDAST)toShift).setLine(parent.getLine());
        ((MDDAST)toShift).setCol(parent.getColumn() + toShift.getColumn());
        
        if(toShift.getNextSibling() != null)
            shift(toShift.getNextSibling(), parent);
        if(toShift.getFirstChild() != null)
            shift(toShift.getFirstChild(), parent);
    }
    
    @Override
    protected void errorNestedSubfield(AST s) {
        factory.doThrow(typeName, "Nested subtypes are not allowed", s);
    }
    
 
}
