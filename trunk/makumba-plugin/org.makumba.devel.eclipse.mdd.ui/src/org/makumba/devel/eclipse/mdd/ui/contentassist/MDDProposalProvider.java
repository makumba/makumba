/*
 * generated by Xtext
 */
package org.makumba.devel.eclipse.mdd.ui.contentassist;

import static org.eclipse.xtext.scoping.Scopes.scopeFor;

import java.io.StringReader;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.TreeSet;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.Path;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.jface.text.contentassist.ICompletionProposal;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.parser.antlr.IAntlrParser;
import org.eclipse.xtext.parsetree.CompositeNode;
import org.eclipse.xtext.parsetree.LeafNode;
import org.eclipse.xtext.parsetree.NodeUtil;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.resource.IResourceDescriptions;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext;
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor;
import org.makumba.devel.eclipse.mdd.MDDUtils;
import org.makumba.devel.eclipse.mdd.MQLContext;
import org.makumba.devel.eclipse.mdd.MDD.Atom;
import org.makumba.devel.eclipse.mdd.MDD.DataDefinition;
import org.makumba.devel.eclipse.mdd.MDD.Declaration;
import org.makumba.devel.eclipse.mdd.MDD.EqualityExpression;
import org.makumba.devel.eclipse.mdd.MDD.FieldDeclaration;
import org.makumba.devel.eclipse.mdd.MDD.FieldPath;
import org.makumba.devel.eclipse.mdd.MDD.FromClassOrOuterQueryPath;
import org.makumba.devel.eclipse.mdd.MDD.FromClause;
import org.makumba.devel.eclipse.mdd.MDD.FunctionBody;
import org.makumba.devel.eclipse.mdd.MDD.FunctionDeclaration;
import org.makumba.devel.eclipse.mdd.MDD.MultiplyExpression;
import org.makumba.devel.eclipse.mdd.MDD.PointerType;
import org.makumba.devel.eclipse.mdd.MDD.RelationalExpression;
import org.makumba.devel.eclipse.mdd.MDD.SelectFrom;
import org.makumba.devel.eclipse.mdd.MDD.SubFieldDeclaration;

import com.google.common.collect.Iterables;
import com.google.inject.Inject;
import com.google.inject.Provider;

/**
 * see
 * http://www.eclipse.org/Xtext/documentation/latest/xtext.html#contentAssist on
 * how to customize content assistant
 */
public class MDDProposalProvider extends AbstractMDDProposalProvider {

	@Inject
	private IResourceDescriptions resourceDescriptions;

	@Inject
	private Provider<ResourceSet> resourceSet;

	@Inject
	private IQualifiedNameProvider nameProvider;

	@Inject
	private IAntlrParser parser;

	@Override
	public void completeModifiers_NotEmpty(EObject model, Assignment assignment, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		//TODO: add image
		String s = "not empty";
		ICompletionProposal proposal = createCompletionProposal(s, context);
		acceptor.accept(proposal);
	}

	@Override
	public void completeSubFieldDeclaration_SubFieldOf(EObject model, Assignment assignment,
			ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		//		super.completeSubFieldDeclaration_SubFieldOf(model, assignment, context, acceptor);
		Iterable<FieldDeclaration> declarations = MDDUtils.getSubFieldFields(context.getCurrentModel());

		Iterable<IEObjectDescription> candidates = scopeFor(declarations).getAllContents();
		for (IEObjectDescription candidate : candidates) {
			if (!acceptor.canAcceptMoreProposals())
				return;
			acceptor.accept(getProposalFactory("ID", context).apply(candidate));
		}
	}

	@Override
	public void completeFieldPath_Field(EObject model, Assignment assignment, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		IScope fieldPathScope = null;
		if (model instanceof FieldPath) {
			FieldPath parent = (FieldPath) model;
			if (parent.getField().getTypedef() instanceof PointerType) {
				DataDefinition pointsTo = ((PointerType) parent.getField().getTypedef()).getRef();
				Iterable<FieldDeclaration> fields = Iterables.filter(pointsTo.getD(), FieldDeclaration.class);
				fieldPathScope = scopeFor(fields);
			}

		} else {
			EObject current = model;
			while (!(current instanceof Declaration) && current != null) {
				current = current.eContainer();
			}
			if (current != null) {
				Iterable<Declaration> declarations = MDDUtils.getSiblingsOf((Declaration) current);
				Iterable<FieldDeclaration> fields = Iterables.filter(declarations, FieldDeclaration.class);
				fieldPathScope = scopeFor(fields);
			}
		}
		if (fieldPathScope != null) {
			Iterable<IEObjectDescription> candidates = fieldPathScope.getAllContents();
			for (IEObjectDescription candidate : candidates) {
				if (!acceptor.canAcceptMoreProposals())
					return;
				acceptor.accept(getProposalFactory("ID", context).apply(candidate));
			}
		}
	}

	@Override
	public void completeModifiers_NotNull(EObject model, Assignment assignment, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		//TODO: add image

		String s = "not null";

		ICompletionProposal proposal = createCompletionProposal(s, context);
		acceptor.accept(proposal);
	}

	@Override
	public void complete_SELECT(EObject model, RuleCall ruleCall, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		// TODO Auto-generated method stub
		String s = "SELECT";

		ICompletionProposal proposal = createCompletionProposal(s, context);
		acceptor.accept(proposal);
	}

	@Override
	public void completeFromClassOrOuterQueryPath_Path(EObject model, Assignment assignment,
			ContentAssistContext context, ICompletionProposalAcceptor acceptor) {

		String prefix = context.getPrefix();
		int offset = context.getOffset();

		LinkedHashMap<String, String> labels = getLabels(model);

		MQLContext mqlContext = new MQLContext(labels, resourceDescriptions, getFile(model));
		MQLProposalProvider mpp = new MQLProposalProvider(mqlContext, resourceSet.get(), getLabelProvider());

		Set<ICompletionProposal> proposals = new LinkedHashSet<ICompletionProposal>();

		//we need to add the parent's pointers and fields to the proposals
		EObject parent = model.eContainer();
		while (parent != null && !(parent instanceof SubFieldDeclaration) && !(parent instanceof DataDefinition)) {
			parent = parent.eContainer();
		}
		if (parent != null) { //add parant's pointed fields 
			Iterable<Declaration> fields = MDDUtils.getDeclarationsOf(parent);
			fields = Iterables.filter(fields, MDDUtils.PointerOrSetFilter);
			proposals.addAll(mpp.getDeclarationsProposals(prefix, offset, 1100, fields));
		}

		proposals.addAll(mpp.getPathProposals(prefix, offset, 1090, MDDUtils.PointerOrSetFilter));
		proposals.addAll(mpp.getDataDefinitionProposals(prefix, offset, 1080));

		for (ICompletionProposal proposal : proposals) {
			acceptor.accept(proposal);
		}
	}

	@Override
	public void complete_IdentPrimary(EObject model, RuleCall ruleCall, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		//getPriorityHelper().adjustKeywordPriority(proposal, prefix)

		String prefix = context.getPrefix();
		int offset = context.getOffset();

		setPathProposals(model, acceptor, prefix, offset);

	}

	private void setPathProposals(EObject model, ICompletionProposalAcceptor acceptor, String prefix, int offset) {
		LinkedHashMap<String, String> labels = getLabels(model);

		MQLContext mqlContext = new MQLContext(labels, resourceDescriptions, getFile(model));
		MQLProposalProvider mpp = new MQLProposalProvider(mqlContext, resourceSet.get(), getLabelProvider());

		Set<ICompletionProposal> proposals = new LinkedHashSet<ICompletionProposal>();

		//we need to add the parent's fields and functions, plus this functions arguments to the proposals
		EObject parent = model.eContainer();
		while (parent != null && !(parent instanceof SubFieldDeclaration) && !(parent instanceof DataDefinition)) {
			if (parent instanceof FunctionDeclaration) { //get the arguments and create proposals
				proposals.addAll(mpp.getFunctionArgumentsProposals(prefix, offset, 1000,
						((FunctionDeclaration) parent).getArg()));
			}
			parent = parent.eContainer();
		}
		if (parent != null) { //add parant's field and function proposals
			Iterable<Declaration> fields = MDDUtils.getDeclarationsOf(parent);
			fields = Iterables.filter(fields, MDDUtils.FieldOrFunction);
			proposals.addAll(mpp.getDeclarationsProposals(prefix, offset, 1100, fields));
		}

		proposals.addAll(mpp.getPathProposals(prefix, offset, 1090, MDDUtils.FieldOrFunction));
		proposals.addAll(mpp.getQueryFunctionProposals(prefix, offset, 1080));

		for (ICompletionProposal proposal : proposals) {
			acceptor.accept(proposal);
		}
	}

	@Override
	public void complete_Identifier(EObject model, RuleCall ruleCall, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		if (model.eContainer() instanceof Atom || model.eContainer() instanceof MultiplyExpression) {
			//CompositeNode parent = context.getCurrentNode().getParent();
			CompositeNode parent = context.getLastCompleteNode().getParent();
			boolean found = false;
			String prefix = "";
			for (int i = parent.getLeafNodes().size() - 1; i >= 0; i--) {
				LeafNode leafNode = parent.getLeafNodes().get(i);
				if (leafNode.getOffset() < context.getOffset()) {
					if (leafNode.getText().matches("(\\.|\\w+)")) {
						String content = leafNode.getText();
						if (leafNode.getOffset() + leafNode.getLength() > context.getOffset()) {
							content = content.substring(0, context.getOffset() - leafNode.getOffset());
						}
						prefix = content + prefix;

					} else {
						break;
					}
				}
			}
			if (!prefix.isEmpty()) {
				setPathProposals(model, acceptor, prefix, context.getOffset());
			}
		}
	}

	@Override
	public void complete_Atom(EObject model, RuleCall ruleCall, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		String prefix = context.getPrefix();
		int offset = context.getOffset();

		setPathProposals(model, acceptor, prefix, offset);
	}

	@Override
	public void complete_Aggregate(EObject model, RuleCall ruleCall, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		MQLProposalProvider mpp = new MQLProposalProvider(null, resourceSet.get(), getLabelProvider());

		Set<ICompletionProposal> proposals = new TreeSet<ICompletionProposal>();
		String prefix = context.getPrefix();
		int offset = context.getOffset();

		proposals.addAll(mpp.getAggregateFunctionProposals(prefix, offset, 1000));

		for (ICompletionProposal proposal : proposals) {
			acceptor.accept(proposal);
		}
	}

	@Override
	public void complete_RelationalExpression(EObject model, RuleCall ruleCall, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		EObject current = model;
		while (current != null && !(current instanceof EqualityExpression)) {
			current = current.eContainer();
		}
		if (current instanceof EqualityExpression) {
			LinkedHashMap<String, String> labels = getLabels(model);

			MQLContext mqlContext = new MQLContext(labels, resourceDescriptions, getFile(model));
			MQLProposalProvider mpp = new MQLProposalProvider(mqlContext, resourceSet.get(), getLabelProvider());
			Set<ICompletionProposal> proposals = new TreeSet<ICompletionProposal>();

			EqualityExpression e = (EqualityExpression) current;
			for (RelationalExpression relationalExpresion : e.getR()) {
				String enumPath = NodeUtil.getNode(relationalExpresion).serialize().trim();
				proposals.addAll(mpp.getEnumValueProposals(enumPath, context.getPrefix(), context.getOffset(), 1100));
			}
			for (ICompletionProposal proposal : proposals) {
				acceptor.accept(proposal);
			}
		}

	}

	private LinkedHashMap<String, String> getLabels(EObject object) {
		LinkedHashMap<String, String> result = new LinkedHashMap<String, String>();
		EObject current = object.eContainer();
		while (current != null && !(current instanceof FunctionBody)) {
			if (current instanceof SelectFrom) {
				SelectFrom select = (SelectFrom) current;
				if (select.getFrom() == null) {
					String from = NodeUtil.getRootNode(current).serialize()
							.substring(NodeUtil.getNode(current).getTotalOffset());
					if (from.contains("\n")) {
						from = from.substring(0, from.indexOf("\n"));
					}
					if (from.toLowerCase().contains(" from ")) {
						from = from.substring(from.toLowerCase().indexOf(" from "));
						StringReader sr = new StringReader(from);
						EObject parseResult = parser.parse("FromClause", sr).getRootASTElement();
						if (parseResult != null && parseResult instanceof FromClause) {
							result.putAll(processFrom((FromClause) parseResult));
						}
					}
				} else {
					result.putAll(processFrom(select.getFrom()));
				}
			}
			current = current.eContainer();
		}
		EObject parent = object.eContainer();
		while (parent != null && !(parent instanceof SubFieldDeclaration) && !(parent instanceof DataDefinition)) {
			parent = parent.eContainer();
		}
		if (parent != null) {
			String name = nameProvider.getQualifiedName(parent);
			//TODO: check if this referes subfielddeclaration as well or always only to MDD
			result.put("this", name);
		}
		return result;
	}

	private LinkedHashMap<String, String> processFrom(FromClause from) {
		LinkedHashMap<String, String> result = new LinkedHashMap<String, String>();
		if (from != null) {
			for (EObject o : from.eContents()) {
				if (o instanceof FromClassOrOuterQueryPath) {
					FromClassOrOuterQueryPath f = (FromClassOrOuterQueryPath) o;
					if (f.getName() != null && !f.getName().isEmpty() && f.getPath() != null && !f.getPath().isEmpty()) {
						result.put(f.getName(), f.getPath());
					}
				}
			}
		}
		return result;

	}

	private IFile getFile(EObject o) {
		return ResourcesPlugin.getWorkspace().getRoot()
				.getFile(new Path(o.eResource().getURI().toPlatformString(true)));
	}

}
