/*
* generated by Xtext
*/

package org.makumba.devel.eclipse.mdd.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;


@Singleton
public class MDDGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class DataDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DataDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLINEBREAKTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cDAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDDeclarationParserRuleCall_1_0 = (RuleCall)cDAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final RuleCall cLINEBREAKTerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Assignment cDAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cDDeclarationParserRuleCall_2_1_0 = (RuleCall)cDAssignment_2_1.eContents().get(0);
		private final RuleCall cLINEBREAKTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		//DataDefinition:
		//	LINEBREAK* d+=Declaration? (LINEBREAK+ d+=Declaration)* LINEBREAK*;
		public ParserRule getRule() { return rule; }

		//LINEBREAK* d+=Declaration? (LINEBREAK+ d+=Declaration)* LINEBREAK*
		public Group getGroup() { return cGroup; }

		//LINEBREAK*
		public RuleCall getLINEBREAKTerminalRuleCall_0() { return cLINEBREAKTerminalRuleCall_0; }

		//d+=Declaration?
		public Assignment getDAssignment_1() { return cDAssignment_1; }

		//Declaration
		public RuleCall getDDeclarationParserRuleCall_1_0() { return cDDeclarationParserRuleCall_1_0; }

		//(LINEBREAK+ d+=Declaration)*
		public Group getGroup_2() { return cGroup_2; }

		//LINEBREAK+
		public RuleCall getLINEBREAKTerminalRuleCall_2_0() { return cLINEBREAKTerminalRuleCall_2_0; }

		//d+=Declaration
		public Assignment getDAssignment_2_1() { return cDAssignment_2_1; }

		//Declaration
		public RuleCall getDDeclarationParserRuleCall_2_1_0() { return cDDeclarationParserRuleCall_2_1_0; }

		//LINEBREAK*
		public RuleCall getLINEBREAKTerminalRuleCall_3() { return cLINEBREAKTerminalRuleCall_3; }
	}

	public class DeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Declaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cFieldDeclarationParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cTitleDeclarationParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final RuleCall cTypeDeclarationParserRuleCall_0_2 = (RuleCall)cAlternatives_0.eContents().get(2);
		private final RuleCall cIncludeDeclarationParserRuleCall_0_3 = (RuleCall)cAlternatives_0.eContents().get(3);
		private final RuleCall cValidationRuleDeclarationParserRuleCall_0_4 = (RuleCall)cAlternatives_0.eContents().get(4);
		private final RuleCall cFunctionDeclarationParserRuleCall_0_5 = (RuleCall)cAlternatives_0.eContents().get(5);
		private final RuleCall cNativeValidationRuleDeclarationParserRuleCall_0_6 = (RuleCall)cAlternatives_0.eContents().get(6);
		private final RuleCall cSubFieldDeclarationParserRuleCall_0_7 = (RuleCall)cAlternatives_0.eContents().get(7);
		private final Assignment cFieldCommentAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFieldCommentFIELDCOMMENTTerminalRuleCall_1_0 = (RuleCall)cFieldCommentAssignment_1.eContents().get(0);
		
		//Declaration:
		//	(FieldDeclaration | TitleDeclaration | TypeDeclaration | IncludeDeclaration | ValidationRuleDeclaration |
		//	FunctionDeclaration | NativeValidationRuleDeclaration | SubFieldDeclaration) fieldComment=FIELDCOMMENT?;
		public ParserRule getRule() { return rule; }

		//(FieldDeclaration | TitleDeclaration | TypeDeclaration | IncludeDeclaration | ValidationRuleDeclaration |
		//FunctionDeclaration | NativeValidationRuleDeclaration | SubFieldDeclaration) fieldComment=FIELDCOMMENT?
		public Group getGroup() { return cGroup; }

		//FieldDeclaration | TitleDeclaration | TypeDeclaration | IncludeDeclaration | ValidationRuleDeclaration |
		//FunctionDeclaration | NativeValidationRuleDeclaration | SubFieldDeclaration
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//FieldDeclaration
		public RuleCall getFieldDeclarationParserRuleCall_0_0() { return cFieldDeclarationParserRuleCall_0_0; }

		//TitleDeclaration
		public RuleCall getTitleDeclarationParserRuleCall_0_1() { return cTitleDeclarationParserRuleCall_0_1; }

		//TypeDeclaration
		public RuleCall getTypeDeclarationParserRuleCall_0_2() { return cTypeDeclarationParserRuleCall_0_2; }

		//IncludeDeclaration
		public RuleCall getIncludeDeclarationParserRuleCall_0_3() { return cIncludeDeclarationParserRuleCall_0_3; }

		//ValidationRuleDeclaration
		public RuleCall getValidationRuleDeclarationParserRuleCall_0_4() { return cValidationRuleDeclarationParserRuleCall_0_4; }

		//FunctionDeclaration
		public RuleCall getFunctionDeclarationParserRuleCall_0_5() { return cFunctionDeclarationParserRuleCall_0_5; }

		//NativeValidationRuleDeclaration
		public RuleCall getNativeValidationRuleDeclarationParserRuleCall_0_6() { return cNativeValidationRuleDeclarationParserRuleCall_0_6; }

		//SubFieldDeclaration
		public RuleCall getSubFieldDeclarationParserRuleCall_0_7() { return cSubFieldDeclarationParserRuleCall_0_7; }

		//fieldComment=FIELDCOMMENT?
		public Assignment getFieldCommentAssignment_1() { return cFieldCommentAssignment_1; }

		//FIELDCOMMENT
		public RuleCall getFieldCommentFIELDCOMMENTTerminalRuleCall_1_0() { return cFieldCommentFIELDCOMMENTTerminalRuleCall_1_0; }
	}

	public class FieldDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FieldDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdOrKeywordParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cModifiersAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cModifiersModifiersParserRuleCall_2_0_0 = (RuleCall)cModifiersAssignment_2_0.eContents().get(0);
		private final Assignment cTypedefAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cTypedefFieldTypeParserRuleCall_2_1_0 = (RuleCall)cTypedefAssignment_2_1.eContents().get(0);
		
		/// *extendedDeclaration:
		//	Declaration |
		//	 FIELDCOMMENT? LINEBREAK*;* //////// Field Declaration 
		//FieldDeclaration:
		//	name=IdOrKeyword "=" (modifiers=Modifiers typedef=FieldType)?;
		public ParserRule getRule() { return rule; }

		//name=IdOrKeyword "=" (modifiers=Modifiers typedef=FieldType)?
		public Group getGroup() { return cGroup; }

		//name=IdOrKeyword
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//IdOrKeyword
		public RuleCall getNameIdOrKeywordParserRuleCall_0_0() { return cNameIdOrKeywordParserRuleCall_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//(modifiers=Modifiers typedef=FieldType)?
		public Group getGroup_2() { return cGroup_2; }

		//modifiers=Modifiers
		public Assignment getModifiersAssignment_2_0() { return cModifiersAssignment_2_0; }

		//Modifiers
		public RuleCall getModifiersModifiersParserRuleCall_2_0_0() { return cModifiersModifiersParserRuleCall_2_0_0; }

		//typedef=FieldType
		public Assignment getTypedefAssignment_2_1() { return cTypedefAssignment_2_1; }

		//FieldType
		public RuleCall getTypedefFieldTypeParserRuleCall_2_1_0() { return cTypedefFieldTypeParserRuleCall_2_1_0; }
	}

	public class ModifiersElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Modifiers");
		private final UnorderedGroup cUnorderedGroup = (UnorderedGroup)rule.eContents().get(1);
		private final Assignment cUniqueAssignment_0 = (Assignment)cUnorderedGroup.eContents().get(0);
		private final Keyword cUniqueUniqueKeyword_0_0 = (Keyword)cUniqueAssignment_0.eContents().get(0);
		private final Assignment cFixedAssignment_1 = (Assignment)cUnorderedGroup.eContents().get(1);
		private final Keyword cFixedFixedKeyword_1_0 = (Keyword)cFixedAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cUnorderedGroup.eContents().get(2);
		private final Assignment cNotNullAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final Keyword cNotNullNotKeyword_2_0_0 = (Keyword)cNotNullAssignment_2_0.eContents().get(0);
		private final Keyword cNullKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Group cGroup_3 = (Group)cUnorderedGroup.eContents().get(3);
		private final Assignment cNotEmptyAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final Keyword cNotEmptyNotKeyword_3_0_0 = (Keyword)cNotEmptyAssignment_3_0.eContents().get(0);
		private final Keyword cEmptyKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		
		//Modifiers:
		//	unique?="unique"? & fixed?="fixed"? & (notNull?="not" "null")? & (notEmpty?="not" "empty")?;
		public ParserRule getRule() { return rule; }

		//unique?="unique"? & fixed?="fixed"? & (notNull?="not" "null")? & (notEmpty?="not" "empty")?
		public UnorderedGroup getUnorderedGroup() { return cUnorderedGroup; }

		//unique?="unique"?
		public Assignment getUniqueAssignment_0() { return cUniqueAssignment_0; }

		//"unique"
		public Keyword getUniqueUniqueKeyword_0_0() { return cUniqueUniqueKeyword_0_0; }

		//fixed?="fixed"?
		public Assignment getFixedAssignment_1() { return cFixedAssignment_1; }

		//"fixed"
		public Keyword getFixedFixedKeyword_1_0() { return cFixedFixedKeyword_1_0; }

		//(notNull?="not" "null")?
		public Group getGroup_2() { return cGroup_2; }

		//notNull?="not"
		public Assignment getNotNullAssignment_2_0() { return cNotNullAssignment_2_0; }

		//"not"
		public Keyword getNotNullNotKeyword_2_0_0() { return cNotNullNotKeyword_2_0_0; }

		//"null"
		public Keyword getNullKeyword_2_1() { return cNullKeyword_2_1; }

		//(notEmpty?="not" "empty")?
		public Group getGroup_3() { return cGroup_3; }

		//notEmpty?="not"
		public Assignment getNotEmptyAssignment_3_0() { return cNotEmptyAssignment_3_0; }

		//"not"
		public Keyword getNotEmptyNotKeyword_3_0_0() { return cNotEmptyNotKeyword_3_0_0; }

		//"empty"
		public Keyword getEmptyKeyword_3_1() { return cEmptyKeyword_3_1; }
	}

	public class FieldTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FieldType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCharTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCharEnumParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cSetKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cCharEnumParserRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final RuleCall cIntEnumParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Keyword cSetKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final RuleCall cIntEnumParserRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Action cFieldTypeAction_5_0 = (Action)cGroup_5.eContents().get(0);
		private final Assignment cTypeAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final Alternatives cTypeAlternatives_5_1_0 = (Alternatives)cTypeAssignment_5_1.eContents().get(0);
		private final Keyword cTypeIntKeyword_5_1_0_0 = (Keyword)cTypeAlternatives_5_1_0.eContents().get(0);
		private final Keyword cTypeRealKeyword_5_1_0_1 = (Keyword)cTypeAlternatives_5_1_0.eContents().get(1);
		private final Keyword cTypeBooleanKeyword_5_1_0_2 = (Keyword)cTypeAlternatives_5_1_0.eContents().get(2);
		private final Keyword cTypeTextKeyword_5_1_0_3 = (Keyword)cTypeAlternatives_5_1_0.eContents().get(3);
		private final Keyword cTypeBinaryKeyword_5_1_0_4 = (Keyword)cTypeAlternatives_5_1_0.eContents().get(4);
		private final Keyword cTypeFileKeyword_5_1_0_5 = (Keyword)cTypeAlternatives_5_1_0.eContents().get(5);
		private final Keyword cTypeDateKeyword_5_1_0_6 = (Keyword)cTypeAlternatives_5_1_0.eContents().get(6);
		private final RuleCall cPointerTypeParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cSetTypeParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final Assignment cTypeDecAssignment_8 = (Assignment)cAlternatives.eContents().get(8);
		private final CrossReference cTypeDecTypeDeclarationCrossReference_8_0 = (CrossReference)cTypeDecAssignment_8.eContents().get(0);
		private final RuleCall cTypeDecTypeDeclarationIDTerminalRuleCall_8_0_1 = (RuleCall)cTypeDecTypeDeclarationCrossReference_8_0.eContents().get(1);
		
		//FieldType:
		//	CharType | CharEnum | "set" CharEnum | IntEnum | "set" IntEnum | {FieldType} type=("int" | "real" | "boolean" | "text"
		//	| "binary" | "file" | "date") | PointerType | SetType | typeDec=[TypeDeclaration];
		public ParserRule getRule() { return rule; }

		//CharType | CharEnum | "set" CharEnum | IntEnum | "set" IntEnum | {FieldType} type=("int" | "real" | "boolean" | "text" |
		//"binary" | "file" | "date") | PointerType | SetType | typeDec=[TypeDeclaration]
		public Alternatives getAlternatives() { return cAlternatives; }

		//CharType
		public RuleCall getCharTypeParserRuleCall_0() { return cCharTypeParserRuleCall_0; }

		//CharEnum
		public RuleCall getCharEnumParserRuleCall_1() { return cCharEnumParserRuleCall_1; }

		//"set" CharEnum
		public Group getGroup_2() { return cGroup_2; }

		//"set"
		public Keyword getSetKeyword_2_0() { return cSetKeyword_2_0; }

		//CharEnum
		public RuleCall getCharEnumParserRuleCall_2_1() { return cCharEnumParserRuleCall_2_1; }

		//IntEnum
		public RuleCall getIntEnumParserRuleCall_3() { return cIntEnumParserRuleCall_3; }

		//"set" IntEnum
		public Group getGroup_4() { return cGroup_4; }

		//"set"
		public Keyword getSetKeyword_4_0() { return cSetKeyword_4_0; }

		//IntEnum
		public RuleCall getIntEnumParserRuleCall_4_1() { return cIntEnumParserRuleCall_4_1; }

		//{FieldType} type=("int" | "real" | "boolean" | "text" | "binary" | "file" | "date")
		public Group getGroup_5() { return cGroup_5; }

		//{FieldType}
		public Action getFieldTypeAction_5_0() { return cFieldTypeAction_5_0; }

		//type=("int" | "real" | "boolean" | "text" | "binary" | "file" | "date")
		public Assignment getTypeAssignment_5_1() { return cTypeAssignment_5_1; }

		//"int" | "real" | "boolean" | "text" | "binary" | "file" | "date"
		public Alternatives getTypeAlternatives_5_1_0() { return cTypeAlternatives_5_1_0; }

		//"int"
		public Keyword getTypeIntKeyword_5_1_0_0() { return cTypeIntKeyword_5_1_0_0; }

		//"real"
		public Keyword getTypeRealKeyword_5_1_0_1() { return cTypeRealKeyword_5_1_0_1; }

		//"boolean"
		public Keyword getTypeBooleanKeyword_5_1_0_2() { return cTypeBooleanKeyword_5_1_0_2; }

		//"text"
		public Keyword getTypeTextKeyword_5_1_0_3() { return cTypeTextKeyword_5_1_0_3; }

		//"binary"
		public Keyword getTypeBinaryKeyword_5_1_0_4() { return cTypeBinaryKeyword_5_1_0_4; }

		//"file"
		public Keyword getTypeFileKeyword_5_1_0_5() { return cTypeFileKeyword_5_1_0_5; }

		//"date"
		public Keyword getTypeDateKeyword_5_1_0_6() { return cTypeDateKeyword_5_1_0_6; }

		//PointerType
		public RuleCall getPointerTypeParserRuleCall_6() { return cPointerTypeParserRuleCall_6; }

		//SetType
		public RuleCall getSetTypeParserRuleCall_7() { return cSetTypeParserRuleCall_7; }

		//typeDec=[TypeDeclaration]
		public Assignment getTypeDecAssignment_8() { return cTypeDecAssignment_8; }

		//[TypeDeclaration]
		public CrossReference getTypeDecTypeDeclarationCrossReference_8_0() { return cTypeDecTypeDeclarationCrossReference_8_0; }

		//ID
		public RuleCall getTypeDecTypeDeclarationIDTerminalRuleCall_8_0_1() { return cTypeDecTypeDeclarationIDTerminalRuleCall_8_0_1; }
	}

	public class IntEnumElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IntEnum");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameIntKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValuesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValuesEnumValueParserRuleCall_2_0 = (RuleCall)cValuesAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cValuesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cValuesEnumValueParserRuleCall_3_1_0 = (RuleCall)cValuesAssignment_3_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//IntEnum:
		//	name="int" "{" values+=EnumValue ("," values+=EnumValue)* "}";
		public ParserRule getRule() { return rule; }

		//name="int" "{" values+=EnumValue ("," values+=EnumValue)* "}"
		public Group getGroup() { return cGroup; }

		//name="int"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"int"
		public Keyword getNameIntKeyword_0_0() { return cNameIntKeyword_0_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//values+=EnumValue
		public Assignment getValuesAssignment_2() { return cValuesAssignment_2; }

		//EnumValue
		public RuleCall getValuesEnumValueParserRuleCall_2_0() { return cValuesEnumValueParserRuleCall_2_0; }

		//("," values+=EnumValue)*
		public Group getGroup_3() { return cGroup_3; }

		//","
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//values+=EnumValue
		public Assignment getValuesAssignment_3_1() { return cValuesAssignment_3_1; }

		//EnumValue
		public RuleCall getValuesEnumValueParserRuleCall_3_1_0() { return cValuesEnumValueParserRuleCall_3_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class CharEnumElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CharEnum");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameCharKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValuesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValuesSTRINGTerminalRuleCall_2_0 = (RuleCall)cValuesAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cValuesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cValuesSTRINGTerminalRuleCall_3_1_0 = (RuleCall)cValuesAssignment_3_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//CharEnum:
		//	name="char" "{" values+=STRING ("," values+=STRING)* "}";
		public ParserRule getRule() { return rule; }

		//name="char" "{" values+=STRING ("," values+=STRING)* "}"
		public Group getGroup() { return cGroup; }

		//name="char"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"char"
		public Keyword getNameCharKeyword_0_0() { return cNameCharKeyword_0_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//values+=STRING
		public Assignment getValuesAssignment_2() { return cValuesAssignment_2; }

		//STRING
		public RuleCall getValuesSTRINGTerminalRuleCall_2_0() { return cValuesSTRINGTerminalRuleCall_2_0; }

		//("," values+=STRING)*
		public Group getGroup_3() { return cGroup_3; }

		//","
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//values+=STRING
		public Assignment getValuesAssignment_3_1() { return cValuesAssignment_3_1; }

		//STRING
		public RuleCall getValuesSTRINGTerminalRuleCall_3_1_0() { return cValuesSTRINGTerminalRuleCall_3_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class EnumValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EnumValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameSTRINGTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cValueAlternatives_2_0 = (Alternatives)cValueAssignment_2.eContents().get(0);
		private final RuleCall cValueINTTerminalRuleCall_2_0_0 = (RuleCall)cValueAlternatives_2_0.eContents().get(0);
		private final RuleCall cValueSIGNED_INTTerminalRuleCall_2_0_1 = (RuleCall)cValueAlternatives_2_0.eContents().get(1);
		private final Assignment cDecpricatedAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final Keyword cDecpricatedDeprecatedKeyword_3_0 = (Keyword)cDecpricatedAssignment_3.eContents().get(0);
		
		/// * New syntax to be introduced in mak 0.9
		//EnumType:
		//  'enum' ('{'  values+=EnumValue (',' values+=EnumValue)* '}'); 
		//
		//SetEnumType:
		//  'setEnum' ('{'  values+=EnumValue (',' values+=EnumValue)* '}');* /EnumValue:
		//	name=STRING "=" value=(INT | SIGNED_INT) decpricated?="deprecated"?;
		public ParserRule getRule() { return rule; }

		//name=STRING "=" value=(INT | SIGNED_INT) decpricated?="deprecated"?
		public Group getGroup() { return cGroup; }

		//name=STRING
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_0_0() { return cNameSTRINGTerminalRuleCall_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//value=(INT | SIGNED_INT)
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//INT | SIGNED_INT
		public Alternatives getValueAlternatives_2_0() { return cValueAlternatives_2_0; }

		//INT
		public RuleCall getValueINTTerminalRuleCall_2_0_0() { return cValueINTTerminalRuleCall_2_0_0; }

		//SIGNED_INT
		public RuleCall getValueSIGNED_INTTerminalRuleCall_2_0_1() { return cValueSIGNED_INTTerminalRuleCall_2_0_1; }

		//decpricated?="deprecated"?
		public Assignment getDecpricatedAssignment_3() { return cDecpricatedAssignment_3; }

		//"deprecated"
		public Keyword getDecpricatedDeprecatedKeyword_3_0() { return cDecpricatedDeprecatedKeyword_3_0; }
	}

	public class CharTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CharType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCharTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cCharKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftSquareBracketKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cLengthAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cLengthINTTerminalRuleCall_2_1_0 = (RuleCall)cLengthAssignment_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		
		//CharType:
		//	{CharType} "char" ("[" length=INT? "]")?;
		public ParserRule getRule() { return rule; }

		//{CharType} "char" ("[" length=INT? "]")?
		public Group getGroup() { return cGroup; }

		//{CharType}
		public Action getCharTypeAction_0() { return cCharTypeAction_0; }

		//"char"
		public Keyword getCharKeyword_1() { return cCharKeyword_1; }

		//("[" length=INT? "]")?
		public Group getGroup_2() { return cGroup_2; }

		//"["
		public Keyword getLeftSquareBracketKeyword_2_0() { return cLeftSquareBracketKeyword_2_0; }

		//length=INT?
		public Assignment getLengthAssignment_2_1() { return cLengthAssignment_2_1; }

		//INT
		public RuleCall getLengthINTTerminalRuleCall_2_1_0() { return cLengthINTTerminalRuleCall_2_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_2_2() { return cRightSquareBracketKeyword_2_2; }
	}

	public class PointerTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PointerType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPointerTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cPtrKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRefAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cRefDataDefinitionCrossReference_2_0 = (CrossReference)cRefAssignment_2.eContents().get(0);
		private final RuleCall cRefDataDefinitionTypeParserRuleCall_2_0_1 = (RuleCall)cRefDataDefinitionCrossReference_2_0.eContents().get(1);
		
		//PointerType:
		//	{PointerType} "ptr" ref=[DataDefinition|Type]?;
		public ParserRule getRule() { return rule; }

		//{PointerType} "ptr" ref=[DataDefinition|Type]?
		public Group getGroup() { return cGroup; }

		//{PointerType}
		public Action getPointerTypeAction_0() { return cPointerTypeAction_0; }

		//"ptr"
		public Keyword getPtrKeyword_1() { return cPtrKeyword_1; }

		//ref=[DataDefinition|Type]?
		public Assignment getRefAssignment_2() { return cRefAssignment_2; }

		//[DataDefinition|Type]
		public CrossReference getRefDataDefinitionCrossReference_2_0() { return cRefDataDefinitionCrossReference_2_0; }

		//Type
		public RuleCall getRefDataDefinitionTypeParserRuleCall_2_0_1() { return cRefDataDefinitionTypeParserRuleCall_2_0_1; }
	}

	public class SetTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SetType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSetTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cSetKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRefAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cRefDataDefinitionCrossReference_2_0 = (CrossReference)cRefAssignment_2.eContents().get(0);
		private final RuleCall cRefDataDefinitionTypeParserRuleCall_2_0_1 = (RuleCall)cRefDataDefinitionCrossReference_2_0.eContents().get(1);
		
		//SetType:
		//	{SetType} "set" ref=[DataDefinition|Type]?;
		public ParserRule getRule() { return rule; }

		//{SetType} "set" ref=[DataDefinition|Type]?
		public Group getGroup() { return cGroup; }

		//{SetType}
		public Action getSetTypeAction_0() { return cSetTypeAction_0; }

		//"set"
		public Keyword getSetKeyword_1() { return cSetKeyword_1; }

		//ref=[DataDefinition|Type]?
		public Assignment getRefAssignment_2() { return cRefAssignment_2; }

		//[DataDefinition|Type]
		public CrossReference getRefDataDefinitionCrossReference_2_0() { return cRefDataDefinitionCrossReference_2_0; }

		//Type
		public RuleCall getRefDataDefinitionTypeParserRuleCall_2_0_1() { return cRefDataDefinitionTypeParserRuleCall_2_0_1; }
	}

	public class SubFieldDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SubFieldDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSubFieldOfAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cSubFieldOfFieldDeclarationCrossReference_0_0 = (CrossReference)cSubFieldOfAssignment_0.eContents().get(0);
		private final RuleCall cSubFieldOfFieldDeclarationIDTerminalRuleCall_0_0_1 = (RuleCall)cSubFieldOfFieldDeclarationCrossReference_0_0.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cDAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDDeclarationParserRuleCall_2_0 = (RuleCall)cDAssignment_2.eContents().get(0);
		
		//SubFieldDeclaration:
		//	subFieldOf=[FieldDeclaration] "->" d=Declaration;
		public ParserRule getRule() { return rule; }

		//subFieldOf=[FieldDeclaration] "->" d=Declaration
		public Group getGroup() { return cGroup; }

		//subFieldOf=[FieldDeclaration]
		public Assignment getSubFieldOfAssignment_0() { return cSubFieldOfAssignment_0; }

		//[FieldDeclaration]
		public CrossReference getSubFieldOfFieldDeclarationCrossReference_0_0() { return cSubFieldOfFieldDeclarationCrossReference_0_0; }

		//ID
		public RuleCall getSubFieldOfFieldDeclarationIDTerminalRuleCall_0_0_1() { return cSubFieldOfFieldDeclarationIDTerminalRuleCall_0_0_1; }

		//"->"
		public Keyword getHyphenMinusGreaterThanSignKeyword_1() { return cHyphenMinusGreaterThanSignKeyword_1; }

		//d=Declaration
		public Assignment getDAssignment_2() { return cDAssignment_2; }

		//Declaration
		public RuleCall getDDeclarationParserRuleCall_2_0() { return cDDeclarationParserRuleCall_2_0; }
	}

	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIdOrKeywordParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIdOrKeywordParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//Type returns ecore::EString:
		//	IdOrKeyword ("." IdOrKeyword)*;
		public ParserRule getRule() { return rule; }

		//IdOrKeyword ("." IdOrKeyword)*
		public Group getGroup() { return cGroup; }

		//IdOrKeyword
		public RuleCall getIdOrKeywordParserRuleCall_0() { return cIdOrKeywordParserRuleCall_0; }

		//("." IdOrKeyword)*
		public Group getGroup_1() { return cGroup_1; }

		//"."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//IdOrKeyword
		public RuleCall getIdOrKeywordParserRuleCall_1_1() { return cIdOrKeywordParserRuleCall_1_1; }
	}

	public class TitleDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TitleDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExclamationMarkKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cTitleKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Assignment cFieldAssignment_3_0 = (Assignment)cAlternatives_3.eContents().get(0);
		private final RuleCall cFieldFieldPathParserRuleCall_3_0_0 = (RuleCall)cFieldAssignment_3_0.eContents().get(0);
		private final Assignment cFunctionAssignment_3_1 = (Assignment)cAlternatives_3.eContents().get(1);
		private final RuleCall cFunctionFunctionCallParserRuleCall_3_1_0 = (RuleCall)cFunctionAssignment_3_1.eContents().get(0);
		
		//// !title = field or function
		//TitleDeclaration:
		//	"!" "title" "=" (field=FieldPath | function=FunctionCall);
		public ParserRule getRule() { return rule; }

		//"!" "title" "=" (field=FieldPath | function=FunctionCall)
		public Group getGroup() { return cGroup; }

		//"!"
		public Keyword getExclamationMarkKeyword_0() { return cExclamationMarkKeyword_0; }

		//"title"
		public Keyword getTitleKeyword_1() { return cTitleKeyword_1; }

		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//field=FieldPath | function=FunctionCall
		public Alternatives getAlternatives_3() { return cAlternatives_3; }

		//field=FieldPath
		public Assignment getFieldAssignment_3_0() { return cFieldAssignment_3_0; }

		//FieldPath
		public RuleCall getFieldFieldPathParserRuleCall_3_0_0() { return cFieldFieldPathParserRuleCall_3_0_0; }

		//function=FunctionCall
		public Assignment getFunctionAssignment_3_1() { return cFunctionAssignment_3_1; }

		//FunctionCall
		public RuleCall getFunctionFunctionCallParserRuleCall_3_1_0() { return cFunctionFunctionCallParserRuleCall_3_1_0; }
	}

	public class IncludeDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IncludeDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExclamationMarkKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cIncludeKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cImportedNamespaceAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final CrossReference cImportedNamespaceDataDefinitionCrossReference_3_0 = (CrossReference)cImportedNamespaceAssignment_3.eContents().get(0);
		private final RuleCall cImportedNamespaceDataDefinitionTypeParserRuleCall_3_0_1 = (RuleCall)cImportedNamespaceDataDefinitionCrossReference_3_0.eContents().get(1);
		
		//// !include = general.Address
		//IncludeDeclaration:
		//	"!" "include" "=" importedNamespace=[DataDefinition|Type];
		public ParserRule getRule() { return rule; }

		//"!" "include" "=" importedNamespace=[DataDefinition|Type]
		public Group getGroup() { return cGroup; }

		//"!"
		public Keyword getExclamationMarkKeyword_0() { return cExclamationMarkKeyword_0; }

		//"include"
		public Keyword getIncludeKeyword_1() { return cIncludeKeyword_1; }

		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//importedNamespace=[DataDefinition|Type]
		public Assignment getImportedNamespaceAssignment_3() { return cImportedNamespaceAssignment_3; }

		//[DataDefinition|Type]
		public CrossReference getImportedNamespaceDataDefinitionCrossReference_3_0() { return cImportedNamespaceDataDefinitionCrossReference_3_0; }

		//Type
		public RuleCall getImportedNamespaceDataDefinitionTypeParserRuleCall_3_0_1() { return cImportedNamespaceDataDefinitionTypeParserRuleCall_3_0_1; }
	}

	public class TypeDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExclamationMarkKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cTypeKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameIDTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Keyword cEqualsSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cFieldTypeAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cFieldTypeFieldTypeParserRuleCall_5_0 = (RuleCall)cFieldTypeAssignment_5.eContents().get(0);
		
		//// !type.genDef = ...
		//TypeDeclaration:
		//	"!" "type" "." name=ID "=" fieldType=FieldType;
		public ParserRule getRule() { return rule; }

		//"!" "type" "." name=ID "=" fieldType=FieldType
		public Group getGroup() { return cGroup; }

		//"!"
		public Keyword getExclamationMarkKeyword_0() { return cExclamationMarkKeyword_0; }

		//"type"
		public Keyword getTypeKeyword_1() { return cTypeKeyword_1; }

		//"."
		public Keyword getFullStopKeyword_2() { return cFullStopKeyword_2; }

		//name=ID
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_3_0() { return cNameIDTerminalRuleCall_3_0; }

		//"="
		public Keyword getEqualsSignKeyword_4() { return cEqualsSignKeyword_4; }

		//fieldType=FieldType
		public Assignment getFieldTypeAssignment_5() { return cFieldTypeAssignment_5; }

		//FieldType
		public RuleCall getFieldTypeFieldTypeParserRuleCall_5_0() { return cFieldTypeFieldTypeParserRuleCall_5_0; }
	}

	public class ValidationRuleDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ValidationRuleDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cRangeValidationRuleDeclarationParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cUniquenessValidationRuleDeclarationParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final RuleCall cComparisonValidationRuleDeclarationParserRuleCall_0_2 = (RuleCall)cAlternatives_0.eContents().get(2);
		private final RuleCall cRegexValidationRuleDeclarationParserRuleCall_0_3 = (RuleCall)cAlternatives_0.eContents().get(3);
		private final Assignment cErrorMessageAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cErrorMessageErrorMessageParserRuleCall_1_0 = (RuleCall)cErrorMessageAssignment_1.eContents().get(0);
		
		/////// Validation Rules
		//ValidationRuleDeclaration:
		//	(RangeValidationRuleDeclaration | UniquenessValidationRuleDeclaration | ComparisonValidationRuleDeclaration |
		//	RegexValidationRuleDeclaration) errorMessage=ErrorMessage;
		public ParserRule getRule() { return rule; }

		//(RangeValidationRuleDeclaration | UniquenessValidationRuleDeclaration | ComparisonValidationRuleDeclaration |
		//RegexValidationRuleDeclaration) errorMessage=ErrorMessage
		public Group getGroup() { return cGroup; }

		//RangeValidationRuleDeclaration | UniquenessValidationRuleDeclaration | ComparisonValidationRuleDeclaration |
		//RegexValidationRuleDeclaration
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//RangeValidationRuleDeclaration
		public RuleCall getRangeValidationRuleDeclarationParserRuleCall_0_0() { return cRangeValidationRuleDeclarationParserRuleCall_0_0; }

		//UniquenessValidationRuleDeclaration
		public RuleCall getUniquenessValidationRuleDeclarationParserRuleCall_0_1() { return cUniquenessValidationRuleDeclarationParserRuleCall_0_1; }

		//ComparisonValidationRuleDeclaration
		public RuleCall getComparisonValidationRuleDeclarationParserRuleCall_0_2() { return cComparisonValidationRuleDeclarationParserRuleCall_0_2; }

		//RegexValidationRuleDeclaration
		public RuleCall getRegexValidationRuleDeclarationParserRuleCall_0_3() { return cRegexValidationRuleDeclarationParserRuleCall_0_3; }

		//errorMessage=ErrorMessage
		public Assignment getErrorMessageAssignment_1() { return cErrorMessageAssignment_1; }

		//ErrorMessage
		public RuleCall getErrorMessageErrorMessageParserRuleCall_1_0() { return cErrorMessageErrorMessageParserRuleCall_1_0; }
	}

	public class ComparisonValidationRuleDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ComparisonValidationRuleDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameCompareKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Assignment cArgsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cArgsFunctionArgumentsParserRuleCall_1_0 = (RuleCall)cArgsAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cComparisonExpAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cComparisonExpComparisonExpressionParserRuleCall_3_0 = (RuleCall)cComparisonExpAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//ComparisonValidationRuleDeclaration:
		//	name="compare" args=FunctionArguments "{" comparisonExp=ComparisonExpression "}";
		public ParserRule getRule() { return rule; }

		//name="compare" args=FunctionArguments "{" comparisonExp=ComparisonExpression "}"
		public Group getGroup() { return cGroup; }

		//name="compare"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"compare"
		public Keyword getNameCompareKeyword_0_0() { return cNameCompareKeyword_0_0; }

		//args=FunctionArguments
		public Assignment getArgsAssignment_1() { return cArgsAssignment_1; }

		//FunctionArguments
		public RuleCall getArgsFunctionArgumentsParserRuleCall_1_0() { return cArgsFunctionArgumentsParserRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//comparisonExp=ComparisonExpression
		public Assignment getComparisonExpAssignment_3() { return cComparisonExpAssignment_3; }

		//ComparisonExpression
		public RuleCall getComparisonExpComparisonExpressionParserRuleCall_3_0() { return cComparisonExpComparisonExpressionParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class ComparisonExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ComparisonExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhsComparisonPartParserRuleCall_0_0 = (RuleCall)cLhsAssignment_0.eContents().get(0);
		private final Assignment cOAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOOperatorParserRuleCall_1_0 = (RuleCall)cOAssignment_1.eContents().get(0);
		private final Assignment cRhsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRhsComparisonPartParserRuleCall_2_0 = (RuleCall)cRhsAssignment_2.eContents().get(0);
		
		////////// COMPARISON EXPRESSION
		//ComparisonExpression:
		//	lhs=ComparisonPart o=Operator rhs=ComparisonPart;
		public ParserRule getRule() { return rule; }

		//lhs=ComparisonPart o=Operator rhs=ComparisonPart
		public Group getGroup() { return cGroup; }

		//lhs=ComparisonPart
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }

		//ComparisonPart
		public RuleCall getLhsComparisonPartParserRuleCall_0_0() { return cLhsComparisonPartParserRuleCall_0_0; }

		//o=Operator
		public Assignment getOAssignment_1() { return cOAssignment_1; }

		//Operator
		public RuleCall getOOperatorParserRuleCall_1_0() { return cOOperatorParserRuleCall_1_0; }

		//rhs=ComparisonPart
		public Assignment getRhsAssignment_2() { return cRhsAssignment_2; }

		//ComparisonPart
		public RuleCall getRhsComparisonPartParserRuleCall_2_0() { return cRhsComparisonPartParserRuleCall_2_0; }
	}

	public class ComparisonPartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ComparisonPart");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cFieldAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cFieldFieldPathParserRuleCall_0_0 = (RuleCall)cFieldAssignment_0.eContents().get(0);
		private final Assignment cNAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cNINTTerminalRuleCall_1_0 = (RuleCall)cNAssignment_1.eContents().get(0);
		private final Assignment cDfAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cDfDateFunctionParserRuleCall_2_0 = (RuleCall)cDfAssignment_2.eContents().get(0);
		private final Assignment cUAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cUUpperFunctionParserRuleCall_3_0 = (RuleCall)cUAssignment_3.eContents().get(0);
		private final Assignment cLAssignment_4 = (Assignment)cAlternatives.eContents().get(4);
		private final RuleCall cLLowerFunctionParserRuleCall_4_0 = (RuleCall)cLAssignment_4.eContents().get(0);
		private final Assignment cDAssignment_5 = (Assignment)cAlternatives.eContents().get(5);
		private final RuleCall cDDateConstantParserRuleCall_5_0 = (RuleCall)cDAssignment_5.eContents().get(0);
		
		//ComparisonPart:
		//	field=FieldPath | n= //Number
		//	INT | df=DateFunction | u=UpperFunction | l=LowerFunction | d=DateConstant;
		public ParserRule getRule() { return rule; }

		//field=FieldPath | n= //Number
		//INT | df=DateFunction | u=UpperFunction | l=LowerFunction | d=DateConstant
		public Alternatives getAlternatives() { return cAlternatives; }

		//field=FieldPath
		public Assignment getFieldAssignment_0() { return cFieldAssignment_0; }

		//FieldPath
		public RuleCall getFieldFieldPathParserRuleCall_0_0() { return cFieldFieldPathParserRuleCall_0_0; }

		//n= //Number
		//INT
		public Assignment getNAssignment_1() { return cNAssignment_1; }

		////Number
		//INT
		public RuleCall getNINTTerminalRuleCall_1_0() { return cNINTTerminalRuleCall_1_0; }

		//df=DateFunction
		public Assignment getDfAssignment_2() { return cDfAssignment_2; }

		//DateFunction
		public RuleCall getDfDateFunctionParserRuleCall_2_0() { return cDfDateFunctionParserRuleCall_2_0; }

		//u=UpperFunction
		public Assignment getUAssignment_3() { return cUAssignment_3; }

		//UpperFunction
		public RuleCall getUUpperFunctionParserRuleCall_3_0() { return cUUpperFunctionParserRuleCall_3_0; }

		//l=LowerFunction
		public Assignment getLAssignment_4() { return cLAssignment_4; }

		//LowerFunction
		public RuleCall getLLowerFunctionParserRuleCall_4_0() { return cLLowerFunctionParserRuleCall_4_0; }

		//d=DateConstant
		public Assignment getDAssignment_5() { return cDAssignment_5; }

		//DateConstant
		public RuleCall getDDateConstantParserRuleCall_5_0() { return cDDateConstantParserRuleCall_5_0; }
	}

	public class UpperFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UpperFunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cUpperKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cFieldAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cFieldFieldPathParserRuleCall_2_0 = (RuleCall)cFieldAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// here we pass only the type name of the argument, with the function as type
		//UpperFunction:
		//	"upper" "(" field=FieldPath ")";
		public ParserRule getRule() { return rule; }

		//"upper" "(" field=FieldPath ")"
		public Group getGroup() { return cGroup; }

		//"upper"
		public Keyword getUpperKeyword_0() { return cUpperKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//field=FieldPath
		public Assignment getFieldAssignment_2() { return cFieldAssignment_2; }

		//FieldPath
		public RuleCall getFieldFieldPathParserRuleCall_2_0() { return cFieldFieldPathParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class LowerFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LowerFunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLowerKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cFieldAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cFieldFieldPathParserRuleCall_2_0 = (RuleCall)cFieldAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// here we pass only the type name of the argument, with the function as type
		//LowerFunction:
		//	"lower" "(" field=FieldPath ")";
		public ParserRule getRule() { return rule; }

		//"lower" "(" field=FieldPath ")"
		public Group getGroup() { return cGroup; }

		//"lower"
		public Keyword getLowerKeyword_0() { return cLowerKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//field=FieldPath
		public Assignment getFieldAssignment_2() { return cFieldAssignment_2; }

		//FieldPath
		public RuleCall getFieldFieldPathParserRuleCall_2_0() { return cFieldFieldPathParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class OperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Operator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cEqualsSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cGreaterThanSignKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cLessThanSignEqualsSignKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cGreaterThanSignEqualsSignKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cExclamationMarkEqualsSignKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cCircumflexAccentEqualsSignKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cLessThanSignGreaterThanSignKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cLikeKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		
		//Operator returns ecore::EString:
		//	"=" | "<" | ">" | "<=" | ">=" | "!=" | "^=" | "<>" | "like";
		public ParserRule getRule() { return rule; }

		//"=" | "<" | ">" | "<=" | ">=" | "!=" | "^=" | "<>" | "like"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"="
		public Keyword getEqualsSignKeyword_0() { return cEqualsSignKeyword_0; }

		//"<"
		public Keyword getLessThanSignKeyword_1() { return cLessThanSignKeyword_1; }

		//">"
		public Keyword getGreaterThanSignKeyword_2() { return cGreaterThanSignKeyword_2; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_3() { return cLessThanSignEqualsSignKeyword_3; }

		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_4() { return cGreaterThanSignEqualsSignKeyword_4; }

		//"!="
		public Keyword getExclamationMarkEqualsSignKeyword_5() { return cExclamationMarkEqualsSignKeyword_5; }

		//"^="
		public Keyword getCircumflexAccentEqualsSignKeyword_6() { return cCircumflexAccentEqualsSignKeyword_6; }

		//"<>"
		public Keyword getLessThanSignGreaterThanSignKeyword_7() { return cLessThanSignGreaterThanSignKeyword_7; }

		//"like"
		public Keyword getLikeKeyword_8() { return cLikeKeyword_8; }
	}

	public class DateConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DateConstant");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cNowKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cTodayKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//DateConstant returns ecore::EString:
		//	"$now" | "$today";
		public ParserRule getRule() { return rule; }

		//"$now" | "$today"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"$now"
		public Keyword getNowKeyword_0() { return cNowKeyword_0; }

		//"$today"
		public Keyword getTodayKeyword_1() { return cTodayKeyword_1; }
	}

	public class DateFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DateFunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDateKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cDateFunctionArgumentParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final RuleCall cDateFunctionArgumentParserRuleCall_3_1 = (RuleCall)cGroup_3.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//DateFunction returns ecore::EString:
		//	"date" "(" DateFunctionArgument ("," DateFunctionArgument)* ")";
		public ParserRule getRule() { return rule; }

		//"date" "(" DateFunctionArgument ("," DateFunctionArgument)* ")"
		public Group getGroup() { return cGroup; }

		//"date"
		public Keyword getDateKeyword_0() { return cDateKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//DateFunctionArgument
		public RuleCall getDateFunctionArgumentParserRuleCall_2() { return cDateFunctionArgumentParserRuleCall_2; }

		//("," DateFunctionArgument)*
		public Group getGroup_3() { return cGroup_3; }

		//","
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//DateFunctionArgument
		public RuleCall getDateFunctionArgumentParserRuleCall_3_1() { return cDateFunctionArgumentParserRuleCall_3_1; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class DateFunctionArgumentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DateFunctionArgument");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cDateFunctionArgumentMemberParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_0_0 = (Keyword)cAlternatives_1_0.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_0_1 = (Keyword)cAlternatives_1_0.eContents().get(1);
		private final RuleCall cDateFunctionArgumentMemberParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//DateFunctionArgument returns ecore::EString:
		//	DateFunctionArgumentMember (("+" | "-") DateFunctionArgumentMember)?;
		public ParserRule getRule() { return rule; }

		//DateFunctionArgumentMember (("+" | "-") DateFunctionArgumentMember)?
		public Group getGroup() { return cGroup; }

		//DateFunctionArgumentMember
		public RuleCall getDateFunctionArgumentMemberParserRuleCall_0() { return cDateFunctionArgumentMemberParserRuleCall_0; }

		//(("+" | "-") DateFunctionArgumentMember)?
		public Group getGroup_1() { return cGroup_1; }

		//"+" | "-"
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//"+"
		public Keyword getPlusSignKeyword_1_0_0() { return cPlusSignKeyword_1_0_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1_0_1() { return cHyphenMinusKeyword_1_0_1; }

		//DateFunctionArgumentMember
		public RuleCall getDateFunctionArgumentMemberParserRuleCall_1_1() { return cDateFunctionArgumentMemberParserRuleCall_1_1; }
	}

	public class DateFunctionArgumentMemberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DateFunctionArgumentMember");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDateConstantParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//DateFunctionArgumentMember returns ecore::EString: //Number
		//	INT | DateConstant;
		public ParserRule getRule() { return rule; }

		////Number
		//INT | DateConstant
		public Alternatives getAlternatives() { return cAlternatives; }

		////Number
		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }

		//DateConstant
		public RuleCall getDateConstantParserRuleCall_1() { return cDateConstantParserRuleCall_1; }
	}

	public class RangeValidationRuleDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RangeValidationRuleDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cNameAlternatives_0_0 = (Alternatives)cNameAssignment_0.eContents().get(0);
		private final Keyword cNameRangeKeyword_0_0_0 = (Keyword)cNameAlternatives_0_0.eContents().get(0);
		private final Keyword cNameLengthKeyword_0_0_1 = (Keyword)cNameAlternatives_0_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cArgAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cArgFieldReferenceParserRuleCall_2_0 = (RuleCall)cArgAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cRangeAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cRangeRangeParserRuleCall_5_0 = (RuleCall)cRangeAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		////////// RANGE DEFINITION
		//RangeValidationRuleDeclaration:
		//	name=("range" | "length") "(" arg=FieldReference ")" "{" range=Range "}";
		public ParserRule getRule() { return rule; }

		//name=("range" | "length") "(" arg=FieldReference ")" "{" range=Range "}"
		public Group getGroup() { return cGroup; }

		//name=("range" | "length")
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"range" | "length"
		public Alternatives getNameAlternatives_0_0() { return cNameAlternatives_0_0; }

		//"range"
		public Keyword getNameRangeKeyword_0_0_0() { return cNameRangeKeyword_0_0_0; }

		//"length"
		public Keyword getNameLengthKeyword_0_0_1() { return cNameLengthKeyword_0_0_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//arg=FieldReference
		public Assignment getArgAssignment_2() { return cArgAssignment_2; }

		//FieldReference
		public RuleCall getArgFieldReferenceParserRuleCall_2_0() { return cArgFieldReferenceParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }

		//range=Range
		public Assignment getRangeAssignment_5() { return cRangeAssignment_5; }

		//Range
		public RuleCall getRangeRangeParserRuleCall_5_0() { return cRangeRangeParserRuleCall_5_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}

	public class RegexValidationRuleDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RegexValidationRuleDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameMatchesKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cArgAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cArgFieldReferenceParserRuleCall_2_0 = (RuleCall)cArgAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cExpAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cExpREGEXParserRuleCall_5_0 = (RuleCall)cExpAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//RegexValidationRuleDeclaration:
		//	name="matches" "(" arg=FieldReference ")" "{" exp=REGEX "}";
		public ParserRule getRule() { return rule; }

		//name="matches" "(" arg=FieldReference ")" "{" exp=REGEX "}"
		public Group getGroup() { return cGroup; }

		//name="matches"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"matches"
		public Keyword getNameMatchesKeyword_0_0() { return cNameMatchesKeyword_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//arg=FieldReference
		public Assignment getArgAssignment_2() { return cArgAssignment_2; }

		//FieldReference
		public RuleCall getArgFieldReferenceParserRuleCall_2_0() { return cArgFieldReferenceParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }

		//exp=REGEX
		public Assignment getExpAssignment_5() { return cExpAssignment_5; }

		//REGEX
		public RuleCall getExpREGEXParserRuleCall_5_0() { return cExpREGEXParserRuleCall_5_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}

	public class REGEXElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "REGEX");
		private final RuleCall cSTRINGTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//REGEX returns ecore::EString:
		//	STRING;
		public ParserRule getRule() { return rule; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall() { return cSTRINGTerminalRuleCall; }
	}

	public class RangeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Range");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFRangeBoundParserRuleCall_0_0 = (RuleCall)cFAssignment_0.eContents().get(0);
		private final Keyword cFullStopFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTRangeBoundParserRuleCall_2_0 = (RuleCall)cTAssignment_2.eContents().get(0);
		
		//// range(age) {18..99}  
		//Range:
		//	f=RangeBound ".." t=RangeBound;
		public ParserRule getRule() { return rule; }

		//f=RangeBound ".." t=RangeBound
		public Group getGroup() { return cGroup; }

		//f=RangeBound
		public Assignment getFAssignment_0() { return cFAssignment_0; }

		//RangeBound
		public RuleCall getFRangeBoundParserRuleCall_0_0() { return cFRangeBoundParserRuleCall_0_0; }

		//".."
		public Keyword getFullStopFullStopKeyword_1() { return cFullStopFullStopKeyword_1; }

		//t=RangeBound
		public Assignment getTAssignment_2() { return cTAssignment_2; }

		//RangeBound
		public RuleCall getTRangeBoundParserRuleCall_2_0() { return cTRangeBoundParserRuleCall_2_0; }
	}

	public class RangeBoundElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RangeBound");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Keyword cQuestionMarkKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//// [1..?] [?..5]
		//RangeBound returns ecore::EString:
		//	INT | "?";
		public ParserRule getRule() { return rule; }

		//INT | "?"
		public Alternatives getAlternatives() { return cAlternatives; }

		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }

		//"?"
		public Keyword getQuestionMarkKeyword_1() { return cQuestionMarkKeyword_1; }
	}

	public class UniquenessValidationRuleDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UniquenessValidationRuleDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameUniqueKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Assignment cArgsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cArgsFunctionArgumentsParserRuleCall_1_0 = (RuleCall)cArgsAssignment_1.eContents().get(0);
		
		//// unique(field1, field2) : "These need to be unique"
		//UniquenessValidationRuleDeclaration:
		//	name="unique" args=FunctionArguments;
		public ParserRule getRule() { return rule; }

		//name="unique" args=FunctionArguments
		public Group getGroup() { return cGroup; }

		//name="unique"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"unique"
		public Keyword getNameUniqueKeyword_0_0() { return cNameUniqueKeyword_0_0; }

		//args=FunctionArguments
		public Assignment getArgsAssignment_1() { return cArgsAssignment_1; }

		//FunctionArguments
		public RuleCall getArgsFunctionArgumentsParserRuleCall_1_0() { return cArgsFunctionArgumentsParserRuleCall_1_0; }
	}

	public class ErrorMessageElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ErrorMessage");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cColonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cMessageAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cMessageSTRINGTerminalRuleCall_1_0 = (RuleCall)cMessageAssignment_1.eContents().get(0);
		
		//ErrorMessage:
		//	":" message=STRING;
		public ParserRule getRule() { return rule; }

		//":" message=STRING
		public Group getGroup() { return cGroup; }

		//":"
		public Keyword getColonKeyword_0() { return cColonKeyword_0; }

		//message=STRING
		public Assignment getMessageAssignment_1() { return cMessageAssignment_1; }

		//STRING
		public RuleCall getMessageSTRINGTerminalRuleCall_1_0() { return cMessageSTRINGTerminalRuleCall_1_0; }
	}

	public class NativeValidationRuleDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NativeValidationRuleDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFieldAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cFieldFieldDeclarationCrossReference_0_0 = (CrossReference)cFieldAssignment_0.eContents().get(0);
		private final RuleCall cFieldFieldDeclarationIDTerminalRuleCall_0_0_1 = (RuleCall)cFieldFieldDeclarationCrossReference_0_0.eContents().get(1);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cTypeAlternatives_2_0 = (Alternatives)cTypeAssignment_2.eContents().get(0);
		private final Keyword cTypeUniqueKeyword_2_0_0 = (Keyword)cTypeAlternatives_2_0.eContents().get(0);
		private final Keyword cTypeNotNullKeyword_2_0_1 = (Keyword)cTypeAlternatives_2_0.eContents().get(1);
		private final Keyword cTypeNaNKeyword_2_0_2 = (Keyword)cTypeAlternatives_2_0.eContents().get(2);
		private final Keyword cTypeNotEmptyKeyword_2_0_3 = (Keyword)cTypeAlternatives_2_0.eContents().get(3);
		private final Keyword cTypeNotIntKeyword_2_0_4 = (Keyword)cTypeAlternatives_2_0.eContents().get(4);
		private final Keyword cTypeNotRealKeyword_2_0_5 = (Keyword)cTypeAlternatives_2_0.eContents().get(5);
		private final Keyword cTypeNotBooleanKeyword_2_0_6 = (Keyword)cTypeAlternatives_2_0.eContents().get(6);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cMessageAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cMessageSTRINGTerminalRuleCall_4_0 = (RuleCall)cMessageAssignment_4.eContents().get(0);
		
		//NativeValidationRuleDeclaration:
		//	field=[FieldDeclaration] "." type=("unique" | "notNull" | "NaN" | "notEmpty" | "notInt" | "notReal" | "notBoolean")
		//	"=" message=STRING;
		public ParserRule getRule() { return rule; }

		//field=[FieldDeclaration] "." type=("unique" | "notNull" | "NaN" | "notEmpty" | "notInt" | "notReal" | "notBoolean") "="
		//message=STRING
		public Group getGroup() { return cGroup; }

		//field=[FieldDeclaration]
		public Assignment getFieldAssignment_0() { return cFieldAssignment_0; }

		//[FieldDeclaration]
		public CrossReference getFieldFieldDeclarationCrossReference_0_0() { return cFieldFieldDeclarationCrossReference_0_0; }

		//ID
		public RuleCall getFieldFieldDeclarationIDTerminalRuleCall_0_0_1() { return cFieldFieldDeclarationIDTerminalRuleCall_0_0_1; }

		//"."
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }

		//type=("unique" | "notNull" | "NaN" | "notEmpty" | "notInt" | "notReal" | "notBoolean")
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }

		//"unique" | "notNull" | "NaN" | "notEmpty" | "notInt" | "notReal" | "notBoolean"
		public Alternatives getTypeAlternatives_2_0() { return cTypeAlternatives_2_0; }

		//"unique"
		public Keyword getTypeUniqueKeyword_2_0_0() { return cTypeUniqueKeyword_2_0_0; }

		//"notNull"
		public Keyword getTypeNotNullKeyword_2_0_1() { return cTypeNotNullKeyword_2_0_1; }

		//"NaN"
		public Keyword getTypeNaNKeyword_2_0_2() { return cTypeNaNKeyword_2_0_2; }

		//"notEmpty"
		public Keyword getTypeNotEmptyKeyword_2_0_3() { return cTypeNotEmptyKeyword_2_0_3; }

		//"notInt"
		public Keyword getTypeNotIntKeyword_2_0_4() { return cTypeNotIntKeyword_2_0_4; }

		//"notReal"
		public Keyword getTypeNotRealKeyword_2_0_5() { return cTypeNotRealKeyword_2_0_5; }

		//"notBoolean"
		public Keyword getTypeNotBooleanKeyword_2_0_6() { return cTypeNotBooleanKeyword_2_0_6; }

		//"="
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }

		//message=STRING
		public Assignment getMessageAssignment_4() { return cMessageAssignment_4; }

		//STRING
		public RuleCall getMessageSTRINGTerminalRuleCall_4_0() { return cMessageSTRINGTerminalRuleCall_4_0; }
	}

	public class FunctionDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cBAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cBIDTerminalRuleCall_0_0_0 = (RuleCall)cBAssignment_0_0.eContents().get(0);
		private final Keyword cPercentSignKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cArgAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cArgFunctionArgumentDeclarationParserRuleCall_2_0 = (RuleCall)cArgAssignment_2.eContents().get(0);
		private final Assignment cBodyAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBodyFunctionBodyParserRuleCall_3_0 = (RuleCall)cBodyAssignment_3.eContents().get(0);
		private final Assignment cMAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cMErrorMessageParserRuleCall_4_0 = (RuleCall)cMAssignment_4.eContents().get(0);
		
		/////// Functions
		//FunctionDeclaration:
		//	(b=ID "%")? name=ID arg=FunctionArgumentDeclaration body=FunctionBody m=ErrorMessage?;
		public ParserRule getRule() { return rule; }

		//(b=ID "%")? name=ID arg=FunctionArgumentDeclaration body=FunctionBody m=ErrorMessage?
		public Group getGroup() { return cGroup; }

		//(b=ID "%")?
		public Group getGroup_0() { return cGroup_0; }

		//b=ID
		public Assignment getBAssignment_0_0() { return cBAssignment_0_0; }

		//ID
		public RuleCall getBIDTerminalRuleCall_0_0_0() { return cBIDTerminalRuleCall_0_0_0; }

		//"%"
		public Keyword getPercentSignKeyword_0_1() { return cPercentSignKeyword_0_1; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//arg=FunctionArgumentDeclaration
		public Assignment getArgAssignment_2() { return cArgAssignment_2; }

		//FunctionArgumentDeclaration
		public RuleCall getArgFunctionArgumentDeclarationParserRuleCall_2_0() { return cArgFunctionArgumentDeclarationParserRuleCall_2_0; }

		//body=FunctionBody
		public Assignment getBodyAssignment_3() { return cBodyAssignment_3; }

		//FunctionBody
		public RuleCall getBodyFunctionBodyParserRuleCall_3_0() { return cBodyFunctionBodyParserRuleCall_3_0; }

		//m=ErrorMessage?
		public Assignment getMAssignment_4() { return cMAssignment_4; }

		//ErrorMessage
		public RuleCall getMErrorMessageParserRuleCall_4_0() { return cMErrorMessageParserRuleCall_4_0; }
	}

	public class FunctionArgumentDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionArgumentDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFunctionArgumentDeclarationAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cFAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cFFunctionArgumentBodyParserRuleCall_2_0 = (RuleCall)cFAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cFAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cFFunctionArgumentBodyParserRuleCall_3_1_0 = (RuleCall)cFAssignment_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//FunctionArgumentDeclaration:
		//	{FunctionArgumentDeclaration} "(" f+=FunctionArgumentBody? ("," f+=FunctionArgumentBody)* ")";
		public ParserRule getRule() { return rule; }

		//{FunctionArgumentDeclaration} "(" f+=FunctionArgumentBody? ("," f+=FunctionArgumentBody)* ")"
		public Group getGroup() { return cGroup; }

		//{FunctionArgumentDeclaration}
		public Action getFunctionArgumentDeclarationAction_0() { return cFunctionArgumentDeclarationAction_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//f+=FunctionArgumentBody?
		public Assignment getFAssignment_2() { return cFAssignment_2; }

		//FunctionArgumentBody
		public RuleCall getFFunctionArgumentBodyParserRuleCall_2_0() { return cFFunctionArgumentBodyParserRuleCall_2_0; }

		//("," f+=FunctionArgumentBody)*
		public Group getGroup_3() { return cGroup_3; }

		//","
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//f+=FunctionArgumentBody
		public Assignment getFAssignment_3_1() { return cFAssignment_3_1; }

		//FunctionArgumentBody
		public RuleCall getFFunctionArgumentBodyParserRuleCall_3_1_0() { return cFFunctionArgumentBodyParserRuleCall_3_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class FunctionArgumentBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionArgumentBody");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cCharTypeParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cIntEnumParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final Group cGroup_0_2 = (Group)cAlternatives_0.eContents().get(2);
		private final Keyword cSetKeyword_0_2_0 = (Keyword)cGroup_0_2.eContents().get(0);
		private final RuleCall cIntEnumParserRuleCall_0_2_1 = (RuleCall)cGroup_0_2.eContents().get(1);
		private final RuleCall cCharEnumParserRuleCall_0_3 = (RuleCall)cAlternatives_0.eContents().get(3);
		private final Group cGroup_0_4 = (Group)cAlternatives_0.eContents().get(4);
		private final Keyword cSetKeyword_0_4_0 = (Keyword)cGroup_0_4.eContents().get(0);
		private final RuleCall cCharEnumParserRuleCall_0_4_1 = (RuleCall)cGroup_0_4.eContents().get(1);
		private final Keyword cIntKeyword_0_5 = (Keyword)cAlternatives_0.eContents().get(5);
		private final Keyword cRealKeyword_0_6 = (Keyword)cAlternatives_0.eContents().get(6);
		private final Keyword cBooleanKeyword_0_7 = (Keyword)cAlternatives_0.eContents().get(7);
		private final Keyword cTextKeyword_0_8 = (Keyword)cAlternatives_0.eContents().get(8);
		private final Keyword cBinaryKeyword_0_9 = (Keyword)cAlternatives_0.eContents().get(9);
		private final Keyword cFileKeyword_0_10 = (Keyword)cAlternatives_0.eContents().get(10);
		private final Keyword cDateKeyword_0_11 = (Keyword)cAlternatives_0.eContents().get(11);
		private final Group cGroup_0_12 = (Group)cAlternatives_0.eContents().get(12);
		private final Keyword cPtrKeyword_0_12_0 = (Keyword)cGroup_0_12.eContents().get(0);
		private final RuleCall cTypeParserRuleCall_0_12_1 = (RuleCall)cGroup_0_12.eContents().get(1);
		private final Group cGroup_0_13 = (Group)cAlternatives_0.eContents().get(13);
		private final Keyword cSetKeyword_0_13_0 = (Keyword)cGroup_0_13.eContents().get(0);
		private final RuleCall cTypeParserRuleCall_0_13_1 = (RuleCall)cGroup_0_13.eContents().get(1);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIdOrKeywordParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//// TODO: fix this so that function label can show param type instead of the name
		//// ugly fix until the syntax change
		////	FieldType arg=(ID|Keyword)
		//FunctionArgumentBody:
		//	(CharType | IntEnum | "set" IntEnum | CharEnum | "set" CharEnum | "int" | "real" | "boolean" | "text" | "binary" |
		//	"file" | "date" | "ptr" Type | "set" Type) name=IdOrKeyword;
		public ParserRule getRule() { return rule; }

		//(CharType | IntEnum | "set" IntEnum | CharEnum | "set" CharEnum | "int" | "real" | "boolean" | "text" | "binary" |
		//"file" | "date" | "ptr" Type | "set" Type) name=IdOrKeyword
		public Group getGroup() { return cGroup; }

		//CharType | IntEnum | "set" IntEnum | CharEnum | "set" CharEnum | "int" | "real" | "boolean" | "text" | "binary" | "file"
		//| "date" | "ptr" Type | "set" Type
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//CharType
		public RuleCall getCharTypeParserRuleCall_0_0() { return cCharTypeParserRuleCall_0_0; }

		//IntEnum
		public RuleCall getIntEnumParserRuleCall_0_1() { return cIntEnumParserRuleCall_0_1; }

		//"set" IntEnum
		public Group getGroup_0_2() { return cGroup_0_2; }

		//"set"
		public Keyword getSetKeyword_0_2_0() { return cSetKeyword_0_2_0; }

		//IntEnum
		public RuleCall getIntEnumParserRuleCall_0_2_1() { return cIntEnumParserRuleCall_0_2_1; }

		//CharEnum
		public RuleCall getCharEnumParserRuleCall_0_3() { return cCharEnumParserRuleCall_0_3; }

		//"set" CharEnum
		public Group getGroup_0_4() { return cGroup_0_4; }

		//"set"
		public Keyword getSetKeyword_0_4_0() { return cSetKeyword_0_4_0; }

		//CharEnum
		public RuleCall getCharEnumParserRuleCall_0_4_1() { return cCharEnumParserRuleCall_0_4_1; }

		//"int"
		public Keyword getIntKeyword_0_5() { return cIntKeyword_0_5; }

		//"real"
		public Keyword getRealKeyword_0_6() { return cRealKeyword_0_6; }

		//"boolean"
		public Keyword getBooleanKeyword_0_7() { return cBooleanKeyword_0_7; }

		//"text"
		public Keyword getTextKeyword_0_8() { return cTextKeyword_0_8; }

		//"binary"
		public Keyword getBinaryKeyword_0_9() { return cBinaryKeyword_0_9; }

		//"file"
		public Keyword getFileKeyword_0_10() { return cFileKeyword_0_10; }

		//"date"
		public Keyword getDateKeyword_0_11() { return cDateKeyword_0_11; }

		//"ptr" Type
		public Group getGroup_0_12() { return cGroup_0_12; }

		//"ptr"
		public Keyword getPtrKeyword_0_12_0() { return cPtrKeyword_0_12_0; }

		//Type
		public RuleCall getTypeParserRuleCall_0_12_1() { return cTypeParserRuleCall_0_12_1; }

		//"set" Type
		public Group getGroup_0_13() { return cGroup_0_13; }

		//"set"
		public Keyword getSetKeyword_0_13_0() { return cSetKeyword_0_13_0; }

		//Type
		public RuleCall getTypeParserRuleCall_0_13_1() { return cTypeParserRuleCall_0_13_1; }

		//name=IdOrKeyword
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//IdOrKeyword
		public RuleCall getNameIdOrKeywordParserRuleCall_1_0() { return cNameIdOrKeywordParserRuleCall_1_0; }
	}

	public class FunctionCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFunctionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cFunctionFunctionDeclarationCrossReference_0_0 = (CrossReference)cFunctionAssignment_0.eContents().get(0);
		private final RuleCall cFunctionFunctionDeclarationIDTerminalRuleCall_0_0_1 = (RuleCall)cFunctionFunctionDeclarationCrossReference_0_0.eContents().get(1);
		private final Assignment cFAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFFunctionArgumentsParserRuleCall_1_0 = (RuleCall)cFAssignment_1.eContents().get(0);
		
		//FunctionCall:
		//	function=[FunctionDeclaration] f=FunctionArguments;
		public ParserRule getRule() { return rule; }

		//function=[FunctionDeclaration] f=FunctionArguments
		public Group getGroup() { return cGroup; }

		//function=[FunctionDeclaration]
		public Assignment getFunctionAssignment_0() { return cFunctionAssignment_0; }

		//[FunctionDeclaration]
		public CrossReference getFunctionFunctionDeclarationCrossReference_0_0() { return cFunctionFunctionDeclarationCrossReference_0_0; }

		//ID
		public RuleCall getFunctionFunctionDeclarationIDTerminalRuleCall_0_0_1() { return cFunctionFunctionDeclarationIDTerminalRuleCall_0_0_1; }

		//f=FunctionArguments
		public Assignment getFAssignment_1() { return cFAssignment_1; }

		//FunctionArguments
		public RuleCall getFFunctionArgumentsParserRuleCall_1_0() { return cFFunctionArgumentsParserRuleCall_1_0; }
	}

	public class FieldPathElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FieldPath");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFieldAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cFieldFieldDeclarationCrossReference_0_0 = (CrossReference)cFieldAssignment_0.eContents().get(0);
		private final RuleCall cFieldFieldDeclarationIdOrKeywordParserRuleCall_0_0_1 = (RuleCall)cFieldFieldDeclarationCrossReference_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cSubFieldAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cSubFieldFieldPathParserRuleCall_1_1_0 = (RuleCall)cSubFieldAssignment_1_1.eContents().get(0);
		
		//FieldPath:
		//	field=[FieldDeclaration|IdOrKeyword] ("." subField=FieldPath)?;
		public ParserRule getRule() { return rule; }

		//field=[FieldDeclaration|IdOrKeyword] ("." subField=FieldPath)?
		public Group getGroup() { return cGroup; }

		//field=[FieldDeclaration|IdOrKeyword]
		public Assignment getFieldAssignment_0() { return cFieldAssignment_0; }

		//[FieldDeclaration|IdOrKeyword]
		public CrossReference getFieldFieldDeclarationCrossReference_0_0() { return cFieldFieldDeclarationCrossReference_0_0; }

		//IdOrKeyword
		public RuleCall getFieldFieldDeclarationIdOrKeywordParserRuleCall_0_0_1() { return cFieldFieldDeclarationIdOrKeywordParserRuleCall_0_0_1; }

		//("." subField=FieldPath)?
		public Group getGroup_1() { return cGroup_1; }

		//"."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//subField=FieldPath
		public Assignment getSubFieldAssignment_1_1() { return cSubFieldAssignment_1_1; }

		//FieldPath
		public RuleCall getSubFieldFieldPathParserRuleCall_1_1_0() { return cSubFieldFieldPathParserRuleCall_1_1_0; }
	}

	public class FieldReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FieldReference");
		private final Assignment cFieldAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cFieldFieldDeclarationCrossReference_0 = (CrossReference)cFieldAssignment.eContents().get(0);
		private final RuleCall cFieldFieldDeclarationIdOrKeywordParserRuleCall_0_1 = (RuleCall)cFieldFieldDeclarationCrossReference_0.eContents().get(1);
		
		//FieldReference:
		//	field=[FieldDeclaration|IdOrKeyword];
		public ParserRule getRule() { return rule; }

		//field=[FieldDeclaration|IdOrKeyword]
		public Assignment getFieldAssignment() { return cFieldAssignment; }

		//[FieldDeclaration|IdOrKeyword]
		public CrossReference getFieldFieldDeclarationCrossReference_0() { return cFieldFieldDeclarationCrossReference_0; }

		//IdOrKeyword
		public RuleCall getFieldFieldDeclarationIdOrKeywordParserRuleCall_0_1() { return cFieldFieldDeclarationIdOrKeywordParserRuleCall_0_1; }
	}

	public class FunctionArgumentsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionArguments");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFunctionArgumentsAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cArgsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cArgsFieldPathParserRuleCall_2_0_0 = (RuleCall)cArgsAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cArgsAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cArgsFieldPathParserRuleCall_2_1_1_0 = (RuleCall)cArgsAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//FunctionArguments:
		//	{FunctionArguments} "(" (args+=FieldPath ("," args+=FieldPath)*)? ")";
		public ParserRule getRule() { return rule; }

		//{FunctionArguments} "(" (args+=FieldPath ("," args+=FieldPath)*)? ")"
		public Group getGroup() { return cGroup; }

		//{FunctionArguments}
		public Action getFunctionArgumentsAction_0() { return cFunctionArgumentsAction_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(args+=FieldPath ("," args+=FieldPath)*)?
		public Group getGroup_2() { return cGroup_2; }

		//args+=FieldPath
		public Assignment getArgsAssignment_2_0() { return cArgsAssignment_2_0; }

		//FieldPath
		public RuleCall getArgsFieldPathParserRuleCall_2_0_0() { return cArgsFieldPathParserRuleCall_2_0_0; }

		//("," args+=FieldPath)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//args+=FieldPath
		public Assignment getArgsAssignment_2_1_1() { return cArgsAssignment_2_1_1; }

		//FieldPath
		public RuleCall getArgsFieldPathParserRuleCall_2_1_1_0() { return cArgsFieldPathParserRuleCall_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class FunctionBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionBody");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cSAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cSStatementParserRuleCall_1_0_0 = (RuleCall)cSAssignment_1_0.eContents().get(0);
		private final Assignment cEAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_1_1_0 = (RuleCall)cEAssignment_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//FunctionBody:
		//	"{" (s=Statement | e=Expression) "}";
		public ParserRule getRule() { return rule; }

		//"{" (s=Statement | e=Expression) "}"
		public Group getGroup() { return cGroup; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_0() { return cLeftCurlyBracketKeyword_0; }

		//s=Statement | e=Expression
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//s=Statement
		public Assignment getSAssignment_1_0() { return cSAssignment_1_0; }

		//Statement
		public RuleCall getSStatementParserRuleCall_1_0_0() { return cSStatementParserRuleCall_1_0_0; }

		//e=Expression
		public Assignment getEAssignment_1_1() { return cEAssignment_1_1; }

		//Expression
		public RuleCall getEExpressionParserRuleCall_1_1_0() { return cEExpressionParserRuleCall_1_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_2() { return cRightCurlyBracketKeyword_2; }
	}

	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Statement");
		private final RuleCall cQueryRuleParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		/////// HQL stuff
		//Statement:
		//	QueryRule;
		public ParserRule getRule() { return rule; }

		//QueryRule
		public RuleCall getQueryRuleParserRuleCall() { return cQueryRuleParserRuleCall; }
	}

	public class UnionRuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnionRule");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cQAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cQQueryRuleParserRuleCall_0_0 = (RuleCall)cQAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cUnionKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cQAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cQQueryRuleParserRuleCall_1_1_0 = (RuleCall)cQAssignment_1_1.eContents().get(0);
		
		//UnionRule:
		//	q+=QueryRule ("union" q+=QueryRule)*;
		public ParserRule getRule() { return rule; }

		//q+=QueryRule ("union" q+=QueryRule)*
		public Group getGroup() { return cGroup; }

		//q+=QueryRule
		public Assignment getQAssignment_0() { return cQAssignment_0; }

		//QueryRule
		public RuleCall getQQueryRuleParserRuleCall_0_0() { return cQQueryRuleParserRuleCall_0_0; }

		//("union" q+=QueryRule)*
		public Group getGroup_1() { return cGroup_1; }

		//"union"
		public Keyword getUnionKeyword_1_0() { return cUnionKeyword_1_0; }

		//q+=QueryRule
		public Assignment getQAssignment_1_1() { return cQAssignment_1_1; }

		//QueryRule
		public RuleCall getQQueryRuleParserRuleCall_1_1_0() { return cQQueryRuleParserRuleCall_1_1_0; }
	}

	public class QueryRuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QueryRule");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSelectFromParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cWhereAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cWhereWhereClauseParserRuleCall_1_0 = (RuleCall)cWhereAssignment_1.eContents().get(0);
		private final Assignment cGroupByAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cGroupByGroupByClauseParserRuleCall_2_0 = (RuleCall)cGroupByAssignment_2.eContents().get(0);
		private final Assignment cOrderByAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cOrderByOrderByClauseParserRuleCall_3_0 = (RuleCall)cOrderByAssignment_3.eContents().get(0);
		
		////## query:
		////##     [SelectClause] FromClause [WhereClause] [GroupByClause] [HavingClause] [OrderByClause];
		//QueryRule:
		//	SelectFrom where=WhereClause? groupBy=GroupByClause? orderBy=OrderByClause?;
		public ParserRule getRule() { return rule; }

		//SelectFrom where=WhereClause? groupBy=GroupByClause? orderBy=OrderByClause?
		public Group getGroup() { return cGroup; }

		//SelectFrom
		public RuleCall getSelectFromParserRuleCall_0() { return cSelectFromParserRuleCall_0; }

		//where=WhereClause?
		public Assignment getWhereAssignment_1() { return cWhereAssignment_1; }

		//WhereClause
		public RuleCall getWhereWhereClauseParserRuleCall_1_0() { return cWhereWhereClauseParserRuleCall_1_0; }

		//groupBy=GroupByClause?
		public Assignment getGroupByAssignment_2() { return cGroupByAssignment_2; }

		//GroupByClause
		public RuleCall getGroupByGroupByClauseParserRuleCall_2_0() { return cGroupByGroupByClauseParserRuleCall_2_0; }

		//orderBy=OrderByClause?
		public Assignment getOrderByAssignment_3() { return cOrderByAssignment_3; }

		//OrderByClause
		public RuleCall getOrderByOrderByClauseParserRuleCall_3_0() { return cOrderByOrderByClauseParserRuleCall_3_0; }
	}

	public class SelectFromElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SelectFrom");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSelectFromAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cSAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSSelectClauseParserRuleCall_1_0 = (RuleCall)cSAssignment_1.eContents().get(0);
		private final Assignment cFromAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cFromFromClauseParserRuleCall_2_0 = (RuleCall)cFromAssignment_2.eContents().get(0);
		
		//SelectFrom:
		//	{SelectFrom} s=SelectClause? from=FromClause?;
		public ParserRule getRule() { return rule; }

		//{SelectFrom} s=SelectClause? from=FromClause?
		public Group getGroup() { return cGroup; }

		//{SelectFrom}
		public Action getSelectFromAction_0() { return cSelectFromAction_0; }

		//s=SelectClause?
		public Assignment getSAssignment_1() { return cSAssignment_1; }

		//SelectClause
		public RuleCall getSSelectClauseParserRuleCall_1_0() { return cSSelectClauseParserRuleCall_1_0; }

		//from=FromClause?
		public Assignment getFromAssignment_2() { return cFromAssignment_2; }

		//FromClause
		public RuleCall getFromFromClauseParserRuleCall_2_0() { return cFromFromClauseParserRuleCall_2_0; }
	}

	public class SelectClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SelectClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSelectClauseAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cSELECTParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cDISTINCTParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Assignment cSAssignment_3_0 = (Assignment)cAlternatives_3.eContents().get(0);
		private final RuleCall cSSelectedPropertiesListParserRuleCall_3_0_0 = (RuleCall)cSAssignment_3_0.eContents().get(0);
		private final Assignment cNAssignment_3_1 = (Assignment)cAlternatives_3.eContents().get(1);
		private final RuleCall cNNewExpressionParserRuleCall_3_1_0 = (RuleCall)cNAssignment_3_1.eContents().get(0);
		private final RuleCall cSelectObjectParserRuleCall_3_2 = (RuleCall)cAlternatives_3.eContents().get(2);
		
		////## SelectClause:
		////##     SELECT DISTINCT? SelectedPropertiesList | ( NEW className OPEN SelectedPropertiesList CLOSE );
		//SelectClause:
		//	{SelectClause} SELECT DISTINCT? (s=SelectedPropertiesList | n=NewExpression | SelectObject);
		public ParserRule getRule() { return rule; }

		//{SelectClause} SELECT DISTINCT? (s=SelectedPropertiesList | n=NewExpression | SelectObject)
		public Group getGroup() { return cGroup; }

		//{SelectClause}
		public Action getSelectClauseAction_0() { return cSelectClauseAction_0; }

		//SELECT
		public RuleCall getSELECTParserRuleCall_1() { return cSELECTParserRuleCall_1; }

		//DISTINCT?
		public RuleCall getDISTINCTParserRuleCall_2() { return cDISTINCTParserRuleCall_2; }

		//s=SelectedPropertiesList | n=NewExpression | SelectObject
		public Alternatives getAlternatives_3() { return cAlternatives_3; }

		//s=SelectedPropertiesList
		public Assignment getSAssignment_3_0() { return cSAssignment_3_0; }

		//SelectedPropertiesList
		public RuleCall getSSelectedPropertiesListParserRuleCall_3_0_0() { return cSSelectedPropertiesListParserRuleCall_3_0_0; }

		//n=NewExpression
		public Assignment getNAssignment_3_1() { return cNAssignment_3_1; }

		//NewExpression
		public RuleCall getNNewExpressionParserRuleCall_3_1_0() { return cNNewExpressionParserRuleCall_3_1_0; }

		//SelectObject
		public RuleCall getSelectObjectParserRuleCall_3_2() { return cSelectObjectParserRuleCall_3_2; }
	}

	public class NewExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NewExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNEWParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cPAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPPathParserRuleCall_1_0 = (RuleCall)cPAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cSAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cSSelectedPropertiesListParserRuleCall_3_0 = (RuleCall)cSAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//NewExpression:
		//	NEW p=Path "(" s=SelectedPropertiesList ")";
		public ParserRule getRule() { return rule; }

		//NEW p=Path "(" s=SelectedPropertiesList ")"
		public Group getGroup() { return cGroup; }

		//NEW
		public RuleCall getNEWParserRuleCall_0() { return cNEWParserRuleCall_0; }

		//p=Path
		public Assignment getPAssignment_1() { return cPAssignment_1; }

		//Path
		public RuleCall getPPathParserRuleCall_1_0() { return cPPathParserRuleCall_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//s=SelectedPropertiesList
		public Assignment getSAssignment_3() { return cSAssignment_3; }

		//SelectedPropertiesList
		public RuleCall getSSelectedPropertiesListParserRuleCall_3_0() { return cSSelectedPropertiesListParserRuleCall_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class SelectObjectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SelectObject");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOBJECTParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cIdentifierParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//SelectObject returns ecore::EString:
		//	OBJECT "(" Identifier ")";
		public ParserRule getRule() { return rule; }

		//OBJECT "(" Identifier ")"
		public Group getGroup() { return cGroup; }

		//OBJECT
		public RuleCall getOBJECTParserRuleCall_0() { return cOBJECTParserRuleCall_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//Identifier
		public RuleCall getIdentifierParserRuleCall_2() { return cIdentifierParserRuleCall_2; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class FromClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FromClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cFROMParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cFromRangeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFromRangeFromRangeParserRuleCall_1_0 = (RuleCall)cFromRangeAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cFromJoinAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cFromJoinFromJoinParserRuleCall_2_0_0 = (RuleCall)cFromJoinAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cAlternatives_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cFromRangeAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cFromRangeFromRangeParserRuleCall_2_1_1_0 = (RuleCall)cFromRangeAssignment_2_1_1.eContents().get(0);
		
		////## FromClause:
		////##    FROM className AS? Identifier (  ( ',' className AS? Identifier ) | ( joinType Path AS? Identifier ) )*;
		//// NOTE: This *must* begin with the "FROM" token, otherwise the sub-query rule will be ambiguous
		//// with the expression rule.
		//// Also note: after a comma weak keywords are allowed and should be treated as identifiers.
		//FromClause:
		//	FROM fromRange+=FromRange (fromJoin+=FromJoin | "," fromRange+=FromRange)*;
		public ParserRule getRule() { return rule; }

		//FROM fromRange+=FromRange (fromJoin+=FromJoin | "," fromRange+=FromRange)*
		public Group getGroup() { return cGroup; }

		//FROM
		public RuleCall getFROMParserRuleCall_0() { return cFROMParserRuleCall_0; }

		//fromRange+=FromRange
		public Assignment getFromRangeAssignment_1() { return cFromRangeAssignment_1; }

		//FromRange
		public RuleCall getFromRangeFromRangeParserRuleCall_1_0() { return cFromRangeFromRangeParserRuleCall_1_0; }

		//(fromJoin+=FromJoin | "," fromRange+=FromRange)*
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//fromJoin+=FromJoin
		public Assignment getFromJoinAssignment_2_0() { return cFromJoinAssignment_2_0; }

		//FromJoin
		public RuleCall getFromJoinFromJoinParserRuleCall_2_0_0() { return cFromJoinFromJoinParserRuleCall_2_0_0; }

		//"," fromRange+=FromRange
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//fromRange+=FromRange
		public Assignment getFromRangeAssignment_2_1_1() { return cFromRangeAssignment_2_1_1; }

		//FromRange
		public RuleCall getFromRangeFromRangeParserRuleCall_2_1_1_0() { return cFromRangeFromRangeParserRuleCall_2_1_1_0; }
	}

	public class FromJoinElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FromJoin");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cAlternatives_0.eContents().get(0);
		private final Alternatives cAlternatives_0_0_0 = (Alternatives)cGroup_0_0.eContents().get(0);
		private final RuleCall cLEFTParserRuleCall_0_0_0_0 = (RuleCall)cAlternatives_0_0_0.eContents().get(0);
		private final RuleCall cRIGHTParserRuleCall_0_0_0_1 = (RuleCall)cAlternatives_0_0_0.eContents().get(1);
		private final RuleCall cOUTERParserRuleCall_0_0_1 = (RuleCall)cGroup_0_0.eContents().get(1);
		private final RuleCall cFULLParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final RuleCall cINNERParserRuleCall_0_2 = (RuleCall)cAlternatives_0.eContents().get(2);
		private final RuleCall cJOINParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cFETCHParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final RuleCall cFromClassOrOuterQueryPathParserRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cWAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cWWithClauseParserRuleCall_4_0 = (RuleCall)cWAssignment_4.eContents().get(0);
		
		////## joinType:
		////##     ( ( 'left'|'right' 'outer'? ) | 'full' | 'inner' )? JOIN FETCH?;
		//FromJoin:
		//	((LEFT | RIGHT) OUTER? | FULL | INNER)? JOIN FETCH? FromClassOrOuterQueryPath w=WithClause?;
		public ParserRule getRule() { return rule; }

		//((LEFT | RIGHT) OUTER? | FULL | INNER)? JOIN FETCH? FromClassOrOuterQueryPath w=WithClause?
		public Group getGroup() { return cGroup; }

		//((LEFT | RIGHT) OUTER? | FULL | INNER)?
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//(LEFT | RIGHT) OUTER?
		public Group getGroup_0_0() { return cGroup_0_0; }

		//LEFT | RIGHT
		public Alternatives getAlternatives_0_0_0() { return cAlternatives_0_0_0; }

		//LEFT
		public RuleCall getLEFTParserRuleCall_0_0_0_0() { return cLEFTParserRuleCall_0_0_0_0; }

		//RIGHT
		public RuleCall getRIGHTParserRuleCall_0_0_0_1() { return cRIGHTParserRuleCall_0_0_0_1; }

		//OUTER?
		public RuleCall getOUTERParserRuleCall_0_0_1() { return cOUTERParserRuleCall_0_0_1; }

		//FULL
		public RuleCall getFULLParserRuleCall_0_1() { return cFULLParserRuleCall_0_1; }

		//INNER
		public RuleCall getINNERParserRuleCall_0_2() { return cINNERParserRuleCall_0_2; }

		//JOIN
		public RuleCall getJOINParserRuleCall_1() { return cJOINParserRuleCall_1; }

		//FETCH?
		public RuleCall getFETCHParserRuleCall_2() { return cFETCHParserRuleCall_2; }

		//FromClassOrOuterQueryPath
		public RuleCall getFromClassOrOuterQueryPathParserRuleCall_3() { return cFromClassOrOuterQueryPathParserRuleCall_3; }

		//w=WithClause?
		public Assignment getWAssignment_4() { return cWAssignment_4; }

		//WithClause
		public RuleCall getWWithClauseParserRuleCall_4_0() { return cWWithClauseParserRuleCall_4_0; }
	}

	public class WithClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WithClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cWITHParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cEAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_1_0 = (RuleCall)cEAssignment_1.eContents().get(0);
		
		//WithClause:
		//	WITH e=Expression;
		public ParserRule getRule() { return rule; }

		//WITH e=Expression
		public Group getGroup() { return cGroup; }

		//WITH
		public RuleCall getWITHParserRuleCall_0() { return cWITHParserRuleCall_0; }

		//e=Expression
		public Assignment getEAssignment_1() { return cEAssignment_1; }

		//Expression
		public RuleCall getEExpressionParserRuleCall_1_0() { return cEExpressionParserRuleCall_1_0; }
	}

	public class FromRangeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FromRange");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFromClassOrOuterQueryPathParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cAliasAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cAliasIdentifierParserRuleCall_1_0_0 = (RuleCall)cAliasAssignment_1_0.eContents().get(0);
		private final RuleCall cIN_CLASSParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cPAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cPPathParserRuleCall_1_2_0 = (RuleCall)cPAssignment_1_2.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final RuleCall cINParserRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Assignment cPAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cPPathParserRuleCall_2_2_0 = (RuleCall)cPAssignment_2_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_3 = (Keyword)cGroup_2.eContents().get(3);
		private final Assignment cAliasAssignment_2_4 = (Assignment)cGroup_2.eContents().get(4);
		private final RuleCall cAliasIdentifierParserRuleCall_2_4_0 = (RuleCall)cAliasAssignment_2_4.eContents().get(0);
		private final RuleCall cInCollectionElementsDeclarationParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//FromRange:
		//	FromClassOrOuterQueryPath | alias=Identifier IN_CLASS p=Path | IN "(" p=Path ")" alias=Identifier |
		//	InCollectionElementsDeclaration;
		public ParserRule getRule() { return rule; }

		//FromClassOrOuterQueryPath | alias=Identifier IN_CLASS p=Path | IN "(" p=Path ")" alias=Identifier |
		//InCollectionElementsDeclaration
		public Alternatives getAlternatives() { return cAlternatives; }

		//FromClassOrOuterQueryPath
		public RuleCall getFromClassOrOuterQueryPathParserRuleCall_0() { return cFromClassOrOuterQueryPathParserRuleCall_0; }

		//alias=Identifier IN_CLASS p=Path
		public Group getGroup_1() { return cGroup_1; }

		//alias=Identifier
		public Assignment getAliasAssignment_1_0() { return cAliasAssignment_1_0; }

		//Identifier
		public RuleCall getAliasIdentifierParserRuleCall_1_0_0() { return cAliasIdentifierParserRuleCall_1_0_0; }

		//IN_CLASS
		public RuleCall getIN_CLASSParserRuleCall_1_1() { return cIN_CLASSParserRuleCall_1_1; }

		//p=Path
		public Assignment getPAssignment_1_2() { return cPAssignment_1_2; }

		//Path
		public RuleCall getPPathParserRuleCall_1_2_0() { return cPPathParserRuleCall_1_2_0; }

		//IN "(" p=Path ")" alias=Identifier
		public Group getGroup_2() { return cGroup_2; }

		//IN
		public RuleCall getINParserRuleCall_2_0() { return cINParserRuleCall_2_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_2_1() { return cLeftParenthesisKeyword_2_1; }

		//p=Path
		public Assignment getPAssignment_2_2() { return cPAssignment_2_2; }

		//Path
		public RuleCall getPPathParserRuleCall_2_2_0() { return cPPathParserRuleCall_2_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2_3() { return cRightParenthesisKeyword_2_3; }

		//alias=Identifier
		public Assignment getAliasAssignment_2_4() { return cAliasAssignment_2_4; }

		//Identifier
		public RuleCall getAliasIdentifierParserRuleCall_2_4_0() { return cAliasIdentifierParserRuleCall_2_4_0; }

		//InCollectionElementsDeclaration
		public RuleCall getInCollectionElementsDeclarationParserRuleCall_3() { return cInCollectionElementsDeclarationParserRuleCall_3; }
	}

	public class FromClassOrOuterQueryPathElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FromClassOrOuterQueryPath");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFromClassOrOuterQueryPathAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cPathAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPathPathParserRuleCall_1_0 = (RuleCall)cPathAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final RuleCall cASParserRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Assignment cNameAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cNameIdentifierParserRuleCall_2_1_0 = (RuleCall)cNameAssignment_2_1.eContents().get(0);
		private final Assignment cPropertyFetchAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPropertyFetchPropertyFetchParserRuleCall_3_0 = (RuleCall)cPropertyFetchAssignment_3.eContents().get(0);
		
		//FromClassOrOuterQueryPath:
		//	{FromClassOrOuterQueryPath} path=Path (AS? name=Identifier)? propertyFetch=PropertyFetch?;
		public ParserRule getRule() { return rule; }

		//{FromClassOrOuterQueryPath} path=Path (AS? name=Identifier)? propertyFetch=PropertyFetch?
		public Group getGroup() { return cGroup; }

		//{FromClassOrOuterQueryPath}
		public Action getFromClassOrOuterQueryPathAction_0() { return cFromClassOrOuterQueryPathAction_0; }

		//path=Path
		public Assignment getPathAssignment_1() { return cPathAssignment_1; }

		//Path
		public RuleCall getPathPathParserRuleCall_1_0() { return cPathPathParserRuleCall_1_0; }

		//(AS? name=Identifier)?
		public Group getGroup_2() { return cGroup_2; }

		//AS?
		public RuleCall getASParserRuleCall_2_0() { return cASParserRuleCall_2_0; }

		//name=Identifier
		public Assignment getNameAssignment_2_1() { return cNameAssignment_2_1; }

		//Identifier
		public RuleCall getNameIdentifierParserRuleCall_2_1_0() { return cNameIdentifierParserRuleCall_2_1_0; }

		//propertyFetch=PropertyFetch?
		public Assignment getPropertyFetchAssignment_3() { return cPropertyFetchAssignment_3; }

		//PropertyFetch
		public RuleCall getPropertyFetchPropertyFetchParserRuleCall_3_0() { return cPropertyFetchPropertyFetchParserRuleCall_3_0; }
	}

	public class InCollectionElementsDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "InCollectionElementsDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAliasAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cAliasIdentifierParserRuleCall_0_0 = (RuleCall)cAliasAssignment_0.eContents().get(0);
		private final RuleCall cIN_ELEMENTSParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cPAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPPathParserRuleCall_3_0 = (RuleCall)cPAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//InCollectionElementsDeclaration:
		//	alias=Identifier IN_ELEMENTS "(" p=Path ")";
		public ParserRule getRule() { return rule; }

		//alias=Identifier IN_ELEMENTS "(" p=Path ")"
		public Group getGroup() { return cGroup; }

		//alias=Identifier
		public Assignment getAliasAssignment_0() { return cAliasAssignment_0; }

		//Identifier
		public RuleCall getAliasIdentifierParserRuleCall_0_0() { return cAliasIdentifierParserRuleCall_0_0; }

		//IN_ELEMENTS
		public RuleCall getIN_ELEMENTSParserRuleCall_1() { return cIN_ELEMENTSParserRuleCall_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//p=Path
		public Assignment getPAssignment_3() { return cPAssignment_3; }

		//Path
		public RuleCall getPPathParserRuleCall_3_0() { return cPPathParserRuleCall_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class PropertyFetchElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PropertyFetch");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cFETCHParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cALLParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cPROPERTIESParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//PropertyFetch returns ecore::EString:
		//	FETCH ALL PROPERTIES;
		public ParserRule getRule() { return rule; }

		//FETCH ALL PROPERTIES
		public Group getGroup() { return cGroup; }

		//FETCH
		public RuleCall getFETCHParserRuleCall_0() { return cFETCHParserRuleCall_0; }

		//ALL
		public RuleCall getALLParserRuleCall_1() { return cALLParserRuleCall_1; }

		//PROPERTIES
		public RuleCall getPROPERTIESParserRuleCall_2() { return cPROPERTIESParserRuleCall_2; }
	}

	public class GroupByClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GroupByClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cGROUP_BYParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cEAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_1_0 = (RuleCall)cEAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cEAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_2_1_0 = (RuleCall)cEAssignment_2_1.eContents().get(0);
		private final Assignment cHAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cHHavingClauseParserRuleCall_3_0 = (RuleCall)cHAssignment_3.eContents().get(0);
		
		////## GroupByClause:
		////##     GROUP_BY Path ( ',' Path )*;
		//GroupByClause:
		//	GROUP_BY e+=Expression ("," e+=Expression)* h=HavingClause?;
		public ParserRule getRule() { return rule; }

		//GROUP_BY e+=Expression ("," e+=Expression)* h=HavingClause?
		public Group getGroup() { return cGroup; }

		//GROUP_BY
		public RuleCall getGROUP_BYParserRuleCall_0() { return cGROUP_BYParserRuleCall_0; }

		//e+=Expression
		public Assignment getEAssignment_1() { return cEAssignment_1; }

		//Expression
		public RuleCall getEExpressionParserRuleCall_1_0() { return cEExpressionParserRuleCall_1_0; }

		//("," e+=Expression)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//e+=Expression
		public Assignment getEAssignment_2_1() { return cEAssignment_2_1; }

		//Expression
		public RuleCall getEExpressionParserRuleCall_2_1_0() { return cEExpressionParserRuleCall_2_1_0; }

		//h=HavingClause?
		public Assignment getHAssignment_3() { return cHAssignment_3; }

		//HavingClause
		public RuleCall getHHavingClauseParserRuleCall_3_0() { return cHHavingClauseParserRuleCall_3_0; }
	}

	public class OrderByClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OrderByClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cORDER_BYParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cOAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOOrderElementParserRuleCall_1_0 = (RuleCall)cOAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cOAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cOOrderElementParserRuleCall_2_1_0 = (RuleCall)cOAssignment_2_1.eContents().get(0);
		
		////## OrderByClause:
		////##     ORDER_BY SelectedPropertiesList;
		//OrderByClause:
		//	ORDER_BY o+=OrderElement ("," o+=OrderElement)*;
		public ParserRule getRule() { return rule; }

		//ORDER_BY o+=OrderElement ("," o+=OrderElement)*
		public Group getGroup() { return cGroup; }

		//ORDER_BY
		public RuleCall getORDER_BYParserRuleCall_0() { return cORDER_BYParserRuleCall_0; }

		//o+=OrderElement
		public Assignment getOAssignment_1() { return cOAssignment_1; }

		//OrderElement
		public RuleCall getOOrderElementParserRuleCall_1_0() { return cOOrderElementParserRuleCall_1_0; }

		//("," o+=OrderElement)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//o+=OrderElement
		public Assignment getOAssignment_2_1() { return cOAssignment_2_1; }

		//OrderElement
		public RuleCall getOOrderElementParserRuleCall_2_1_0() { return cOOrderElementParserRuleCall_2_1_0; }
	}

	public class OrderElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OrderElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cAscendingOrDescendingParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//OrderElement:
		//	Expression AscendingOrDescending?;
		public ParserRule getRule() { return rule; }

		//Expression AscendingOrDescending?
		public Group getGroup() { return cGroup; }

		//Expression
		public RuleCall getExpressionParserRuleCall_0() { return cExpressionParserRuleCall_0; }

		//AscendingOrDescending?
		public RuleCall getAscendingOrDescendingParserRuleCall_1() { return cAscendingOrDescendingParserRuleCall_1; }
	}

	public class AscendingOrDescendingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AscendingOrDescending");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cASCParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDESCParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//AscendingOrDescending returns ecore::EString:
		//	ASC | DESC;
		public ParserRule getRule() { return rule; }

		//ASC | DESC
		public Alternatives getAlternatives() { return cAlternatives; }

		//ASC
		public RuleCall getASCParserRuleCall_0() { return cASCParserRuleCall_0; }

		//DESC
		public RuleCall getDESCParserRuleCall_1() { return cDESCParserRuleCall_1; }
	}

	public class HavingClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "HavingClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cHAVINGParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cEAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_1_0 = (RuleCall)cEAssignment_1.eContents().get(0);
		
		////## HavingClause:
		////##     HAVING logicalExpression;
		//HavingClause:
		//	HAVING e=Expression;
		public ParserRule getRule() { return rule; }

		//HAVING e=Expression
		public Group getGroup() { return cGroup; }

		//HAVING
		public RuleCall getHAVINGParserRuleCall_0() { return cHAVINGParserRuleCall_0; }

		//e=Expression
		public Assignment getEAssignment_1() { return cEAssignment_1; }

		//Expression
		public RuleCall getEExpressionParserRuleCall_1_0() { return cEExpressionParserRuleCall_1_0; }
	}

	public class WhereClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WhereClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cWHEREParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cEAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_1_0 = (RuleCall)cEAssignment_1.eContents().get(0);
		
		////## WhereClause:
		////##     WHERE logicalExpression;
		//WhereClause:
		//	WHERE e=Expression;
		public ParserRule getRule() { return rule; }

		//WHERE e=Expression
		public Group getGroup() { return cGroup; }

		//WHERE
		public RuleCall getWHEREParserRuleCall_0() { return cWHEREParserRuleCall_0; }

		//e=Expression
		public Assignment getEAssignment_1() { return cEAssignment_1; }

		//Expression
		public RuleCall getEExpressionParserRuleCall_1_0() { return cEExpressionParserRuleCall_1_0; }
	}

	public class SelectedPropertiesListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SelectedPropertiesList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cAAliasedExpressionParserRuleCall_0_0 = (RuleCall)cAAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cAAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cAAliasedExpressionParserRuleCall_1_1_0 = (RuleCall)cAAssignment_1_1.eContents().get(0);
		
		////## SelectedPropertiesList:
		////##     ( Path | Aggregate ) ( ',' Path | Aggregate )*;
		//SelectedPropertiesList:
		//	a+=AliasedExpression ("," a+=AliasedExpression)*;
		public ParserRule getRule() { return rule; }

		//a+=AliasedExpression ("," a+=AliasedExpression)*
		public Group getGroup() { return cGroup; }

		//a+=AliasedExpression
		public Assignment getAAssignment_0() { return cAAssignment_0; }

		//AliasedExpression
		public RuleCall getAAliasedExpressionParserRuleCall_0_0() { return cAAliasedExpressionParserRuleCall_0_0; }

		//("," a+=AliasedExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//a+=AliasedExpression
		public Assignment getAAssignment_1_1() { return cAAssignment_1_1; }

		//AliasedExpression
		public RuleCall getAAliasedExpressionParserRuleCall_1_1_0() { return cAAliasedExpressionParserRuleCall_1_1_0; }
	}

	public class AliasedExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AliasedExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cASParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cIdAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cIdIdentifierParserRuleCall_1_1_0 = (RuleCall)cIdAssignment_1_1.eContents().get(0);
		
		//AliasedExpression:
		//	Expression (AS id=Identifier)?;
		public ParserRule getRule() { return rule; }

		//Expression (AS id=Identifier)?
		public Group getGroup() { return cGroup; }

		//Expression
		public RuleCall getExpressionParserRuleCall_0() { return cExpressionParserRuleCall_0; }

		//(AS id=Identifier)?
		public Group getGroup_1() { return cGroup_1; }

		//AS
		public RuleCall getASParserRuleCall_1_0() { return cASParserRuleCall_1_0; }

		//id=Identifier
		public Assignment getIdAssignment_1_1() { return cIdAssignment_1_1; }

		//Identifier
		public RuleCall getIdIdentifierParserRuleCall_1_1_0() { return cIdIdentifierParserRuleCall_1_1_0; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final RuleCall cLogicalOrExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// expressions
		//// Note that most of these expressions follow the pattern
		////   thisLevelExpression :
		////       nextHigherPrecedenceExpression
		////           (OPERATOR nextHigherPrecedenceExpression)*
		//// which is a standard recursive definition for a parsing an expression.
		////
		//// Operator precedence in HQL
		//// lowest  --> ( 7)  OR
		////             ( 6)  AND, NOT
		////             ( 5)  equality: ==, <>, =, is
		////             ( 4)  relational: <, <=, >, >=,
		////                   LIKE, NOT LIKE, BETWEEN, NOT BETWEEN, IN, NOT IN
		////             ( 3)  addition and subtraction: +(binary) -(binary)
		////             ( 2)  multiplication: * / %, concatenate: ||
		//// highest --> ( 1)  +(unary) -(unary)
		////                   []   () (method call)  . (dot -- identifier qualification)
		////                   aggregate function
		////                   ()  (explicit parenthesis)
		////
		//// Note that the above precedence levels map to the rules below...
		//// Once you have a precedence chart, writing the appropriate rules as below
		//// is usually very straightfoward
		//// Main expression rule
		//Expression:
		//	LogicalOrExpression;
		public ParserRule getRule() { return rule; }

		//LogicalOrExpression
		public RuleCall getLogicalOrExpressionParserRuleCall() { return cLogicalOrExpressionParserRuleCall; }
	}

	public class LogicalOrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalOrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLLogicalAndExpressionParserRuleCall_0_0 = (RuleCall)cLAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cORParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cLAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cLLogicalAndExpressionParserRuleCall_1_1_0 = (RuleCall)cLAssignment_1_1.eContents().get(0);
		
		//// level 7 - OR
		//LogicalOrExpression:
		//	l+=LogicalAndExpression (OR l+=LogicalAndExpression)*;
		public ParserRule getRule() { return rule; }

		//l+=LogicalAndExpression (OR l+=LogicalAndExpression)*
		public Group getGroup() { return cGroup; }

		//l+=LogicalAndExpression
		public Assignment getLAssignment_0() { return cLAssignment_0; }

		//LogicalAndExpression
		public RuleCall getLLogicalAndExpressionParserRuleCall_0_0() { return cLLogicalAndExpressionParserRuleCall_0_0; }

		//(OR l+=LogicalAndExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//OR
		public RuleCall getORParserRuleCall_1_0() { return cORParserRuleCall_1_0; }

		//l+=LogicalAndExpression
		public Assignment getLAssignment_1_1() { return cLAssignment_1_1; }

		//LogicalAndExpression
		public RuleCall getLLogicalAndExpressionParserRuleCall_1_1_0() { return cLLogicalAndExpressionParserRuleCall_1_1_0; }
	}

	public class LogicalAndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalAndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNNegatedExpressionParserRuleCall_0_0 = (RuleCall)cNAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cANDParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cNAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cNNegatedExpressionParserRuleCall_1_1_0 = (RuleCall)cNAssignment_1_1.eContents().get(0);
		
		//// level 6 - AND, NOT
		//LogicalAndExpression:
		//	n+=NegatedExpression (AND n+=NegatedExpression)*;
		public ParserRule getRule() { return rule; }

		//n+=NegatedExpression (AND n+=NegatedExpression)*
		public Group getGroup() { return cGroup; }

		//n+=NegatedExpression
		public Assignment getNAssignment_0() { return cNAssignment_0; }

		//NegatedExpression
		public RuleCall getNNegatedExpressionParserRuleCall_0_0() { return cNNegatedExpressionParserRuleCall_0_0; }

		//(AND n+=NegatedExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//AND
		public RuleCall getANDParserRuleCall_1_0() { return cANDParserRuleCall_1_0; }

		//n+=NegatedExpression
		public Assignment getNAssignment_1_1() { return cNAssignment_1_1; }

		//NegatedExpression
		public RuleCall getNNegatedExpressionParserRuleCall_1_1_0() { return cNNegatedExpressionParserRuleCall_1_1_0; }
	}

	public class NegatedExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NegatedExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cNOTParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Assignment cNAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cNNegatedExpressionParserRuleCall_0_1_0 = (RuleCall)cNAssignment_0_1.eContents().get(0);
		private final RuleCall cEqualityExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// NOT nodes aren't generated.  Instead, the operator in the sub-tree will be
		//// negated, if possible.   Expressions without a NOT parent are passed through.
		//// Weak keywords can appear in an expression, so look ahead.
		//NegatedExpression:
		//	NOT n=NegatedExpression | EqualityExpression;
		public ParserRule getRule() { return rule; }

		//NOT n=NegatedExpression | EqualityExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//NOT n=NegatedExpression
		public Group getGroup_0() { return cGroup_0; }

		//NOT
		public RuleCall getNOTParserRuleCall_0_0() { return cNOTParserRuleCall_0_0; }

		//n=NegatedExpression
		public Assignment getNAssignment_0_1() { return cNAssignment_0_1; }

		//NegatedExpression
		public RuleCall getNNegatedExpressionParserRuleCall_0_1_0() { return cNNegatedExpressionParserRuleCall_0_1_0; }

		//EqualityExpression
		public RuleCall getEqualityExpressionParserRuleCall_1() { return cEqualityExpressionParserRuleCall_1; }
	}

	public class EqualityExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EqualityExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cRAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cRRelationalExpressionParserRuleCall_0_0 = (RuleCall)cRAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_0_0 = (Keyword)cAlternatives_1_0.eContents().get(0);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final RuleCall cISParserRuleCall_1_0_1_0 = (RuleCall)cGroup_1_0_1.eContents().get(0);
		private final RuleCall cNOTParserRuleCall_1_0_1_1 = (RuleCall)cGroup_1_0_1.eContents().get(1);
		private final Keyword cExclamationMarkEqualsSignKeyword_1_0_2 = (Keyword)cAlternatives_1_0.eContents().get(2);
		private final Keyword cLessThanSignGreaterThanSignKeyword_1_0_3 = (Keyword)cAlternatives_1_0.eContents().get(3);
		private final Assignment cRAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRRelationalExpressionParserRuleCall_1_1_0 = (RuleCall)cRAssignment_1_1.eContents().get(0);
		
		////## OP: EQ | LT | GT | LE | GE | NE | SQL_NE | LIKE;
		//// level 5 - EQ, NE
		//EqualityExpression:
		//	r+=RelationalExpression (("=" | IS NOT? | "!=" | "<>") r+=RelationalExpression)*;
		public ParserRule getRule() { return rule; }

		//r+=RelationalExpression (("=" | IS NOT? | "!=" | "<>") r+=RelationalExpression)*
		public Group getGroup() { return cGroup; }

		//r+=RelationalExpression
		public Assignment getRAssignment_0() { return cRAssignment_0; }

		//RelationalExpression
		public RuleCall getRRelationalExpressionParserRuleCall_0_0() { return cRRelationalExpressionParserRuleCall_0_0; }

		//(("=" | IS NOT? | "!=" | "<>") r+=RelationalExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//"=" | IS NOT? | "!=" | "<>"
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_1_0_0() { return cEqualsSignKeyword_1_0_0; }

		//IS NOT?
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//IS
		public RuleCall getISParserRuleCall_1_0_1_0() { return cISParserRuleCall_1_0_1_0; }

		//NOT?
		public RuleCall getNOTParserRuleCall_1_0_1_1() { return cNOTParserRuleCall_1_0_1_1; }

		//"!="
		public Keyword getExclamationMarkEqualsSignKeyword_1_0_2() { return cExclamationMarkEqualsSignKeyword_1_0_2; }

		//"<>"
		public Keyword getLessThanSignGreaterThanSignKeyword_1_0_3() { return cLessThanSignGreaterThanSignKeyword_1_0_3; }

		//r+=RelationalExpression
		public Assignment getRAssignment_1_1() { return cRAssignment_1_1; }

		//RelationalExpression
		public RuleCall getRRelationalExpressionParserRuleCall_1_1_0() { return cRRelationalExpressionParserRuleCall_1_1_0; }
	}

	public class RelationalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RelationalExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cConcatenationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Alternatives cAlternatives_1_0_0 = (Alternatives)cGroup_1_0.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1_0_0_0 = (Keyword)cAlternatives_1_0_0.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_1_0_0_1 = (Keyword)cAlternatives_1_0_0.eContents().get(1);
		private final Keyword cLessThanSignEqualsSignKeyword_1_0_0_2 = (Keyword)cAlternatives_1_0_0.eContents().get(2);
		private final Keyword cGreaterThanSignEqualsSignKeyword_1_0_0_3 = (Keyword)cAlternatives_1_0_0.eContents().get(3);
		private final Assignment cAAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cAAdditiveExpressionParserRuleCall_1_0_1_0 = (RuleCall)cAAssignment_1_0_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final RuleCall cNOTParserRuleCall_1_1_0 = (RuleCall)cGroup_1_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1_1 = (Alternatives)cGroup_1_1.eContents().get(1);
		private final Group cGroup_1_1_1_0 = (Group)cAlternatives_1_1_1.eContents().get(0);
		private final RuleCall cINParserRuleCall_1_1_1_0_0 = (RuleCall)cGroup_1_1_1_0.eContents().get(0);
		private final Assignment cIAssignment_1_1_1_0_1 = (Assignment)cGroup_1_1_1_0.eContents().get(1);
		private final RuleCall cICompoundExprParserRuleCall_1_1_1_0_1_0 = (RuleCall)cIAssignment_1_1_1_0_1.eContents().get(0);
		private final Group cGroup_1_1_1_1 = (Group)cAlternatives_1_1_1.eContents().get(1);
		private final RuleCall cBETWEENParserRuleCall_1_1_1_1_0 = (RuleCall)cGroup_1_1_1_1.eContents().get(0);
		private final Assignment cBAssignment_1_1_1_1_1 = (Assignment)cGroup_1_1_1_1.eContents().get(1);
		private final RuleCall cBBetweenListParserRuleCall_1_1_1_1_1_0 = (RuleCall)cBAssignment_1_1_1_1_1.eContents().get(0);
		private final Group cGroup_1_1_1_2 = (Group)cAlternatives_1_1_1.eContents().get(2);
		private final RuleCall cLIKEParserRuleCall_1_1_1_2_0 = (RuleCall)cGroup_1_1_1_2.eContents().get(0);
		private final Assignment cCAssignment_1_1_1_2_1 = (Assignment)cGroup_1_1_1_2.eContents().get(1);
		private final RuleCall cCConcatenationParserRuleCall_1_1_1_2_1_0 = (RuleCall)cCAssignment_1_1_1_2_1.eContents().get(0);
		private final Assignment cLAssignment_1_1_1_2_2 = (Assignment)cGroup_1_1_1_2.eContents().get(2);
		private final RuleCall cLLikeEscapeParserRuleCall_1_1_1_2_2_0 = (RuleCall)cLAssignment_1_1_1_2_2.eContents().get(0);
		private final Group cGroup_1_1_1_3 = (Group)cAlternatives_1_1_1.eContents().get(3);
		private final RuleCall cMEMBERParserRuleCall_1_1_1_3_0 = (RuleCall)cGroup_1_1_1_3.eContents().get(0);
		private final RuleCall cOFParserRuleCall_1_1_1_3_1 = (RuleCall)cGroup_1_1_1_3.eContents().get(1);
		private final Assignment cPAssignment_1_1_1_3_2 = (Assignment)cGroup_1_1_1_3.eContents().get(2);
		private final RuleCall cPPathParserRuleCall_1_1_1_3_2_0 = (RuleCall)cPAssignment_1_1_1_3_2.eContents().get(0);
		
		//// level 4 - LT, GT, LE, GE, LIKE, NOT LIKE, BETWEEN, NOT BETWEEN
		//// NOTE: The NOT prefix for LIKE and BETWEEN will be represented in the
		//// token type.  When traversing the AST, use the token type, and not the
		//// token text to interpret the semantics of these nodes.
		//RelationalExpression:
		//	Concatenation ((("<" | ">" | "<=" | ">=") a+=AdditiveExpression)* // Disable node production for the optional 'not'.
		//	| NOT? (IN i=CompoundExpr // Represent the optional NOT prefix using the token type by
		//	// testing 'n' and setting the token type accordingly.
		//	| BETWEEN b=BetweenList | LIKE c=Concatenation l=LikeEscape | MEMBER OF? p=Path));
		public ParserRule getRule() { return rule; }

		//Concatenation ((("<" | ">" | "<=" | ">=") a+=AdditiveExpression)* // Disable node production for the optional 'not'.
		//| NOT? (IN i=CompoundExpr // Represent the optional NOT prefix using the token type by
		//// testing 'n' and setting the token type accordingly.
		//| BETWEEN b=BetweenList | LIKE c=Concatenation l=LikeEscape | MEMBER OF? p=Path))
		public Group getGroup() { return cGroup; }

		//Concatenation
		public RuleCall getConcatenationParserRuleCall_0() { return cConcatenationParserRuleCall_0; }

		//(("<" | ">" | "<=" | ">=") a+=AdditiveExpression)* // Disable node production for the optional 'not'.
		//| NOT? (IN i=CompoundExpr // Represent the optional NOT prefix using the token type by
		//// testing 'n' and setting the token type accordingly.
		//| BETWEEN b=BetweenList | LIKE c=Concatenation l=LikeEscape | MEMBER OF? p=Path)
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//(("<" | ">" | "<=" | ">=") a+=AdditiveExpression)*
		public Group getGroup_1_0() { return cGroup_1_0; }

		//"<" | ">" | "<=" | ">="
		public Alternatives getAlternatives_1_0_0() { return cAlternatives_1_0_0; }

		//"<"
		public Keyword getLessThanSignKeyword_1_0_0_0() { return cLessThanSignKeyword_1_0_0_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_1_0_0_1() { return cGreaterThanSignKeyword_1_0_0_1; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_1_0_0_2() { return cLessThanSignEqualsSignKeyword_1_0_0_2; }

		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_1_0_0_3() { return cGreaterThanSignEqualsSignKeyword_1_0_0_3; }

		//a+=AdditiveExpression
		public Assignment getAAssignment_1_0_1() { return cAAssignment_1_0_1; }

		//AdditiveExpression
		public RuleCall getAAdditiveExpressionParserRuleCall_1_0_1_0() { return cAAdditiveExpressionParserRuleCall_1_0_1_0; }

		//NOT? (IN i=CompoundExpr // Represent the optional NOT prefix using the token type by
		//// testing 'n' and setting the token type accordingly.
		//| BETWEEN b=BetweenList | LIKE c=Concatenation l=LikeEscape | MEMBER OF? p=Path)
		public Group getGroup_1_1() { return cGroup_1_1; }

		//NOT?
		public RuleCall getNOTParserRuleCall_1_1_0() { return cNOTParserRuleCall_1_1_0; }

		//IN i=CompoundExpr // Represent the optional NOT prefix using the token type by
		//// testing 'n' and setting the token type accordingly.
		//| BETWEEN b=BetweenList | LIKE c=Concatenation l=LikeEscape | MEMBER OF? p=Path
		public Alternatives getAlternatives_1_1_1() { return cAlternatives_1_1_1; }

		//IN i=CompoundExpr
		public Group getGroup_1_1_1_0() { return cGroup_1_1_1_0; }

		//IN
		public RuleCall getINParserRuleCall_1_1_1_0_0() { return cINParserRuleCall_1_1_1_0_0; }

		//i=CompoundExpr
		public Assignment getIAssignment_1_1_1_0_1() { return cIAssignment_1_1_1_0_1; }

		//CompoundExpr
		public RuleCall getICompoundExprParserRuleCall_1_1_1_0_1_0() { return cICompoundExprParserRuleCall_1_1_1_0_1_0; }

		//BETWEEN b=BetweenList
		public Group getGroup_1_1_1_1() { return cGroup_1_1_1_1; }

		//BETWEEN
		public RuleCall getBETWEENParserRuleCall_1_1_1_1_0() { return cBETWEENParserRuleCall_1_1_1_1_0; }

		//b=BetweenList
		public Assignment getBAssignment_1_1_1_1_1() { return cBAssignment_1_1_1_1_1; }

		//BetweenList
		public RuleCall getBBetweenListParserRuleCall_1_1_1_1_1_0() { return cBBetweenListParserRuleCall_1_1_1_1_1_0; }

		//LIKE c=Concatenation l=LikeEscape
		public Group getGroup_1_1_1_2() { return cGroup_1_1_1_2; }

		//LIKE
		public RuleCall getLIKEParserRuleCall_1_1_1_2_0() { return cLIKEParserRuleCall_1_1_1_2_0; }

		//c=Concatenation
		public Assignment getCAssignment_1_1_1_2_1() { return cCAssignment_1_1_1_2_1; }

		//Concatenation
		public RuleCall getCConcatenationParserRuleCall_1_1_1_2_1_0() { return cCConcatenationParserRuleCall_1_1_1_2_1_0; }

		//l=LikeEscape
		public Assignment getLAssignment_1_1_1_2_2() { return cLAssignment_1_1_1_2_2; }

		//LikeEscape
		public RuleCall getLLikeEscapeParserRuleCall_1_1_1_2_2_0() { return cLLikeEscapeParserRuleCall_1_1_1_2_2_0; }

		//MEMBER OF? p=Path
		public Group getGroup_1_1_1_3() { return cGroup_1_1_1_3; }

		//MEMBER
		public RuleCall getMEMBERParserRuleCall_1_1_1_3_0() { return cMEMBERParserRuleCall_1_1_1_3_0; }

		//OF?
		public RuleCall getOFParserRuleCall_1_1_1_3_1() { return cOFParserRuleCall_1_1_1_3_1; }

		//p=Path
		public Assignment getPAssignment_1_1_1_3_2() { return cPAssignment_1_1_1_3_2; }

		//Path
		public RuleCall getPPathParserRuleCall_1_1_1_3_2_0() { return cPPathParserRuleCall_1_1_1_3_2_0; }
	}

	public class LikeEscapeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LikeEscape");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLikeEscapeAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cESCAPEParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cCAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cCConcatenationParserRuleCall_1_1_0 = (RuleCall)cCAssignment_1_1.eContents().get(0);
		
		//LikeEscape:
		//	{LikeEscape} (ESCAPE c=Concatenation)?;
		public ParserRule getRule() { return rule; }

		//{LikeEscape} (ESCAPE c=Concatenation)?
		public Group getGroup() { return cGroup; }

		//{LikeEscape}
		public Action getLikeEscapeAction_0() { return cLikeEscapeAction_0; }

		//(ESCAPE c=Concatenation)?
		public Group getGroup_1() { return cGroup_1; }

		//ESCAPE
		public RuleCall getESCAPEParserRuleCall_1_0() { return cESCAPEParserRuleCall_1_0; }

		//c=Concatenation
		public Assignment getCAssignment_1_1() { return cCAssignment_1_1; }

		//Concatenation
		public RuleCall getCConcatenationParserRuleCall_1_1_0() { return cCConcatenationParserRuleCall_1_1_0; }
	}

	public class BetweenListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BetweenList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCConcatenationParserRuleCall_0_0 = (RuleCall)cCAssignment_0.eContents().get(0);
		private final RuleCall cANDParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cCAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCConcatenationParserRuleCall_2_0 = (RuleCall)cCAssignment_2.eContents().get(0);
		
		//BetweenList:
		//	c+=Concatenation AND c+=Concatenation;
		public ParserRule getRule() { return rule; }

		//c+=Concatenation AND c+=Concatenation
		public Group getGroup() { return cGroup; }

		//c+=Concatenation
		public Assignment getCAssignment_0() { return cCAssignment_0; }

		//Concatenation
		public RuleCall getCConcatenationParserRuleCall_0_0() { return cCConcatenationParserRuleCall_0_0; }

		//AND
		public RuleCall getANDParserRuleCall_1() { return cANDParserRuleCall_1; }

		//c+=Concatenation
		public Assignment getCAssignment_2() { return cCAssignment_2; }

		//Concatenation
		public RuleCall getCConcatenationParserRuleCall_2_0() { return cCConcatenationParserRuleCall_2_0; }
	}

	public class ConcatenationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Concatenation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdditiveExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cVerticalLineVerticalLineKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cAAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cAAdditiveExpressionParserRuleCall_1_1_0 = (RuleCall)cAAssignment_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cVerticalLineVerticalLineKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cAAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cAAdditiveExpressionParserRuleCall_1_2_1_0 = (RuleCall)cAAssignment_1_2_1.eContents().get(0);
		
		////level 4 - string concatenation
		//Concatenation:
		//	AdditiveExpression ("||" a+=AdditiveExpression ("||" a+=AdditiveExpression)*)?;
		public ParserRule getRule() { return rule; }

		//AdditiveExpression ("||" a+=AdditiveExpression ("||" a+=AdditiveExpression)*)?
		public Group getGroup() { return cGroup; }

		//AdditiveExpression
		public RuleCall getAdditiveExpressionParserRuleCall_0() { return cAdditiveExpressionParserRuleCall_0; }

		//("||" a+=AdditiveExpression ("||" a+=AdditiveExpression)*)?
		public Group getGroup_1() { return cGroup_1; }

		//"||"
		public Keyword getVerticalLineVerticalLineKeyword_1_0() { return cVerticalLineVerticalLineKeyword_1_0; }

		//a+=AdditiveExpression
		public Assignment getAAssignment_1_1() { return cAAssignment_1_1; }

		//AdditiveExpression
		public RuleCall getAAdditiveExpressionParserRuleCall_1_1_0() { return cAAdditiveExpressionParserRuleCall_1_1_0; }

		//("||" a+=AdditiveExpression)*
		public Group getGroup_1_2() { return cGroup_1_2; }

		//"||"
		public Keyword getVerticalLineVerticalLineKeyword_1_2_0() { return cVerticalLineVerticalLineKeyword_1_2_0; }

		//a+=AdditiveExpression
		public Assignment getAAssignment_1_2_1() { return cAAssignment_1_2_1; }

		//AdditiveExpression
		public RuleCall getAAdditiveExpressionParserRuleCall_1_2_1_0() { return cAAdditiveExpressionParserRuleCall_1_2_1_0; }
	}

	public class AdditiveExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AdditiveExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cMAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cMMultiplyExpressionParserRuleCall_0_0 = (RuleCall)cMAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_0_0 = (Keyword)cAlternatives_1_0.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_0_1 = (Keyword)cAlternatives_1_0.eContents().get(1);
		private final Assignment cMAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cMMultiplyExpressionParserRuleCall_1_1_0 = (RuleCall)cMAssignment_1_1.eContents().get(0);
		
		//// level 3 - binary plus and minus
		//AdditiveExpression:
		//	m+=MultiplyExpression (("+" | "-") m+=MultiplyExpression)*;
		public ParserRule getRule() { return rule; }

		//m+=MultiplyExpression (("+" | "-") m+=MultiplyExpression)*
		public Group getGroup() { return cGroup; }

		//m+=MultiplyExpression
		public Assignment getMAssignment_0() { return cMAssignment_0; }

		//MultiplyExpression
		public RuleCall getMMultiplyExpressionParserRuleCall_0_0() { return cMMultiplyExpressionParserRuleCall_0_0; }

		//(("+" | "-") m+=MultiplyExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//"+" | "-"
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//"+"
		public Keyword getPlusSignKeyword_1_0_0() { return cPlusSignKeyword_1_0_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1_0_1() { return cHyphenMinusKeyword_1_0_1; }

		//m+=MultiplyExpression
		public Assignment getMAssignment_1_1() { return cMAssignment_1_1; }

		//MultiplyExpression
		public RuleCall getMMultiplyExpressionParserRuleCall_1_1_0() { return cMMultiplyExpressionParserRuleCall_1_1_0; }
	}

	public class MultiplyExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplyExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cUAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cUUnaryExpressionParserRuleCall_0_0 = (RuleCall)cUAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_0_0 = (Keyword)cAlternatives_1_0.eContents().get(0);
		private final Keyword cSolidusKeyword_1_0_1 = (Keyword)cAlternatives_1_0.eContents().get(1);
		private final Assignment cUAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cUUnaryExpressionParserRuleCall_1_1_0 = (RuleCall)cUAssignment_1_1.eContents().get(0);
		
		//// level 2 - binary multiply and divide
		//MultiplyExpression:
		//	u+=UnaryExpression (("*" | "/") u+=UnaryExpression)*;
		public ParserRule getRule() { return rule; }

		//u+=UnaryExpression (("*" | "/") u+=UnaryExpression)*
		public Group getGroup() { return cGroup; }

		//u+=UnaryExpression
		public Assignment getUAssignment_0() { return cUAssignment_0; }

		//UnaryExpression
		public RuleCall getUUnaryExpressionParserRuleCall_0_0() { return cUUnaryExpressionParserRuleCall_0_0; }

		//(("*" | "/") u+=UnaryExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//"*" | "/"
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//"*"
		public Keyword getAsteriskKeyword_1_0_0() { return cAsteriskKeyword_1_0_0; }

		//"/"
		public Keyword getSolidusKeyword_1_0_1() { return cSolidusKeyword_1_0_1; }

		//u+=UnaryExpression
		public Assignment getUAssignment_1_1() { return cUAssignment_1_1; }

		//UnaryExpression
		public RuleCall getUUnaryExpressionParserRuleCall_1_1_0() { return cUUnaryExpressionParserRuleCall_1_1_0; }
	}

	public class UnaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cUAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cUUnaryExpressionParserRuleCall_0_1_0 = (RuleCall)cUAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cPlusSignKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cUAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cUUnaryExpressionParserRuleCall_1_1_0 = (RuleCall)cUAssignment_1_1.eContents().get(0);
		private final RuleCall cCaseExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cQuantifiedExpressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cAtomParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//// level 1 - unary minus, unary plus, not
		//UnaryExpression:
		//	"-" u=UnaryExpression | "+" u=UnaryExpression | CaseExpression | QuantifiedExpression | Atom;
		public ParserRule getRule() { return rule; }

		//"-" u=UnaryExpression | "+" u=UnaryExpression | CaseExpression | QuantifiedExpression | Atom
		public Alternatives getAlternatives() { return cAlternatives; }

		//"-" u=UnaryExpression
		public Group getGroup_0() { return cGroup_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_0_0() { return cHyphenMinusKeyword_0_0; }

		//u=UnaryExpression
		public Assignment getUAssignment_0_1() { return cUAssignment_0_1; }

		//UnaryExpression
		public RuleCall getUUnaryExpressionParserRuleCall_0_1_0() { return cUUnaryExpressionParserRuleCall_0_1_0; }

		//"+" u=UnaryExpression
		public Group getGroup_1() { return cGroup_1; }

		//"+"
		public Keyword getPlusSignKeyword_1_0() { return cPlusSignKeyword_1_0; }

		//u=UnaryExpression
		public Assignment getUAssignment_1_1() { return cUAssignment_1_1; }

		//UnaryExpression
		public RuleCall getUUnaryExpressionParserRuleCall_1_1_0() { return cUUnaryExpressionParserRuleCall_1_1_0; }

		//CaseExpression
		public RuleCall getCaseExpressionParserRuleCall_2() { return cCaseExpressionParserRuleCall_2; }

		//QuantifiedExpression
		public RuleCall getQuantifiedExpressionParserRuleCall_3() { return cQuantifiedExpressionParserRuleCall_3; }

		//Atom
		public RuleCall getAtomParserRuleCall_4() { return cAtomParserRuleCall_4; }
	}

	public class CaseExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CaseExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cCASEParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Assignment cWAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cWWhenClauseParserRuleCall_0_1_0 = (RuleCall)cWAssignment_0_1.eContents().get(0);
		private final Assignment cEAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cEElseClauseParserRuleCall_0_2_0 = (RuleCall)cEAssignment_0_2.eContents().get(0);
		private final RuleCall cENDParserRuleCall_0_3 = (RuleCall)cGroup_0.eContents().get(3);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cCASEParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cUAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cUUnaryExpressionParserRuleCall_1_1_0 = (RuleCall)cUAssignment_1_1.eContents().get(0);
		private final Assignment cAAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cAAltWhenClauseParserRuleCall_1_2_0 = (RuleCall)cAAssignment_1_2.eContents().get(0);
		private final Assignment cEAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cEElseClauseParserRuleCall_1_3_0 = (RuleCall)cEAssignment_1_3.eContents().get(0);
		private final RuleCall cENDParserRuleCall_1_4 = (RuleCall)cGroup_1.eContents().get(4);
		
		//CaseExpression:
		//	CASE w+=WhenClause+ e=ElseClause? END | CASE u=UnaryExpression a+=AltWhenClause+ e=ElseClause? END;
		public ParserRule getRule() { return rule; }

		//CASE w+=WhenClause+ e=ElseClause? END | CASE u=UnaryExpression a+=AltWhenClause+ e=ElseClause? END
		public Alternatives getAlternatives() { return cAlternatives; }

		//CASE w+=WhenClause+ e=ElseClause? END
		public Group getGroup_0() { return cGroup_0; }

		//CASE
		public RuleCall getCASEParserRuleCall_0_0() { return cCASEParserRuleCall_0_0; }

		//w+=WhenClause+
		public Assignment getWAssignment_0_1() { return cWAssignment_0_1; }

		//WhenClause
		public RuleCall getWWhenClauseParserRuleCall_0_1_0() { return cWWhenClauseParserRuleCall_0_1_0; }

		//e=ElseClause?
		public Assignment getEAssignment_0_2() { return cEAssignment_0_2; }

		//ElseClause
		public RuleCall getEElseClauseParserRuleCall_0_2_0() { return cEElseClauseParserRuleCall_0_2_0; }

		//END
		public RuleCall getENDParserRuleCall_0_3() { return cENDParserRuleCall_0_3; }

		//CASE u=UnaryExpression a+=AltWhenClause+ e=ElseClause? END
		public Group getGroup_1() { return cGroup_1; }

		//CASE
		public RuleCall getCASEParserRuleCall_1_0() { return cCASEParserRuleCall_1_0; }

		//u=UnaryExpression
		public Assignment getUAssignment_1_1() { return cUAssignment_1_1; }

		//UnaryExpression
		public RuleCall getUUnaryExpressionParserRuleCall_1_1_0() { return cUUnaryExpressionParserRuleCall_1_1_0; }

		//a+=AltWhenClause+
		public Assignment getAAssignment_1_2() { return cAAssignment_1_2; }

		//AltWhenClause
		public RuleCall getAAltWhenClauseParserRuleCall_1_2_0() { return cAAltWhenClauseParserRuleCall_1_2_0; }

		//e=ElseClause?
		public Assignment getEAssignment_1_3() { return cEAssignment_1_3; }

		//ElseClause
		public RuleCall getEElseClauseParserRuleCall_1_3_0() { return cEElseClauseParserRuleCall_1_3_0; }

		//END
		public RuleCall getENDParserRuleCall_1_4() { return cENDParserRuleCall_1_4; }
	}

	public class WhenClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WhenClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cWHENParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cWhenExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cWhenExprExpressionParserRuleCall_1_0 = (RuleCall)cWhenExprAssignment_1.eContents().get(0);
		private final RuleCall cTHENParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cThenExprAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cThenExprUnaryExpressionParserRuleCall_3_0 = (RuleCall)cThenExprAssignment_3.eContents().get(0);
		
		//WhenClause:
		//	WHEN whenExpr=Expression THEN thenExpr=UnaryExpression;
		public ParserRule getRule() { return rule; }

		//WHEN whenExpr=Expression THEN thenExpr=UnaryExpression
		public Group getGroup() { return cGroup; }

		//WHEN
		public RuleCall getWHENParserRuleCall_0() { return cWHENParserRuleCall_0; }

		//whenExpr=Expression
		public Assignment getWhenExprAssignment_1() { return cWhenExprAssignment_1; }

		//Expression
		public RuleCall getWhenExprExpressionParserRuleCall_1_0() { return cWhenExprExpressionParserRuleCall_1_0; }

		//THEN
		public RuleCall getTHENParserRuleCall_2() { return cTHENParserRuleCall_2; }

		//thenExpr=UnaryExpression
		public Assignment getThenExprAssignment_3() { return cThenExprAssignment_3; }

		//UnaryExpression
		public RuleCall getThenExprUnaryExpressionParserRuleCall_3_0() { return cThenExprUnaryExpressionParserRuleCall_3_0; }
	}

	public class AltWhenClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AltWhenClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cWHENParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cWAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cWUnaryExpressionParserRuleCall_1_0 = (RuleCall)cWAssignment_1.eContents().get(0);
		private final RuleCall cTHENParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cTAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTUnaryExpressionParserRuleCall_3_0 = (RuleCall)cTAssignment_3.eContents().get(0);
		
		//AltWhenClause:
		//	WHEN w=UnaryExpression THEN t=UnaryExpression;
		public ParserRule getRule() { return rule; }

		//WHEN w=UnaryExpression THEN t=UnaryExpression
		public Group getGroup() { return cGroup; }

		//WHEN
		public RuleCall getWHENParserRuleCall_0() { return cWHENParserRuleCall_0; }

		//w=UnaryExpression
		public Assignment getWAssignment_1() { return cWAssignment_1; }

		//UnaryExpression
		public RuleCall getWUnaryExpressionParserRuleCall_1_0() { return cWUnaryExpressionParserRuleCall_1_0; }

		//THEN
		public RuleCall getTHENParserRuleCall_2() { return cTHENParserRuleCall_2; }

		//t=UnaryExpression
		public Assignment getTAssignment_3() { return cTAssignment_3; }

		//UnaryExpression
		public RuleCall getTUnaryExpressionParserRuleCall_3_0() { return cTUnaryExpressionParserRuleCall_3_0; }
	}

	public class ElseClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ElseClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cELSEParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cUAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cUUnaryExpressionParserRuleCall_1_0 = (RuleCall)cUAssignment_1.eContents().get(0);
		
		//ElseClause:
		//	ELSE u=UnaryExpression;
		public ParserRule getRule() { return rule; }

		//ELSE u=UnaryExpression
		public Group getGroup() { return cGroup; }

		//ELSE
		public RuleCall getELSEParserRuleCall_0() { return cELSEParserRuleCall_0; }

		//u=UnaryExpression
		public Assignment getUAssignment_1() { return cUAssignment_1; }

		//UnaryExpression
		public RuleCall getUUnaryExpressionParserRuleCall_1_0() { return cUUnaryExpressionParserRuleCall_1_0; }
	}

	public class QuantifiedExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QuantifiedExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cQuantifiedExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cSOMEParserRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cEXISTSParserRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		private final RuleCall cALLParserRuleCall_1_2 = (RuleCall)cAlternatives_1.eContents().get(2);
		private final RuleCall cANYParserRuleCall_1_3 = (RuleCall)cAlternatives_1.eContents().get(3);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final RuleCall cIdentifierParserRuleCall_2_0 = (RuleCall)cAlternatives_2.eContents().get(0);
		private final RuleCall cCollectionExprParserRuleCall_2_1 = (RuleCall)cAlternatives_2.eContents().get(1);
		private final Group cGroup_2_2 = (Group)cAlternatives_2.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Assignment cSAssignment_2_2_1 = (Assignment)cGroup_2_2.eContents().get(1);
		private final RuleCall cSUnionRuleParserRuleCall_2_2_1_0 = (RuleCall)cSAssignment_2_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_2_2 = (Keyword)cGroup_2_2.eContents().get(2);
		
		//QuantifiedExpression:
		//	{QuantifiedExpression} (SOME | EXISTS | ALL | ANY) (Identifier | CollectionExpr | "(" s=UnionRule ")");
		public ParserRule getRule() { return rule; }

		//{QuantifiedExpression} (SOME | EXISTS | ALL | ANY) (Identifier | CollectionExpr | "(" s=UnionRule ")")
		public Group getGroup() { return cGroup; }

		//{QuantifiedExpression}
		public Action getQuantifiedExpressionAction_0() { return cQuantifiedExpressionAction_0; }

		//SOME | EXISTS | ALL | ANY
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//SOME
		public RuleCall getSOMEParserRuleCall_1_0() { return cSOMEParserRuleCall_1_0; }

		//EXISTS
		public RuleCall getEXISTSParserRuleCall_1_1() { return cEXISTSParserRuleCall_1_1; }

		//ALL
		public RuleCall getALLParserRuleCall_1_2() { return cALLParserRuleCall_1_2; }

		//ANY
		public RuleCall getANYParserRuleCall_1_3() { return cANYParserRuleCall_1_3; }

		//Identifier | CollectionExpr | "(" s=UnionRule ")"
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//Identifier
		public RuleCall getIdentifierParserRuleCall_2_0() { return cIdentifierParserRuleCall_2_0; }

		//CollectionExpr
		public RuleCall getCollectionExprParserRuleCall_2_1() { return cCollectionExprParserRuleCall_2_1; }

		//"(" s=UnionRule ")"
		public Group getGroup_2_2() { return cGroup_2_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_2_2_0() { return cLeftParenthesisKeyword_2_2_0; }

		//s=UnionRule
		public Assignment getSAssignment_2_2_1() { return cSAssignment_2_2_1; }

		//UnionRule
		public RuleCall getSUnionRuleParserRuleCall_2_2_1_0() { return cSUnionRuleParserRuleCall_2_2_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2_2_2() { return cRightParenthesisKeyword_2_2_2; }
	}

	public class AtomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Atom");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAtomAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cPrimeAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cPrimePrimaryExpressionParserRuleCall_1_0_0 = (RuleCall)cPrimeAssignment_1_0.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Group cGroup_1_1_0 = (Group)cAlternatives_1_1.eContents().get(0);
		private final Keyword cFullStopKeyword_1_1_0_0 = (Keyword)cGroup_1_1_0.eContents().get(0);
		private final RuleCall cIdentifierParserRuleCall_1_1_0_1 = (RuleCall)cGroup_1_1_0.eContents().get(1);
		private final Group cGroup_1_1_0_2 = (Group)cGroup_1_1_0.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_1_1_0_2_0 = (Keyword)cGroup_1_1_0_2.eContents().get(0);
		private final Assignment cEAssignment_1_1_0_2_1 = (Assignment)cGroup_1_1_0_2.eContents().get(1);
		private final RuleCall cEExprListParserRuleCall_1_1_0_2_1_0 = (RuleCall)cEAssignment_1_1_0_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_1_0_2_2 = (Keyword)cGroup_1_1_0_2.eContents().get(2);
		private final Group cGroup_1_1_1 = (Group)cAlternatives_1_1.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1_1_1_0 = (Keyword)cGroup_1_1_1.eContents().get(0);
		private final Assignment cExpAssignment_1_1_1_1 = (Assignment)cGroup_1_1_1.eContents().get(1);
		private final RuleCall cExpExpressionParserRuleCall_1_1_1_1_0 = (RuleCall)cExpAssignment_1_1_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_1_1_2 = (Keyword)cGroup_1_1_1.eContents().get(2);
		
		//// level 0 - expression atom
		//// ident qualifier ('.' ident ), array index ( [ expr ] ),
		//// method call ( '.' ident '(' ExprList ') )
		//Atom:
		//	{Atom} (prime=PrimaryExpression ("." Identifier ("(" e+=ExprList ")")? | "[" exp+=Expression "]")*);
		public ParserRule getRule() { return rule; }

		//{Atom} (prime=PrimaryExpression ("." Identifier ("(" e+=ExprList ")")? | "[" exp+=Expression "]")*)
		public Group getGroup() { return cGroup; }

		//{Atom}
		public Action getAtomAction_0() { return cAtomAction_0; }

		//prime=PrimaryExpression ("." Identifier ("(" e+=ExprList ")")? | "[" exp+=Expression "]")*
		public Group getGroup_1() { return cGroup_1; }

		//prime=PrimaryExpression
		public Assignment getPrimeAssignment_1_0() { return cPrimeAssignment_1_0; }

		//PrimaryExpression
		public RuleCall getPrimePrimaryExpressionParserRuleCall_1_0_0() { return cPrimePrimaryExpressionParserRuleCall_1_0_0; }

		//("." Identifier ("(" e+=ExprList ")")? | "[" exp+=Expression "]")*
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//"." Identifier ("(" e+=ExprList ")")?
		public Group getGroup_1_1_0() { return cGroup_1_1_0; }

		//"."
		public Keyword getFullStopKeyword_1_1_0_0() { return cFullStopKeyword_1_1_0_0; }

		//Identifier
		public RuleCall getIdentifierParserRuleCall_1_1_0_1() { return cIdentifierParserRuleCall_1_1_0_1; }

		//("(" e+=ExprList ")")?
		public Group getGroup_1_1_0_2() { return cGroup_1_1_0_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_1_0_2_0() { return cLeftParenthesisKeyword_1_1_0_2_0; }

		//e+=ExprList
		public Assignment getEAssignment_1_1_0_2_1() { return cEAssignment_1_1_0_2_1; }

		//ExprList
		public RuleCall getEExprListParserRuleCall_1_1_0_2_1_0() { return cEExprListParserRuleCall_1_1_0_2_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_1_0_2_2() { return cRightParenthesisKeyword_1_1_0_2_2; }

		//"[" exp+=Expression "]"
		public Group getGroup_1_1_1() { return cGroup_1_1_1; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1_1_1_0() { return cLeftSquareBracketKeyword_1_1_1_0; }

		//exp+=Expression
		public Assignment getExpAssignment_1_1_1_1() { return cExpAssignment_1_1_1_1; }

		//Expression
		public RuleCall getExpExpressionParserRuleCall_1_1_1_1_0() { return cExpExpressionParserRuleCall_1_1_1_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_1_1_2() { return cRightSquareBracketKeyword_1_1_1_2; }
	}

	public class PrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cIdentPrimaryParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Keyword cFullStopKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final RuleCall cCLASSParserRuleCall_0_1_1 = (RuleCall)cGroup_0_1.eContents().get(1);
		private final RuleCall cConstantParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cColonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cIdentifierParserRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Keyword cLeftParenthesisKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Alternatives cAlternatives_3_1 = (Alternatives)cGroup_3.eContents().get(1);
		private final RuleCall cExpressionOrVectorParserRuleCall_3_1_0 = (RuleCall)cAlternatives_3_1.eContents().get(0);
		private final RuleCall cUnionRuleParserRuleCall_3_1_1 = (RuleCall)cAlternatives_3_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_3_2 = (Keyword)cGroup_3.eContents().get(2);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Keyword cQuestionMarkKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		
		//// level 0 - the basic element of an expression
		//PrimaryExpression:
		//	IdentPrimary ("." CLASS)? | Constant | ":" Identifier | "(" (ExpressionOrVector | UnionRule) ")" | "?" INT?;
		public ParserRule getRule() { return rule; }

		//IdentPrimary ("." CLASS)? | Constant | ":" Identifier | "(" (ExpressionOrVector | UnionRule) ")" | "?" INT?
		public Alternatives getAlternatives() { return cAlternatives; }

		//IdentPrimary ("." CLASS)?
		public Group getGroup_0() { return cGroup_0; }

		//IdentPrimary
		public RuleCall getIdentPrimaryParserRuleCall_0_0() { return cIdentPrimaryParserRuleCall_0_0; }

		//("." CLASS)?
		public Group getGroup_0_1() { return cGroup_0_1; }

		//"."
		public Keyword getFullStopKeyword_0_1_0() { return cFullStopKeyword_0_1_0; }

		//CLASS
		public RuleCall getCLASSParserRuleCall_0_1_1() { return cCLASSParserRuleCall_0_1_1; }

		//Constant
		public RuleCall getConstantParserRuleCall_1() { return cConstantParserRuleCall_1; }

		//":" Identifier
		public Group getGroup_2() { return cGroup_2; }

		//":"
		public Keyword getColonKeyword_2_0() { return cColonKeyword_2_0; }

		//Identifier
		public RuleCall getIdentifierParserRuleCall_2_1() { return cIdentifierParserRuleCall_2_1; }

		//"(" (ExpressionOrVector | UnionRule) ")"
		public Group getGroup_3() { return cGroup_3; }

		//"("
		public Keyword getLeftParenthesisKeyword_3_0() { return cLeftParenthesisKeyword_3_0; }

		//ExpressionOrVector | UnionRule
		public Alternatives getAlternatives_3_1() { return cAlternatives_3_1; }

		//ExpressionOrVector
		public RuleCall getExpressionOrVectorParserRuleCall_3_1_0() { return cExpressionOrVectorParserRuleCall_3_1_0; }

		//UnionRule
		public RuleCall getUnionRuleParserRuleCall_3_1_1() { return cUnionRuleParserRuleCall_3_1_1; }

		//")"
		public Keyword getRightParenthesisKeyword_3_2() { return cRightParenthesisKeyword_3_2; }

		//"?" INT?
		public Group getGroup_4() { return cGroup_4; }

		//"?"
		public Keyword getQuestionMarkKeyword_4_0() { return cQuestionMarkKeyword_4_0; }

		//INT?
		public RuleCall getINTTerminalRuleCall_4_1() { return cINTTerminalRuleCall_4_1; }
	}

	public class ExpressionOrVectorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExpressionOrVector");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cVAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVVectorExprParserRuleCall_1_0 = (RuleCall)cVAssignment_1.eContents().get(0);
		
		//// This parses normal expression and a list of expressions separated by commas.  If a comma is encountered
		//// a parent VECTOR_EXPR node will be created for the list.
		//ExpressionOrVector:
		//	Expression v=VectorExpr?;
		public ParserRule getRule() { return rule; }

		//Expression v=VectorExpr?
		public Group getGroup() { return cGroup; }

		//Expression
		public RuleCall getExpressionParserRuleCall_0() { return cExpressionParserRuleCall_0; }

		//v=VectorExpr?
		public Assignment getVAssignment_1() { return cVAssignment_1; }

		//VectorExpr
		public RuleCall getVVectorExprParserRuleCall_1_0() { return cVVectorExprParserRuleCall_1_0; }
	}

	public class VectorExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VectorExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCommaKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cEAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_1_0 = (RuleCall)cEAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cEAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_2_1_0 = (RuleCall)cEAssignment_2_1.eContents().get(0);
		
		//VectorExpr:
		//	"," e+=Expression ("," e+=Expression)*;
		public ParserRule getRule() { return rule; }

		//"," e+=Expression ("," e+=Expression)*
		public Group getGroup() { return cGroup; }

		//","
		public Keyword getCommaKeyword_0() { return cCommaKeyword_0; }

		//e+=Expression
		public Assignment getEAssignment_1() { return cEAssignment_1; }

		//Expression
		public RuleCall getEExpressionParserRuleCall_1_0() { return cEExpressionParserRuleCall_1_0; }

		//("," e+=Expression)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//e+=Expression
		public Assignment getEAssignment_2_1() { return cEAssignment_2_1; }

		//Expression
		public RuleCall getEExpressionParserRuleCall_2_1_0() { return cEExpressionParserRuleCall_2_1_0; }
	}

	public class IdentPrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IdentPrimary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cIdentPrimaryAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final RuleCall cIdentifierParserRuleCall_0_1_0 = (RuleCall)cGroup_0_1.eContents().get(0);
		private final Alternatives cAlternatives_0_1_1 = (Alternatives)cGroup_0_1.eContents().get(1);
		private final Group cGroup_0_1_1_0 = (Group)cAlternatives_0_1_1.eContents().get(0);
		private final Keyword cFullStopKeyword_0_1_1_0_0 = (Keyword)cGroup_0_1_1_0.eContents().get(0);
		private final RuleCall cIdentifierParserRuleCall_0_1_1_0_1 = (RuleCall)cGroup_0_1_1_0.eContents().get(1);
		private final Group cGroup_0_1_1_1 = (Group)cAlternatives_0_1_1.eContents().get(1);
		private final Keyword cFullStopKeyword_0_1_1_1_0 = (Keyword)cGroup_0_1_1_1.eContents().get(0);
		private final RuleCall cELEMENTSParserRuleCall_0_1_1_1_1 = (RuleCall)cGroup_0_1_1_1.eContents().get(1);
		private final Group cGroup_0_1_1_2 = (Group)cAlternatives_0_1_1.eContents().get(2);
		private final Keyword cFullStopKeyword_0_1_1_2_0 = (Keyword)cGroup_0_1_1_2.eContents().get(0);
		private final RuleCall cOBJECTParserRuleCall_0_1_1_2_1 = (RuleCall)cGroup_0_1_1_2.eContents().get(1);
		private final Group cGroup_0_1_2 = (Group)cGroup_0_1.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_0_1_2_0 = (Keyword)cGroup_0_1_2.eContents().get(0);
		private final Assignment cEAssignment_0_1_2_1 = (Assignment)cGroup_0_1_2.eContents().get(1);
		private final RuleCall cEExprListParserRuleCall_0_1_2_1_0 = (RuleCall)cEAssignment_0_1_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_0_1_2_2 = (Keyword)cGroup_0_1_2.eContents().get(2);
		private final RuleCall cAggregateParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// identifier, followed by member refs (dot ident), or method calls.
		//// NOTE: handleDotIdent() is called immediately after the first IDENT is recognized because
		//// the method looks a head to find keywords after '.' and turns them into identifiers.
		//IdentPrimary:
		//	{IdentPrimary} (Identifier ("." Identifier | "." ELEMENTS | "." OBJECT)* ("(" e=ExprList ")")?) | Aggregate;
		public ParserRule getRule() { return rule; }

		//{IdentPrimary} (Identifier ("." Identifier | "." ELEMENTS | "." OBJECT)* ("(" e=ExprList ")")?) | Aggregate
		public Alternatives getAlternatives() { return cAlternatives; }

		//{IdentPrimary} (Identifier ("." Identifier | "." ELEMENTS | "." OBJECT)* ("(" e=ExprList ")")?)
		public Group getGroup_0() { return cGroup_0; }

		//{IdentPrimary}
		public Action getIdentPrimaryAction_0_0() { return cIdentPrimaryAction_0_0; }

		//Identifier ("." Identifier | "." ELEMENTS | "." OBJECT)* ("(" e=ExprList ")")?
		public Group getGroup_0_1() { return cGroup_0_1; }

		//Identifier
		public RuleCall getIdentifierParserRuleCall_0_1_0() { return cIdentifierParserRuleCall_0_1_0; }

		//("." Identifier | "." ELEMENTS | "." OBJECT)*
		public Alternatives getAlternatives_0_1_1() { return cAlternatives_0_1_1; }

		//"." Identifier
		public Group getGroup_0_1_1_0() { return cGroup_0_1_1_0; }

		//"."
		public Keyword getFullStopKeyword_0_1_1_0_0() { return cFullStopKeyword_0_1_1_0_0; }

		//Identifier
		public RuleCall getIdentifierParserRuleCall_0_1_1_0_1() { return cIdentifierParserRuleCall_0_1_1_0_1; }

		//"." ELEMENTS
		public Group getGroup_0_1_1_1() { return cGroup_0_1_1_1; }

		//"."
		public Keyword getFullStopKeyword_0_1_1_1_0() { return cFullStopKeyword_0_1_1_1_0; }

		//ELEMENTS
		public RuleCall getELEMENTSParserRuleCall_0_1_1_1_1() { return cELEMENTSParserRuleCall_0_1_1_1_1; }

		//"." OBJECT
		public Group getGroup_0_1_1_2() { return cGroup_0_1_1_2; }

		//"."
		public Keyword getFullStopKeyword_0_1_1_2_0() { return cFullStopKeyword_0_1_1_2_0; }

		//OBJECT
		public RuleCall getOBJECTParserRuleCall_0_1_1_2_1() { return cOBJECTParserRuleCall_0_1_1_2_1; }

		//("(" e=ExprList ")")?
		public Group getGroup_0_1_2() { return cGroup_0_1_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_1_2_0() { return cLeftParenthesisKeyword_0_1_2_0; }

		//e=ExprList
		public Assignment getEAssignment_0_1_2_1() { return cEAssignment_0_1_2_1; }

		//ExprList
		public RuleCall getEExprListParserRuleCall_0_1_2_1_0() { return cEExprListParserRuleCall_0_1_2_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_0_1_2_2() { return cRightParenthesisKeyword_0_1_2_2; }

		//Aggregate
		public RuleCall getAggregateParserRuleCall_1() { return cAggregateParserRuleCall_1; }
	}

	public class AggregateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Aggregate");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cAggregateAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Alternatives cAlternatives_0_1 = (Alternatives)cGroup_0.eContents().get(1);
		private final RuleCall cSUMParserRuleCall_0_1_0 = (RuleCall)cAlternatives_0_1.eContents().get(0);
		private final RuleCall cAVGParserRuleCall_0_1_1 = (RuleCall)cAlternatives_0_1.eContents().get(1);
		private final RuleCall cMAXParserRuleCall_0_1_2 = (RuleCall)cAlternatives_0_1.eContents().get(2);
		private final RuleCall cMINParserRuleCall_0_1_3 = (RuleCall)cAlternatives_0_1.eContents().get(3);
		private final Keyword cLeftParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Assignment cAAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cAAdditiveExpressionParserRuleCall_0_3_0 = (RuleCall)cAAssignment_0_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_0_4 = (Keyword)cGroup_0.eContents().get(4);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cAggregateAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final RuleCall cCOUNTParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Alternatives cAlternatives_1_3 = (Alternatives)cGroup_1.eContents().get(3);
		private final Keyword cAsteriskKeyword_1_3_0 = (Keyword)cAlternatives_1_3.eContents().get(0);
		private final Group cGroup_1_3_1 = (Group)cAlternatives_1_3.eContents().get(1);
		private final Alternatives cAlternatives_1_3_1_0 = (Alternatives)cGroup_1_3_1.eContents().get(0);
		private final RuleCall cDISTINCTParserRuleCall_1_3_1_0_0 = (RuleCall)cAlternatives_1_3_1_0.eContents().get(0);
		private final RuleCall cALLParserRuleCall_1_3_1_0_1 = (RuleCall)cAlternatives_1_3_1_0.eContents().get(1);
		private final Alternatives cAlternatives_1_3_1_1 = (Alternatives)cGroup_1_3_1.eContents().get(1);
		private final RuleCall cPathParserRuleCall_1_3_1_1_0 = (RuleCall)cAlternatives_1_3_1_1.eContents().get(0);
		private final RuleCall cCollectionExprParserRuleCall_1_3_1_1_1 = (RuleCall)cAlternatives_1_3_1_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final RuleCall cCollectionExprParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		////## aggregate:
		////##     ( aggregateFunction OPEN Path CLOSE ) | ( COUNT OPEN '*' CLOSE ) | ( COUNT OPEN (DISTINCT | ALL) Path CLOSE );
		////## aggregateFunction:
		////##     COUNT | 'sum' | 'avg' | 'max' | 'min';
		//Aggregate:
		//	{Aggregate} (SUM | AVG | MAX | MIN) "(" a=AdditiveExpression ")" // Special case for count - It's 'parameters' can be keywords.
		//	| {Aggregate} COUNT "(" ("*" | (DISTINCT | ALL)? (Path | CollectionExpr)) ")" | CollectionExpr;
		public ParserRule getRule() { return rule; }

		//{Aggregate} (SUM | AVG | MAX | MIN) "(" a=AdditiveExpression ")" // Special case for count - It's 'parameters' can be keywords.
		//| {Aggregate} COUNT "(" ("*" | (DISTINCT | ALL)? (Path | CollectionExpr)) ")" | CollectionExpr
		public Alternatives getAlternatives() { return cAlternatives; }

		//{Aggregate} (SUM | AVG | MAX | MIN) "(" a=AdditiveExpression ")"
		public Group getGroup_0() { return cGroup_0; }

		//{Aggregate}
		public Action getAggregateAction_0_0() { return cAggregateAction_0_0; }

		//SUM | AVG | MAX | MIN
		public Alternatives getAlternatives_0_1() { return cAlternatives_0_1; }

		//SUM
		public RuleCall getSUMParserRuleCall_0_1_0() { return cSUMParserRuleCall_0_1_0; }

		//AVG
		public RuleCall getAVGParserRuleCall_0_1_1() { return cAVGParserRuleCall_0_1_1; }

		//MAX
		public RuleCall getMAXParserRuleCall_0_1_2() { return cMAXParserRuleCall_0_1_2; }

		//MIN
		public RuleCall getMINParserRuleCall_0_1_3() { return cMINParserRuleCall_0_1_3; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_2() { return cLeftParenthesisKeyword_0_2; }

		//a=AdditiveExpression
		public Assignment getAAssignment_0_3() { return cAAssignment_0_3; }

		//AdditiveExpression
		public RuleCall getAAdditiveExpressionParserRuleCall_0_3_0() { return cAAdditiveExpressionParserRuleCall_0_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_0_4() { return cRightParenthesisKeyword_0_4; }

		//{Aggregate} COUNT "(" ("*" | (DISTINCT | ALL)? (Path | CollectionExpr)) ")"
		public Group getGroup_1() { return cGroup_1; }

		//{Aggregate}
		public Action getAggregateAction_1_0() { return cAggregateAction_1_0; }

		//COUNT
		public RuleCall getCOUNTParserRuleCall_1_1() { return cCOUNTParserRuleCall_1_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_2() { return cLeftParenthesisKeyword_1_2; }

		//"*" | (DISTINCT | ALL)? (Path | CollectionExpr)
		public Alternatives getAlternatives_1_3() { return cAlternatives_1_3; }

		//"*"
		public Keyword getAsteriskKeyword_1_3_0() { return cAsteriskKeyword_1_3_0; }

		//(DISTINCT | ALL)? (Path | CollectionExpr)
		public Group getGroup_1_3_1() { return cGroup_1_3_1; }

		//(DISTINCT | ALL)?
		public Alternatives getAlternatives_1_3_1_0() { return cAlternatives_1_3_1_0; }

		//DISTINCT
		public RuleCall getDISTINCTParserRuleCall_1_3_1_0_0() { return cDISTINCTParserRuleCall_1_3_1_0_0; }

		//ALL
		public RuleCall getALLParserRuleCall_1_3_1_0_1() { return cALLParserRuleCall_1_3_1_0_1; }

		//Path | CollectionExpr
		public Alternatives getAlternatives_1_3_1_1() { return cAlternatives_1_3_1_1; }

		//Path
		public RuleCall getPathParserRuleCall_1_3_1_1_0() { return cPathParserRuleCall_1_3_1_1_0; }

		//CollectionExpr
		public RuleCall getCollectionExprParserRuleCall_1_3_1_1_1() { return cCollectionExprParserRuleCall_1_3_1_1_1; }

		//")"
		public Keyword getRightParenthesisKeyword_1_4() { return cRightParenthesisKeyword_1_4; }

		//CollectionExpr
		public RuleCall getCollectionExprParserRuleCall_2() { return cCollectionExprParserRuleCall_2; }
	}

	public class CollectionExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CollectionExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cELEMENTSParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cINDICESParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cPathParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		////## collection: ( OPEN query CLOSE ) | ( 'elements'|'indices' OPEN Path CLOSE );
		//CollectionExpr returns ecore::EString:
		//	(ELEMENTS | INDICES) "(" Path ")";
		public ParserRule getRule() { return rule; }

		//(ELEMENTS | INDICES) "(" Path ")"
		public Group getGroup() { return cGroup; }

		//ELEMENTS | INDICES
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//ELEMENTS
		public RuleCall getELEMENTSParserRuleCall_0_0() { return cELEMENTSParserRuleCall_0_0; }

		//INDICES
		public RuleCall getINDICESParserRuleCall_0_1() { return cINDICESParserRuleCall_0_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//Path
		public RuleCall getPathParserRuleCall_2() { return cPathParserRuleCall_2; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class CompoundExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CompoundExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCollectionExprParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPathParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Alternatives cAlternatives_2_1 = (Alternatives)cGroup_2.eContents().get(1);
		private final Group cGroup_2_1_0 = (Group)cAlternatives_2_1.eContents().get(0);
		private final Assignment cEAssignment_2_1_0_0 = (Assignment)cGroup_2_1_0.eContents().get(0);
		private final RuleCall cEExpressionParserRuleCall_2_1_0_0_0 = (RuleCall)cEAssignment_2_1_0_0.eContents().get(0);
		private final Group cGroup_2_1_0_1 = (Group)cGroup_2_1_0.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0_1_0 = (Keyword)cGroup_2_1_0_1.eContents().get(0);
		private final Assignment cEAssignment_2_1_0_1_1 = (Assignment)cGroup_2_1_0_1.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_2_1_0_1_1_0 = (RuleCall)cEAssignment_2_1_0_1_1.eContents().get(0);
		private final Assignment cSAssignment_2_1_1 = (Assignment)cAlternatives_2_1.eContents().get(1);
		private final RuleCall cSUnionRuleParserRuleCall_2_1_1_0 = (RuleCall)cSAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		
		//// NOTE: CompoundExpr can be a 'Path' where the last token in the path is '.elements' or '.indicies'
		//CompoundExpr:
		//	CollectionExpr | Path | "(" (e+=Expression ("," e+=Expression)* | s=UnionRule) ")";
		public ParserRule getRule() { return rule; }

		//CollectionExpr | Path | "(" (e+=Expression ("," e+=Expression)* | s=UnionRule) ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//CollectionExpr
		public RuleCall getCollectionExprParserRuleCall_0() { return cCollectionExprParserRuleCall_0; }

		//Path
		public RuleCall getPathParserRuleCall_1() { return cPathParserRuleCall_1; }

		//"(" (e+=Expression ("," e+=Expression)* | s=UnionRule) ")"
		public Group getGroup_2() { return cGroup_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }

		//e+=Expression ("," e+=Expression)* | s=UnionRule
		public Alternatives getAlternatives_2_1() { return cAlternatives_2_1; }

		//e+=Expression ("," e+=Expression)*
		public Group getGroup_2_1_0() { return cGroup_2_1_0; }

		//e+=Expression
		public Assignment getEAssignment_2_1_0_0() { return cEAssignment_2_1_0_0; }

		//Expression
		public RuleCall getEExpressionParserRuleCall_2_1_0_0_0() { return cEExpressionParserRuleCall_2_1_0_0_0; }

		//("," e+=Expression)*
		public Group getGroup_2_1_0_1() { return cGroup_2_1_0_1; }

		//","
		public Keyword getCommaKeyword_2_1_0_1_0() { return cCommaKeyword_2_1_0_1_0; }

		//e+=Expression
		public Assignment getEAssignment_2_1_0_1_1() { return cEAssignment_2_1_0_1_1; }

		//Expression
		public RuleCall getEExpressionParserRuleCall_2_1_0_1_1_0() { return cEExpressionParserRuleCall_2_1_0_1_1_0; }

		//s=UnionRule
		public Assignment getSAssignment_2_1_1() { return cSAssignment_2_1_1; }

		//UnionRule
		public RuleCall getSUnionRuleParserRuleCall_2_1_1_0() { return cSUnionRuleParserRuleCall_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
	}

	public class ExprListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExprList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cTRAILINGParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cLEADINGParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final RuleCall cBOTHParserRuleCall_0_2 = (RuleCall)cAlternatives_0.eContents().get(2);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Assignment cEAssignment_1_0_0 = (Assignment)cGroup_1_0.eContents().get(0);
		private final RuleCall cEExpressionParserRuleCall_1_0_0_0 = (RuleCall)cEAssignment_1_0_0.eContents().get(0);
		private final Alternatives cAlternatives_1_0_1 = (Alternatives)cGroup_1_0.eContents().get(1);
		private final Group cGroup_1_0_1_0 = (Group)cAlternatives_1_0_1.eContents().get(0);
		private final Keyword cCommaKeyword_1_0_1_0_0 = (Keyword)cGroup_1_0_1_0.eContents().get(0);
		private final Assignment cEAssignment_1_0_1_0_1 = (Assignment)cGroup_1_0_1_0.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_1_0_1_0_1_0 = (RuleCall)cEAssignment_1_0_1_0_1.eContents().get(0);
		private final Group cGroup_1_0_1_1 = (Group)cAlternatives_1_0_1.eContents().get(1);
		private final RuleCall cFROMParserRuleCall_1_0_1_1_0 = (RuleCall)cGroup_1_0_1_1.eContents().get(0);
		private final Assignment cEAssignment_1_0_1_1_1 = (Assignment)cGroup_1_0_1_1.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_1_0_1_1_1_0 = (RuleCall)cEAssignment_1_0_1_1_1.eContents().get(0);
		private final Group cGroup_1_0_1_2 = (Group)cAlternatives_1_0_1.eContents().get(2);
		private final RuleCall cASParserRuleCall_1_0_1_2_0 = (RuleCall)cGroup_1_0_1_2.eContents().get(0);
		private final Assignment cIdAssignment_1_0_1_2_1 = (Assignment)cGroup_1_0_1_2.eContents().get(1);
		private final RuleCall cIdIdentifierParserRuleCall_1_0_1_2_1_0 = (RuleCall)cIdAssignment_1_0_1_2_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final RuleCall cFROMParserRuleCall_1_1_0 = (RuleCall)cGroup_1_1.eContents().get(0);
		private final Assignment cEAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_1_1_1_0 = (RuleCall)cEAssignment_1_1_1.eContents().get(0);
		
		//ExprList:
		//	(TRAILING | LEADING | BOTH)? (e+=Expression (("," e+=Expression)+ | FROM e+=Expression | AS id=Identifier)? | FROM
		//	e+=Expression)?;
		public ParserRule getRule() { return rule; }

		//(TRAILING | LEADING | BOTH)? (e+=Expression (("," e+=Expression)+ | FROM e+=Expression | AS id=Identifier)? | FROM
		//e+=Expression)?
		public Group getGroup() { return cGroup; }

		//(TRAILING | LEADING | BOTH)?
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//TRAILING
		public RuleCall getTRAILINGParserRuleCall_0_0() { return cTRAILINGParserRuleCall_0_0; }

		//LEADING
		public RuleCall getLEADINGParserRuleCall_0_1() { return cLEADINGParserRuleCall_0_1; }

		//BOTH
		public RuleCall getBOTHParserRuleCall_0_2() { return cBOTHParserRuleCall_0_2; }

		//(e+=Expression (("," e+=Expression)+ | FROM e+=Expression | AS id=Identifier)? | FROM e+=Expression)?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//e+=Expression (("," e+=Expression)+ | FROM e+=Expression | AS id=Identifier)?
		public Group getGroup_1_0() { return cGroup_1_0; }

		//e+=Expression
		public Assignment getEAssignment_1_0_0() { return cEAssignment_1_0_0; }

		//Expression
		public RuleCall getEExpressionParserRuleCall_1_0_0_0() { return cEExpressionParserRuleCall_1_0_0_0; }

		//(("," e+=Expression)+ | FROM e+=Expression | AS id=Identifier)?
		public Alternatives getAlternatives_1_0_1() { return cAlternatives_1_0_1; }

		//("," e+=Expression)+
		public Group getGroup_1_0_1_0() { return cGroup_1_0_1_0; }

		//","
		public Keyword getCommaKeyword_1_0_1_0_0() { return cCommaKeyword_1_0_1_0_0; }

		//e+=Expression
		public Assignment getEAssignment_1_0_1_0_1() { return cEAssignment_1_0_1_0_1; }

		//Expression
		public RuleCall getEExpressionParserRuleCall_1_0_1_0_1_0() { return cEExpressionParserRuleCall_1_0_1_0_1_0; }

		//FROM e+=Expression
		public Group getGroup_1_0_1_1() { return cGroup_1_0_1_1; }

		//FROM
		public RuleCall getFROMParserRuleCall_1_0_1_1_0() { return cFROMParserRuleCall_1_0_1_1_0; }

		//e+=Expression
		public Assignment getEAssignment_1_0_1_1_1() { return cEAssignment_1_0_1_1_1; }

		//Expression
		public RuleCall getEExpressionParserRuleCall_1_0_1_1_1_0() { return cEExpressionParserRuleCall_1_0_1_1_1_0; }

		//AS id=Identifier
		public Group getGroup_1_0_1_2() { return cGroup_1_0_1_2; }

		//AS
		public RuleCall getASParserRuleCall_1_0_1_2_0() { return cASParserRuleCall_1_0_1_2_0; }

		//id=Identifier
		public Assignment getIdAssignment_1_0_1_2_1() { return cIdAssignment_1_0_1_2_1; }

		//Identifier
		public RuleCall getIdIdentifierParserRuleCall_1_0_1_2_1_0() { return cIdIdentifierParserRuleCall_1_0_1_2_1_0; }

		//FROM e+=Expression
		public Group getGroup_1_1() { return cGroup_1_1; }

		//FROM
		public RuleCall getFROMParserRuleCall_1_1_0() { return cFROMParserRuleCall_1_1_0; }

		//e+=Expression
		public Assignment getEAssignment_1_1_1() { return cEAssignment_1_1_1; }

		//Expression
		public RuleCall getEExpressionParserRuleCall_1_1_1_0() { return cEExpressionParserRuleCall_1_1_1_0; }
	}

	public class ConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Constant");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNumberParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSTRINGTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cNULLParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cTRUEParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cFALSEParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cEMPTYParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//Constant returns ecore::EString:
		//	Number | STRING | NULL | TRUE | FALSE | EMPTY;
		public ParserRule getRule() { return rule; }

		//Number | STRING | NULL | TRUE | FALSE | EMPTY
		public Alternatives getAlternatives() { return cAlternatives; }

		//Number
		public RuleCall getNumberParserRuleCall_0() { return cNumberParserRuleCall_0; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_1() { return cSTRINGTerminalRuleCall_1; }

		//NULL
		public RuleCall getNULLParserRuleCall_2() { return cNULLParserRuleCall_2; }

		//TRUE
		public RuleCall getTRUEParserRuleCall_3() { return cTRUEParserRuleCall_3; }

		//FALSE
		public RuleCall getFALSEParserRuleCall_4() { return cFALSEParserRuleCall_4; }

		//EMPTY
		public RuleCall getEMPTYParserRuleCall_5() { return cEMPTYParserRuleCall_5; }
	}

	public class PathElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Path");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIdentifierParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIdentifierParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		////## QuantifiedExpression: 'exists' | ( expression 'in' ) | ( Expression OP 'any' | 'some' ) collection;
		////## compoundPath: Path ( OPEN_BRACKET Expression CLOSE_BRACKET ( '.' Path )? )*;
		////## Path: Identifier ( '.' Identifier )*;
		//Path returns ecore::EString:
		//	Identifier ("." Identifier)*;
		public ParserRule getRule() { return rule; }

		//Identifier ("." Identifier)*
		public Group getGroup() { return cGroup; }

		//Identifier
		public RuleCall getIdentifierParserRuleCall_0() { return cIdentifierParserRuleCall_0; }

		//("." Identifier)*
		public Group getGroup_1() { return cGroup_1; }

		//"."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//Identifier
		public RuleCall getIdentifierParserRuleCall_1_1() { return cIdentifierParserRuleCall_1_1; }
	}

	public class IdentifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Identifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cDollarSignKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cEKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cFKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cDKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cUpperKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cLowerKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cNowKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cTodayKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cDateKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cTitleKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cTypeKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cIncludeKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cLengthKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final RuleCall cENDParserRuleCall_13 = (RuleCall)cAlternatives.eContents().get(13);
		private final RuleCall cWHENParserRuleCall_14 = (RuleCall)cAlternatives.eContents().get(14);
		private final RuleCall cFROMParserRuleCall_15 = (RuleCall)cAlternatives.eContents().get(15);
		private final RuleCall cMEMBERParserRuleCall_16 = (RuleCall)cAlternatives.eContents().get(16);
		
		//Identifier returns ecore::EString:
		//	"$"? ID | "e" | "f" | // To allow number terminals as function arguments
		//	"d" | "upper" | "lower" | "$now" | "$today" | "date" | "title" | "type" | "include" | //MDD keywords that can appear in Query Functions
		//	"length" | END | WHEN | FROM | MEMBER;
		public ParserRule getRule() { return rule; }

		//"$"? ID | "e" | "f" | // To allow number terminals as function arguments
		//"d" | "upper" | "lower" | "$now" | "$today" | "date" | "title" | "type" | "include" | //MDD keywords that can appear in Query Functions
		//"length" | END | WHEN | FROM | MEMBER
		public Alternatives getAlternatives() { return cAlternatives; }

		//"$"? ID
		public Group getGroup_0() { return cGroup_0; }

		//"$"?
		public Keyword getDollarSignKeyword_0_0() { return cDollarSignKeyword_0_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_0_1() { return cIDTerminalRuleCall_0_1; }

		//"e"
		public Keyword getEKeyword_1() { return cEKeyword_1; }

		//"f"
		public Keyword getFKeyword_2() { return cFKeyword_2; }

		//// To allow number terminals as function arguments
		//"d"
		public Keyword getDKeyword_3() { return cDKeyword_3; }

		//"upper"
		public Keyword getUpperKeyword_4() { return cUpperKeyword_4; }

		//"lower"
		public Keyword getLowerKeyword_5() { return cLowerKeyword_5; }

		//"$now"
		public Keyword getNowKeyword_6() { return cNowKeyword_6; }

		//"$today"
		public Keyword getTodayKeyword_7() { return cTodayKeyword_7; }

		//"date"
		public Keyword getDateKeyword_8() { return cDateKeyword_8; }

		//"title"
		public Keyword getTitleKeyword_9() { return cTitleKeyword_9; }

		//"type"
		public Keyword getTypeKeyword_10() { return cTypeKeyword_10; }

		//"include"
		public Keyword getIncludeKeyword_11() { return cIncludeKeyword_11; }

		////MDD keywords that can appear in Query Functions
		//"length"
		public Keyword getLengthKeyword_12() { return cLengthKeyword_12; }

		//END
		public RuleCall getENDParserRuleCall_13() { return cENDParserRuleCall_13; }

		//WHEN
		public RuleCall getWHENParserRuleCall_14() { return cWHENParserRuleCall_14; }

		//FROM
		public RuleCall getFROMParserRuleCall_15() { return cFROMParserRuleCall_15; }

		//MEMBER
		public RuleCall getMEMBERParserRuleCall_16() { return cMEMBERParserRuleCall_16; }
	}

	public class NumberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Number");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cFullStopKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0_1_0 = (RuleCall)cGroup_0_1.eContents().get(0);
		private final Group cGroup_0_1_1 = (Group)cGroup_0_1.eContents().get(1);
		private final Keyword cEKeyword_0_1_1_0 = (Keyword)cGroup_0_1_1.eContents().get(0);
		private final Alternatives cAlternatives_0_1_1_1 = (Alternatives)cGroup_0_1_1.eContents().get(1);
		private final Keyword cPlusSignKeyword_0_1_1_1_0 = (Keyword)cAlternatives_0_1_1_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_0_1_1_1_1 = (Keyword)cAlternatives_0_1_1_1.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0_1_1_2 = (RuleCall)cGroup_0_1_1.eContents().get(2);
		private final Alternatives cAlternatives_0_1_2 = (Alternatives)cGroup_0_1.eContents().get(2);
		private final Keyword cFKeyword_0_1_2_0 = (Keyword)cAlternatives_0_1_2.eContents().get(0);
		private final Keyword cDKeyword_0_1_2_1 = (Keyword)cAlternatives_0_1_2.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final RuleCall cHEXTerminalRuleCall_1_0_0 = (RuleCall)cAlternatives_1_0.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1_0_1 = (RuleCall)cAlternatives_1_0.eContents().get(1);
		private final RuleCall cSIGNED_INTTerminalRuleCall_1_0_2 = (RuleCall)cAlternatives_1_0.eContents().get(2);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cLKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1_1 = (Alternatives)cAlternatives_1_1.eContents().get(1);
		private final Group cGroup_1_1_1_0 = (Group)cAlternatives_1_1_1.eContents().get(0);
		private final Keyword cFullStopKeyword_1_1_1_0_0 = (Keyword)cGroup_1_1_1_0.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1_1_1_0_1 = (RuleCall)cGroup_1_1_1_0.eContents().get(1);
		private final Group cGroup_1_1_1_0_2 = (Group)cGroup_1_1_1_0.eContents().get(2);
		private final Keyword cEKeyword_1_1_1_0_2_0 = (Keyword)cGroup_1_1_1_0_2.eContents().get(0);
		private final Alternatives cAlternatives_1_1_1_0_2_1 = (Alternatives)cGroup_1_1_1_0_2.eContents().get(1);
		private final Keyword cPlusSignKeyword_1_1_1_0_2_1_0 = (Keyword)cAlternatives_1_1_1_0_2_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_1_1_0_2_1_1 = (Keyword)cAlternatives_1_1_1_0_2_1.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_1_1_1_0_2_2 = (RuleCall)cGroup_1_1_1_0_2.eContents().get(2);
		private final Alternatives cAlternatives_1_1_1_0_3 = (Alternatives)cGroup_1_1_1_0.eContents().get(3);
		private final Keyword cFKeyword_1_1_1_0_3_0 = (Keyword)cAlternatives_1_1_1_0_3.eContents().get(0);
		private final Keyword cDKeyword_1_1_1_0_3_1 = (Keyword)cAlternatives_1_1_1_0_3.eContents().get(1);
		private final Group cGroup_1_1_1_1 = (Group)cAlternatives_1_1_1.eContents().get(1);
		private final Keyword cEKeyword_1_1_1_1_0 = (Keyword)cGroup_1_1_1_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1_1_1_1 = (Alternatives)cGroup_1_1_1_1.eContents().get(1);
		private final Keyword cPlusSignKeyword_1_1_1_1_1_0 = (Keyword)cAlternatives_1_1_1_1_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_1_1_1_1_1 = (Keyword)cAlternatives_1_1_1_1_1.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_1_1_1_1_2 = (RuleCall)cGroup_1_1_1_1.eContents().get(2);
		private final Alternatives cAlternatives_1_1_1_1_3 = (Alternatives)cGroup_1_1_1_1.eContents().get(3);
		private final Keyword cFKeyword_1_1_1_1_3_0 = (Keyword)cAlternatives_1_1_1_1_3.eContents().get(0);
		private final Keyword cDKeyword_1_1_1_1_3_1 = (Keyword)cAlternatives_1_1_1_1_3.eContents().get(1);
		private final Keyword cFKeyword_1_1_1_2 = (Keyword)cAlternatives_1_1_1.eContents().get(2);
		private final Keyword cDKeyword_1_1_1_3 = (Keyword)cAlternatives_1_1_1.eContents().get(3);
		
		//Number returns ecore::EFloat:
		//	"." (INT ("e" ("+" | "-")? INT)? ("f" | "d")?)? | (HEX | INT | SIGNED_INT) ("l" | ("." INT? ("e" ("+" | "-")? INT)?
		//	("f" | "d")? | "e" ("+" | "-")? INT ("f" | "d")? | "f" | "d"))?;
		public ParserRule getRule() { return rule; }

		//"." (INT ("e" ("+" | "-")? INT)? ("f" | "d")?)? | (HEX | INT | SIGNED_INT) ("l" | ("." INT? ("e" ("+" | "-")? INT)? ("f"
		//| "d")? | "e" ("+" | "-")? INT ("f" | "d")? | "f" | "d"))?
		public Alternatives getAlternatives() { return cAlternatives; }

		//"." (INT ("e" ("+" | "-")? INT)? ("f" | "d")?)?
		public Group getGroup_0() { return cGroup_0; }

		//"."
		public Keyword getFullStopKeyword_0_0() { return cFullStopKeyword_0_0; }

		//(INT ("e" ("+" | "-")? INT)? ("f" | "d")?)?
		public Group getGroup_0_1() { return cGroup_0_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_0_1_0() { return cINTTerminalRuleCall_0_1_0; }

		//("e" ("+" | "-")? INT)?
		public Group getGroup_0_1_1() { return cGroup_0_1_1; }

		//"e"
		public Keyword getEKeyword_0_1_1_0() { return cEKeyword_0_1_1_0; }

		//("+" | "-")?
		public Alternatives getAlternatives_0_1_1_1() { return cAlternatives_0_1_1_1; }

		//"+"
		public Keyword getPlusSignKeyword_0_1_1_1_0() { return cPlusSignKeyword_0_1_1_1_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_0_1_1_1_1() { return cHyphenMinusKeyword_0_1_1_1_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_0_1_1_2() { return cINTTerminalRuleCall_0_1_1_2; }

		//("f" | "d")?
		public Alternatives getAlternatives_0_1_2() { return cAlternatives_0_1_2; }

		//"f"
		public Keyword getFKeyword_0_1_2_0() { return cFKeyword_0_1_2_0; }

		//"d"
		public Keyword getDKeyword_0_1_2_1() { return cDKeyword_0_1_2_1; }

		//(HEX | INT | SIGNED_INT) ("l" | ("." INT? ("e" ("+" | "-")? INT)? ("f" | "d")? | "e" ("+" | "-")? INT ("f" | "d")? | "f"
		//| "d"))?
		public Group getGroup_1() { return cGroup_1; }

		//HEX | INT | SIGNED_INT
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//HEX
		public RuleCall getHEXTerminalRuleCall_1_0_0() { return cHEXTerminalRuleCall_1_0_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_0_1() { return cINTTerminalRuleCall_1_0_1; }

		//SIGNED_INT
		public RuleCall getSIGNED_INTTerminalRuleCall_1_0_2() { return cSIGNED_INTTerminalRuleCall_1_0_2; }

		//("l" | ("." INT? ("e" ("+" | "-")? INT)? ("f" | "d")? | "e" ("+" | "-")? INT ("f" | "d")? | "f" | "d"))?
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//"l"
		public Keyword getLKeyword_1_1_0() { return cLKeyword_1_1_0; }

		//"." INT? ("e" ("+" | "-")? INT)? ("f" | "d")? | "e" ("+" | "-")? INT ("f" | "d")? | "f" | "d"
		public Alternatives getAlternatives_1_1_1() { return cAlternatives_1_1_1; }

		//"." INT? ("e" ("+" | "-")? INT)? ("f" | "d")?
		public Group getGroup_1_1_1_0() { return cGroup_1_1_1_0; }

		//"."
		public Keyword getFullStopKeyword_1_1_1_0_0() { return cFullStopKeyword_1_1_1_0_0; }

		//INT?
		public RuleCall getINTTerminalRuleCall_1_1_1_0_1() { return cINTTerminalRuleCall_1_1_1_0_1; }

		//("e" ("+" | "-")? INT)?
		public Group getGroup_1_1_1_0_2() { return cGroup_1_1_1_0_2; }

		//"e"
		public Keyword getEKeyword_1_1_1_0_2_0() { return cEKeyword_1_1_1_0_2_0; }

		//("+" | "-")?
		public Alternatives getAlternatives_1_1_1_0_2_1() { return cAlternatives_1_1_1_0_2_1; }

		//"+"
		public Keyword getPlusSignKeyword_1_1_1_0_2_1_0() { return cPlusSignKeyword_1_1_1_0_2_1_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1_1_1_0_2_1_1() { return cHyphenMinusKeyword_1_1_1_0_2_1_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_1_1_0_2_2() { return cINTTerminalRuleCall_1_1_1_0_2_2; }

		//("f" | "d")?
		public Alternatives getAlternatives_1_1_1_0_3() { return cAlternatives_1_1_1_0_3; }

		//"f"
		public Keyword getFKeyword_1_1_1_0_3_0() { return cFKeyword_1_1_1_0_3_0; }

		//"d"
		public Keyword getDKeyword_1_1_1_0_3_1() { return cDKeyword_1_1_1_0_3_1; }

		//"e" ("+" | "-")? INT ("f" | "d")?
		public Group getGroup_1_1_1_1() { return cGroup_1_1_1_1; }

		//"e"
		public Keyword getEKeyword_1_1_1_1_0() { return cEKeyword_1_1_1_1_0; }

		//("+" | "-")?
		public Alternatives getAlternatives_1_1_1_1_1() { return cAlternatives_1_1_1_1_1; }

		//"+"
		public Keyword getPlusSignKeyword_1_1_1_1_1_0() { return cPlusSignKeyword_1_1_1_1_1_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1_1_1_1_1_1() { return cHyphenMinusKeyword_1_1_1_1_1_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_1_1_1_2() { return cINTTerminalRuleCall_1_1_1_1_2; }

		//("f" | "d")?
		public Alternatives getAlternatives_1_1_1_1_3() { return cAlternatives_1_1_1_1_3; }

		//"f"
		public Keyword getFKeyword_1_1_1_1_3_0() { return cFKeyword_1_1_1_1_3_0; }

		//"d"
		public Keyword getDKeyword_1_1_1_1_3_1() { return cDKeyword_1_1_1_1_3_1; }

		//"f"
		public Keyword getFKeyword_1_1_1_2() { return cFKeyword_1_1_1_2; }

		//"d"
		public Keyword getDKeyword_1_1_1_3() { return cDKeyword_1_1_1_3; }
	}

	public class SELECTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SELECT");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cSELECTKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cSelectKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cSelectKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//SELECT returns ecore::EString:
		//	"SELECT" | "Select" | "select";
		public ParserRule getRule() { return rule; }

		//"SELECT" | "Select" | "select"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"SELECT"
		public Keyword getSELECTKeyword_0() { return cSELECTKeyword_0; }

		//"Select"
		public Keyword getSelectKeyword_1() { return cSelectKeyword_1; }

		//"select"
		public Keyword getSelectKeyword_2() { return cSelectKeyword_2; }
	}

	public class DISTINCTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DISTINCT");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cDISTINCTKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cDistinctKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cDistinctKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//DISTINCT returns ecore::EString:
		//	"DISTINCT" | "Distinct" | "distinct";
		public ParserRule getRule() { return rule; }

		//"DISTINCT" | "Distinct" | "distinct"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"DISTINCT"
		public Keyword getDISTINCTKeyword_0() { return cDISTINCTKeyword_0; }

		//"Distinct"
		public Keyword getDistinctKeyword_1() { return cDistinctKeyword_1; }

		//"distinct"
		public Keyword getDistinctKeyword_2() { return cDistinctKeyword_2; }
	}

	public class NEWElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NEW");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cNEWKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cNewKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cNewKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//NEW returns ecore::EString:
		//	"NEW" | "New" | "new";
		public ParserRule getRule() { return rule; }

		//"NEW" | "New" | "new"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"NEW"
		public Keyword getNEWKeyword_0() { return cNEWKeyword_0; }

		//"New"
		public Keyword getNewKeyword_1() { return cNewKeyword_1; }

		//"new"
		public Keyword getNewKeyword_2() { return cNewKeyword_2; }
	}

	public class OBJECTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OBJECT");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cOBJECTKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cObjectKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cObjectKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//OBJECT returns ecore::EString:
		//	"OBJECT" | "Object" | "object";
		public ParserRule getRule() { return rule; }

		//"OBJECT" | "Object" | "object"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"OBJECT"
		public Keyword getOBJECTKeyword_0() { return cOBJECTKeyword_0; }

		//"Object"
		public Keyword getObjectKeyword_1() { return cObjectKeyword_1; }

		//"object"
		public Keyword getObjectKeyword_2() { return cObjectKeyword_2; }
	}

	public class FROMElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FROM");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cFROMKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFromKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cFromKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//FROM returns ecore::EString:
		//	"FROM" | "From" | "from";
		public ParserRule getRule() { return rule; }

		//"FROM" | "From" | "from"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"FROM"
		public Keyword getFROMKeyword_0() { return cFROMKeyword_0; }

		//"From"
		public Keyword getFromKeyword_1() { return cFromKeyword_1; }

		//"from"
		public Keyword getFromKeyword_2() { return cFromKeyword_2; }
	}

	public class LEFTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LEFT");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cLEFTKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cLeftKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cLeftKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//LEFT returns ecore::EString:
		//	"LEFT" | "Left" | "left";
		public ParserRule getRule() { return rule; }

		//"LEFT" | "Left" | "left"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"LEFT"
		public Keyword getLEFTKeyword_0() { return cLEFTKeyword_0; }

		//"Left"
		public Keyword getLeftKeyword_1() { return cLeftKeyword_1; }

		//"left"
		public Keyword getLeftKeyword_2() { return cLeftKeyword_2; }
	}

	public class RIGHTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RIGHT");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cRIGHTKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cRightKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cRightKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//RIGHT returns ecore::EString:
		//	"RIGHT" | "Right" | "right";
		public ParserRule getRule() { return rule; }

		//"RIGHT" | "Right" | "right"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"RIGHT"
		public Keyword getRIGHTKeyword_0() { return cRIGHTKeyword_0; }

		//"Right"
		public Keyword getRightKeyword_1() { return cRightKeyword_1; }

		//"right"
		public Keyword getRightKeyword_2() { return cRightKeyword_2; }
	}

	public class OUTERElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OUTER");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cOUTERKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cOuterKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cOuterKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//OUTER returns ecore::EString:
		//	"OUTER" | "Outer" | "outer";
		public ParserRule getRule() { return rule; }

		//"OUTER" | "Outer" | "outer"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"OUTER"
		public Keyword getOUTERKeyword_0() { return cOUTERKeyword_0; }

		//"Outer"
		public Keyword getOuterKeyword_1() { return cOuterKeyword_1; }

		//"outer"
		public Keyword getOuterKeyword_2() { return cOuterKeyword_2; }
	}

	public class FULLElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FULL");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cFULLKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFullKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cFullKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//FULL returns ecore::EString:
		//	"FULL" | "Full" | "full";
		public ParserRule getRule() { return rule; }

		//"FULL" | "Full" | "full"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"FULL"
		public Keyword getFULLKeyword_0() { return cFULLKeyword_0; }

		//"Full"
		public Keyword getFullKeyword_1() { return cFullKeyword_1; }

		//"full"
		public Keyword getFullKeyword_2() { return cFullKeyword_2; }
	}

	public class INNERElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "INNER");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cINNERKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cInnerKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cInnerKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//INNER returns ecore::EString:
		//	"INNER" | "Inner" | "inner";
		public ParserRule getRule() { return rule; }

		//"INNER" | "Inner" | "inner"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"INNER"
		public Keyword getINNERKeyword_0() { return cINNERKeyword_0; }

		//"Inner"
		public Keyword getInnerKeyword_1() { return cInnerKeyword_1; }

		//"inner"
		public Keyword getInnerKeyword_2() { return cInnerKeyword_2; }
	}

	public class JOINElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "JOIN");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cJOINKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cJoinKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cJoinKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//JOIN returns ecore::EString:
		//	"JOIN" | "Join" | "join";
		public ParserRule getRule() { return rule; }

		//"JOIN" | "Join" | "join"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"JOIN"
		public Keyword getJOINKeyword_0() { return cJOINKeyword_0; }

		//"Join"
		public Keyword getJoinKeyword_1() { return cJoinKeyword_1; }

		//"join"
		public Keyword getJoinKeyword_2() { return cJoinKeyword_2; }
	}

	public class FETCHElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FETCH");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cFETCHKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFetchKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cFetchKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//FETCH returns ecore::EString:
		//	"FETCH" | "Fetch" | "fetch";
		public ParserRule getRule() { return rule; }

		//"FETCH" | "Fetch" | "fetch"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"FETCH"
		public Keyword getFETCHKeyword_0() { return cFETCHKeyword_0; }

		//"Fetch"
		public Keyword getFetchKeyword_1() { return cFetchKeyword_1; }

		//"fetch"
		public Keyword getFetchKeyword_2() { return cFetchKeyword_2; }
	}

	public class WITHElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WITH");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cWITHKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cWithKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cWithKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//WITH returns ecore::EString:
		//	"WITH" | "With" | "with";
		public ParserRule getRule() { return rule; }

		//"WITH" | "With" | "with"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"WITH"
		public Keyword getWITHKeyword_0() { return cWITHKeyword_0; }

		//"With"
		public Keyword getWithKeyword_1() { return cWithKeyword_1; }

		//"with"
		public Keyword getWithKeyword_2() { return cWithKeyword_2; }
	}

	public class INElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IN");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cINKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cInKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cInKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//IN returns ecore::EString:
		//	"IN" | "In" | "in";
		public ParserRule getRule() { return rule; }

		//"IN" | "In" | "in"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"IN"
		public Keyword getINKeyword_0() { return cINKeyword_0; }

		//"In"
		public Keyword getInKeyword_1() { return cInKeyword_1; }

		//"in"
		public Keyword getInKeyword_2() { return cInKeyword_2; }
	}

	public class CLASSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CLASS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cCLASSKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cClassKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cClassKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//CLASS returns ecore::EString:
		//	"CLASS" | "Class" | "class";
		public ParserRule getRule() { return rule; }

		//"CLASS" | "Class" | "class"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"CLASS"
		public Keyword getCLASSKeyword_0() { return cCLASSKeyword_0; }

		//"Class"
		public Keyword getClassKeyword_1() { return cClassKeyword_1; }

		//"class"
		public Keyword getClassKeyword_2() { return cClassKeyword_2; }
	}

	public class IN_CLASSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IN_CLASS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cINParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cCLASSParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//IN_CLASS returns ecore::EString:
		//	IN CLASS;
		public ParserRule getRule() { return rule; }

		//IN CLASS
		public Group getGroup() { return cGroup; }

		//IN
		public RuleCall getINParserRuleCall_0() { return cINParserRuleCall_0; }

		//CLASS
		public RuleCall getCLASSParserRuleCall_1() { return cCLASSParserRuleCall_1; }
	}

	public class ELEMENTSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ELEMENTS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cELEMENTSKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cElementsKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cElementsKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//ELEMENTS returns ecore::EString:
		//	"ELEMENTS" | "Elements" | "elements";
		public ParserRule getRule() { return rule; }

		//"ELEMENTS" | "Elements" | "elements"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"ELEMENTS"
		public Keyword getELEMENTSKeyword_0() { return cELEMENTSKeyword_0; }

		//"Elements"
		public Keyword getElementsKeyword_1() { return cElementsKeyword_1; }

		//"elements"
		public Keyword getElementsKeyword_2() { return cElementsKeyword_2; }
	}

	public class IN_ELEMENTSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IN_ELEMENTS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cINParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cELEMENTSParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//IN_ELEMENTS returns ecore::EString:
		//	IN ELEMENTS;
		public ParserRule getRule() { return rule; }

		//IN ELEMENTS
		public Group getGroup() { return cGroup; }

		//IN
		public RuleCall getINParserRuleCall_0() { return cINParserRuleCall_0; }

		//ELEMENTS
		public RuleCall getELEMENTSParserRuleCall_1() { return cELEMENTSParserRuleCall_1; }
	}

	public class ASElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cASKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cAsKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cAsKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//AS returns ecore::EString:
		//	"AS" | "As" | "as";
		public ParserRule getRule() { return rule; }

		//"AS" | "As" | "as"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"AS"
		public Keyword getASKeyword_0() { return cASKeyword_0; }

		//"As"
		public Keyword getAsKeyword_1() { return cAsKeyword_1; }

		//"as"
		public Keyword getAsKeyword_2() { return cAsKeyword_2; }
	}

	public class PROPERTIESElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PROPERTIES");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cPROPERTIESKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cPropertiesKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cPropertiesKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//PROPERTIES returns ecore::EString:
		//	"PROPERTIES" | "Properties" | "properties";
		public ParserRule getRule() { return rule; }

		//"PROPERTIES" | "Properties" | "properties"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"PROPERTIES"
		public Keyword getPROPERTIESKeyword_0() { return cPROPERTIESKeyword_0; }

		//"Properties"
		public Keyword getPropertiesKeyword_1() { return cPropertiesKeyword_1; }

		//"properties"
		public Keyword getPropertiesKeyword_2() { return cPropertiesKeyword_2; }
	}

	public class GROUP_BYElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GROUP_BY");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cGROUPKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cGroupKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Keyword cGroupKeyword_0_2 = (Keyword)cAlternatives_0.eContents().get(2);
		private final RuleCall cBYParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//GROUP_BY returns ecore::EString:
		//	("GROUP" | "Group" | "group") BY;
		public ParserRule getRule() { return rule; }

		//("GROUP" | "Group" | "group") BY
		public Group getGroup() { return cGroup; }

		//"GROUP" | "Group" | "group"
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"GROUP"
		public Keyword getGROUPKeyword_0_0() { return cGROUPKeyword_0_0; }

		//"Group"
		public Keyword getGroupKeyword_0_1() { return cGroupKeyword_0_1; }

		//"group"
		public Keyword getGroupKeyword_0_2() { return cGroupKeyword_0_2; }

		//BY
		public RuleCall getBYParserRuleCall_1() { return cBYParserRuleCall_1; }
	}

	public class ORDER_BYElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ORDER_BY");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cORDERKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cOrderKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Keyword cOrderKeyword_0_2 = (Keyword)cAlternatives_0.eContents().get(2);
		private final RuleCall cBYParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//ORDER_BY returns ecore::EString:
		//	("ORDER" | "Order" | "order") BY;
		public ParserRule getRule() { return rule; }

		//("ORDER" | "Order" | "order") BY
		public Group getGroup() { return cGroup; }

		//"ORDER" | "Order" | "order"
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"ORDER"
		public Keyword getORDERKeyword_0_0() { return cORDERKeyword_0_0; }

		//"Order"
		public Keyword getOrderKeyword_0_1() { return cOrderKeyword_0_1; }

		//"order"
		public Keyword getOrderKeyword_0_2() { return cOrderKeyword_0_2; }

		//BY
		public RuleCall getBYParserRuleCall_1() { return cBYParserRuleCall_1; }
	}

	public class BYElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BY");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cBYKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cByKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cByKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//BY returns ecore::EString:
		//	"BY" | "By" | "by";
		public ParserRule getRule() { return rule; }

		//"BY" | "By" | "by"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"BY"
		public Keyword getBYKeyword_0() { return cBYKeyword_0; }

		//"By"
		public Keyword getByKeyword_1() { return cByKeyword_1; }

		//"by"
		public Keyword getByKeyword_2() { return cByKeyword_2; }
	}

	public class ASCElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ASC");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cASCKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cAscKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cAscKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cASCENDINGKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cAscendingKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cAscendingKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		
		//ASC returns ecore::EString:
		//	"ASC" | "Asc" | "asc" | "ASCENDING" | "Ascending" | "ascending";
		public ParserRule getRule() { return rule; }

		//"ASC" | "Asc" | "asc" | "ASCENDING" | "Ascending" | "ascending"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"ASC"
		public Keyword getASCKeyword_0() { return cASCKeyword_0; }

		//"Asc"
		public Keyword getAscKeyword_1() { return cAscKeyword_1; }

		//"asc"
		public Keyword getAscKeyword_2() { return cAscKeyword_2; }

		//"ASCENDING"
		public Keyword getASCENDINGKeyword_3() { return cASCENDINGKeyword_3; }

		//"Ascending"
		public Keyword getAscendingKeyword_4() { return cAscendingKeyword_4; }

		//"ascending"
		public Keyword getAscendingKeyword_5() { return cAscendingKeyword_5; }
	}

	public class DESCElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DESC");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cDESCKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cDescKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cDescKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cDESCENDINGKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cDescendingKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cDescendingKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		
		//DESC returns ecore::EString:
		//	"DESC" | "Desc" | "desc" | "DESCENDING" | "Descending" | "descending";
		public ParserRule getRule() { return rule; }

		//"DESC" | "Desc" | "desc" | "DESCENDING" | "Descending" | "descending"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"DESC"
		public Keyword getDESCKeyword_0() { return cDESCKeyword_0; }

		//"Desc"
		public Keyword getDescKeyword_1() { return cDescKeyword_1; }

		//"desc"
		public Keyword getDescKeyword_2() { return cDescKeyword_2; }

		//"DESCENDING"
		public Keyword getDESCENDINGKeyword_3() { return cDESCENDINGKeyword_3; }

		//"Descending"
		public Keyword getDescendingKeyword_4() { return cDescendingKeyword_4; }

		//"descending"
		public Keyword getDescendingKeyword_5() { return cDescendingKeyword_5; }
	}

	public class HAVINGElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "HAVING");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cHAVINGKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cHavingKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cHavingKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//HAVING returns ecore::EString:
		//	"HAVING" | "Having" | "having";
		public ParserRule getRule() { return rule; }

		//"HAVING" | "Having" | "having"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"HAVING"
		public Keyword getHAVINGKeyword_0() { return cHAVINGKeyword_0; }

		//"Having"
		public Keyword getHavingKeyword_1() { return cHavingKeyword_1; }

		//"having"
		public Keyword getHavingKeyword_2() { return cHavingKeyword_2; }
	}

	public class WHEREElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WHERE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cWHEREKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cWhereKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cWhereKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//WHERE returns ecore::EString:
		//	"WHERE" | "Where" | "where";
		public ParserRule getRule() { return rule; }

		//"WHERE" | "Where" | "where"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"WHERE"
		public Keyword getWHEREKeyword_0() { return cWHEREKeyword_0; }

		//"Where"
		public Keyword getWhereKeyword_1() { return cWhereKeyword_1; }

		//"where"
		public Keyword getWhereKeyword_2() { return cWhereKeyword_2; }
	}

	public class ORElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OR");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cORKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cOrKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cOrKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//OR returns ecore::EString:
		//	"OR" | "Or" | "or";
		public ParserRule getRule() { return rule; }

		//"OR" | "Or" | "or"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"OR"
		public Keyword getORKeyword_0() { return cORKeyword_0; }

		//"Or"
		public Keyword getOrKeyword_1() { return cOrKeyword_1; }

		//"or"
		public Keyword getOrKeyword_2() { return cOrKeyword_2; }
	}

	public class ANDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AND");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cANDKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cAndKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cAndKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//AND returns ecore::EString:
		//	"AND" | "And" | "and";
		public ParserRule getRule() { return rule; }

		//"AND" | "And" | "and"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"AND"
		public Keyword getANDKeyword_0() { return cANDKeyword_0; }

		//"And"
		public Keyword getAndKeyword_1() { return cAndKeyword_1; }

		//"and"
		public Keyword getAndKeyword_2() { return cAndKeyword_2; }
	}

	public class NOTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NOT");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cNOTKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cNotKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cNotKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//NOT returns ecore::EString:
		//	"NOT" | "Not" | "not";
		public ParserRule getRule() { return rule; }

		//"NOT" | "Not" | "not"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"NOT"
		public Keyword getNOTKeyword_0() { return cNOTKeyword_0; }

		//"Not"
		public Keyword getNotKeyword_1() { return cNotKeyword_1; }

		//"not"
		public Keyword getNotKeyword_2() { return cNotKeyword_2; }
	}

	public class ISElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cISKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cIsKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cIsKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//IS returns ecore::EString:
		//	"IS" | "Is" | "is";
		public ParserRule getRule() { return rule; }

		//"IS" | "Is" | "is"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"IS"
		public Keyword getISKeyword_0() { return cISKeyword_0; }

		//"Is"
		public Keyword getIsKeyword_1() { return cIsKeyword_1; }

		//"is"
		public Keyword getIsKeyword_2() { return cIsKeyword_2; }
	}

	public class BETWEENElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BETWEEN");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cBETWEENKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cBetweenKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cBetweenKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//BETWEEN returns ecore::EString:
		//	"BETWEEN" | "Between" | "between";
		public ParserRule getRule() { return rule; }

		//"BETWEEN" | "Between" | "between"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"BETWEEN"
		public Keyword getBETWEENKeyword_0() { return cBETWEENKeyword_0; }

		//"Between"
		public Keyword getBetweenKeyword_1() { return cBetweenKeyword_1; }

		//"between"
		public Keyword getBetweenKeyword_2() { return cBetweenKeyword_2; }
	}

	public class LIKEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LIKE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cLIKEKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cLikeKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cLikeKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//LIKE returns ecore::EString:
		//	"LIKE" | "Like" | "like";
		public ParserRule getRule() { return rule; }

		//"LIKE" | "Like" | "like"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"LIKE"
		public Keyword getLIKEKeyword_0() { return cLIKEKeyword_0; }

		//"Like"
		public Keyword getLikeKeyword_1() { return cLikeKeyword_1; }

		//"like"
		public Keyword getLikeKeyword_2() { return cLikeKeyword_2; }
	}

	public class MEMBERElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MEMBER");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cMEMBERKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cMemberKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cMemberKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//MEMBER returns ecore::EString:
		//	"MEMBER" | "Member" | "member";
		public ParserRule getRule() { return rule; }

		//"MEMBER" | "Member" | "member"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"MEMBER"
		public Keyword getMEMBERKeyword_0() { return cMEMBERKeyword_0; }

		//"Member"
		public Keyword getMemberKeyword_1() { return cMemberKeyword_1; }

		//"member"
		public Keyword getMemberKeyword_2() { return cMemberKeyword_2; }
	}

	public class OFElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OF");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cOFKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cOfKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cOfKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//OF returns ecore::EString:
		//	"OF" | "Of" | "of";
		public ParserRule getRule() { return rule; }

		//"OF" | "Of" | "of"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"OF"
		public Keyword getOFKeyword_0() { return cOFKeyword_0; }

		//"Of"
		public Keyword getOfKeyword_1() { return cOfKeyword_1; }

		//"of"
		public Keyword getOfKeyword_2() { return cOfKeyword_2; }
	}

	public class ESCAPEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ESCAPE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cESCAPEKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cEscapeKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cEscapeKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//ESCAPE returns ecore::EString:
		//	"ESCAPE" | "Escape" | "escape";
		public ParserRule getRule() { return rule; }

		//"ESCAPE" | "Escape" | "escape"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"ESCAPE"
		public Keyword getESCAPEKeyword_0() { return cESCAPEKeyword_0; }

		//"Escape"
		public Keyword getEscapeKeyword_1() { return cEscapeKeyword_1; }

		//"escape"
		public Keyword getEscapeKeyword_2() { return cEscapeKeyword_2; }
	}

	public class CASEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CASE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cCASEKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cCaseKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cCaseKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//CASE returns ecore::EString:
		//	"CASE" | "Case" | "case";
		public ParserRule getRule() { return rule; }

		//"CASE" | "Case" | "case"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"CASE"
		public Keyword getCASEKeyword_0() { return cCASEKeyword_0; }

		//"Case"
		public Keyword getCaseKeyword_1() { return cCaseKeyword_1; }

		//"case"
		public Keyword getCaseKeyword_2() { return cCaseKeyword_2; }
	}

	public class ENDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "END");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cENDKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cEndKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cEndKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//END returns ecore::EString:
		//	"END" | "End" | "end";
		public ParserRule getRule() { return rule; }

		//"END" | "End" | "end"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"END"
		public Keyword getENDKeyword_0() { return cENDKeyword_0; }

		//"End"
		public Keyword getEndKeyword_1() { return cEndKeyword_1; }

		//"end"
		public Keyword getEndKeyword_2() { return cEndKeyword_2; }
	}

	public class WHENElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WHEN");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cWHENKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cWhenKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cWhenKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//WHEN returns ecore::EString:
		//	"WHEN" | "When" | "when";
		public ParserRule getRule() { return rule; }

		//"WHEN" | "When" | "when"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"WHEN"
		public Keyword getWHENKeyword_0() { return cWHENKeyword_0; }

		//"When"
		public Keyword getWhenKeyword_1() { return cWhenKeyword_1; }

		//"when"
		public Keyword getWhenKeyword_2() { return cWhenKeyword_2; }
	}

	public class THENElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "THEN");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTHENKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cThenKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cThenKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//THEN returns ecore::EString:
		//	"THEN" | "Then" | "then";
		public ParserRule getRule() { return rule; }

		//"THEN" | "Then" | "then"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"THEN"
		public Keyword getTHENKeyword_0() { return cTHENKeyword_0; }

		//"Then"
		public Keyword getThenKeyword_1() { return cThenKeyword_1; }

		//"then"
		public Keyword getThenKeyword_2() { return cThenKeyword_2; }
	}

	public class ELSEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ELSE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cELSEKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cElseKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cElseKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//ELSE returns ecore::EString:
		//	"ELSE" | "Else" | "else";
		public ParserRule getRule() { return rule; }

		//"ELSE" | "Else" | "else"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"ELSE"
		public Keyword getELSEKeyword_0() { return cELSEKeyword_0; }

		//"Else"
		public Keyword getElseKeyword_1() { return cElseKeyword_1; }

		//"else"
		public Keyword getElseKeyword_2() { return cElseKeyword_2; }
	}

	public class SOMEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SOME");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cSOMEKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cSomeKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cSomeKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//SOME returns ecore::EString:
		//	"SOME" | "Some" | "some";
		public ParserRule getRule() { return rule; }

		//"SOME" | "Some" | "some"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"SOME"
		public Keyword getSOMEKeyword_0() { return cSOMEKeyword_0; }

		//"Some"
		public Keyword getSomeKeyword_1() { return cSomeKeyword_1; }

		//"some"
		public Keyword getSomeKeyword_2() { return cSomeKeyword_2; }
	}

	public class EXISTSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EXISTS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cEXISTSKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cExistsKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cExistsKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//EXISTS returns ecore::EString:
		//	"EXISTS" | "Exists" | "exists";
		public ParserRule getRule() { return rule; }

		//"EXISTS" | "Exists" | "exists"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"EXISTS"
		public Keyword getEXISTSKeyword_0() { return cEXISTSKeyword_0; }

		//"Exists"
		public Keyword getExistsKeyword_1() { return cExistsKeyword_1; }

		//"exists"
		public Keyword getExistsKeyword_2() { return cExistsKeyword_2; }
	}

	public class ALLElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ALL");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cALLKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cAllKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cAllKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//ALL returns ecore::EString:
		//	"ALL" | "All" | "all";
		public ParserRule getRule() { return rule; }

		//"ALL" | "All" | "all"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"ALL"
		public Keyword getALLKeyword_0() { return cALLKeyword_0; }

		//"All"
		public Keyword getAllKeyword_1() { return cAllKeyword_1; }

		//"all"
		public Keyword getAllKeyword_2() { return cAllKeyword_2; }
	}

	public class ANYElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ANY");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cANYKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cAnyKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cAnyKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//ANY returns ecore::EString:
		//	"ANY" | "Any" | "any";
		public ParserRule getRule() { return rule; }

		//"ANY" | "Any" | "any"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"ANY"
		public Keyword getANYKeyword_0() { return cANYKeyword_0; }

		//"Any"
		public Keyword getAnyKeyword_1() { return cAnyKeyword_1; }

		//"any"
		public Keyword getAnyKeyword_2() { return cAnyKeyword_2; }
	}

	public class SUMElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SUM");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cSUMKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cSumKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cSumKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//SUM returns ecore::EString:
		//	"SUM" | "Sum" | "sum";
		public ParserRule getRule() { return rule; }

		//"SUM" | "Sum" | "sum"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"SUM"
		public Keyword getSUMKeyword_0() { return cSUMKeyword_0; }

		//"Sum"
		public Keyword getSumKeyword_1() { return cSumKeyword_1; }

		//"sum"
		public Keyword getSumKeyword_2() { return cSumKeyword_2; }
	}

	public class AVGElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AVG");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAVGKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cAvgKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cAvgKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//AVG returns ecore::EString:
		//	"AVG" | "Avg" | "avg";
		public ParserRule getRule() { return rule; }

		//"AVG" | "Avg" | "avg"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"AVG"
		public Keyword getAVGKeyword_0() { return cAVGKeyword_0; }

		//"Avg"
		public Keyword getAvgKeyword_1() { return cAvgKeyword_1; }

		//"avg"
		public Keyword getAvgKeyword_2() { return cAvgKeyword_2; }
	}

	public class MAXElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MAX");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cMAXKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cMaxKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cMaxKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//MAX returns ecore::EString:
		//	"MAX" | "Max" | "max";
		public ParserRule getRule() { return rule; }

		//"MAX" | "Max" | "max"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"MAX"
		public Keyword getMAXKeyword_0() { return cMAXKeyword_0; }

		//"Max"
		public Keyword getMaxKeyword_1() { return cMaxKeyword_1; }

		//"max"
		public Keyword getMaxKeyword_2() { return cMaxKeyword_2; }
	}

	public class MINElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MIN");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cMINKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cMinKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cMinKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//MIN returns ecore::EString:
		//	"MIN" | "Min" | "min";
		public ParserRule getRule() { return rule; }

		//"MIN" | "Min" | "min"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"MIN"
		public Keyword getMINKeyword_0() { return cMINKeyword_0; }

		//"Min"
		public Keyword getMinKeyword_1() { return cMinKeyword_1; }

		//"min"
		public Keyword getMinKeyword_2() { return cMinKeyword_2; }
	}

	public class COUNTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "COUNT");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cCOUNTKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cCountKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cCountKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//COUNT returns ecore::EString:
		//	"COUNT" | "Count" | "count";
		public ParserRule getRule() { return rule; }

		//"COUNT" | "Count" | "count"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"COUNT"
		public Keyword getCOUNTKeyword_0() { return cCOUNTKeyword_0; }

		//"Count"
		public Keyword getCountKeyword_1() { return cCountKeyword_1; }

		//"count"
		public Keyword getCountKeyword_2() { return cCountKeyword_2; }
	}

	public class INDICESElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "INDICES");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cINDICESKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cIndicesKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cIndicesKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//INDICES returns ecore::EString:
		//	"INDICES" | "Indices" | "indices";
		public ParserRule getRule() { return rule; }

		//"INDICES" | "Indices" | "indices"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"INDICES"
		public Keyword getINDICESKeyword_0() { return cINDICESKeyword_0; }

		//"Indices"
		public Keyword getIndicesKeyword_1() { return cIndicesKeyword_1; }

		//"indices"
		public Keyword getIndicesKeyword_2() { return cIndicesKeyword_2; }
	}

	public class TRAILINGElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TRAILING");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTRAILINGKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cTrailingKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cTrailingKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//TRAILING returns ecore::EString:
		//	"TRAILING" | "Trailing" | "trailing";
		public ParserRule getRule() { return rule; }

		//"TRAILING" | "Trailing" | "trailing"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"TRAILING"
		public Keyword getTRAILINGKeyword_0() { return cTRAILINGKeyword_0; }

		//"Trailing"
		public Keyword getTrailingKeyword_1() { return cTrailingKeyword_1; }

		//"trailing"
		public Keyword getTrailingKeyword_2() { return cTrailingKeyword_2; }
	}

	public class LEADINGElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LEADING");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cLEADINGKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cLeadingKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cLeadingKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//LEADING returns ecore::EString:
		//	"LEADING" | "Leading" | "leading";
		public ParserRule getRule() { return rule; }

		//"LEADING" | "Leading" | "leading"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"LEADING"
		public Keyword getLEADINGKeyword_0() { return cLEADINGKeyword_0; }

		//"Leading"
		public Keyword getLeadingKeyword_1() { return cLeadingKeyword_1; }

		//"leading"
		public Keyword getLeadingKeyword_2() { return cLeadingKeyword_2; }
	}

	public class BOTHElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BOTH");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cBOTHKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cBothKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cBothKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//BOTH returns ecore::EString:
		//	"BOTH" | "Both" | "both";
		public ParserRule getRule() { return rule; }

		//"BOTH" | "Both" | "both"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"BOTH"
		public Keyword getBOTHKeyword_0() { return cBOTHKeyword_0; }

		//"Both"
		public Keyword getBothKeyword_1() { return cBothKeyword_1; }

		//"both"
		public Keyword getBothKeyword_2() { return cBothKeyword_2; }
	}

	public class NULLElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NULL");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cNULLKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cNullKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cNullKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//NULL returns ecore::EString:
		//	"NULL" | "Null" | "null";
		public ParserRule getRule() { return rule; }

		//"NULL" | "Null" | "null"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"NULL"
		public Keyword getNULLKeyword_0() { return cNULLKeyword_0; }

		//"Null"
		public Keyword getNullKeyword_1() { return cNullKeyword_1; }

		//"null"
		public Keyword getNullKeyword_2() { return cNullKeyword_2; }
	}

	public class TRUEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TRUE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTRUEKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cTrueKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cTrueKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//TRUE returns ecore::EString:
		//	"TRUE" | "True" | "true";
		public ParserRule getRule() { return rule; }

		//"TRUE" | "True" | "true"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"TRUE"
		public Keyword getTRUEKeyword_0() { return cTRUEKeyword_0; }

		//"True"
		public Keyword getTrueKeyword_1() { return cTrueKeyword_1; }

		//"true"
		public Keyword getTrueKeyword_2() { return cTrueKeyword_2; }
	}

	public class FALSEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FALSE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cFALSEKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFalseKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cFalseKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//FALSE returns ecore::EString:
		//	"FALSE" | "False" | "false";
		public ParserRule getRule() { return rule; }

		//"FALSE" | "False" | "false"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"FALSE"
		public Keyword getFALSEKeyword_0() { return cFALSEKeyword_0; }

		//"False"
		public Keyword getFalseKeyword_1() { return cFalseKeyword_1; }

		//"false"
		public Keyword getFalseKeyword_2() { return cFalseKeyword_2; }
	}

	public class EMPTYElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EMPTY");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cEMPTYKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cEmptyKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cEmptyKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//EMPTY returns ecore::EString:
		//	"EMPTY" | "Empty" | "empty";
		public ParserRule getRule() { return rule; }

		//"EMPTY" | "Empty" | "empty"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"EMPTY"
		public Keyword getEMPTYKeyword_0() { return cEMPTYKeyword_0; }

		//"Empty"
		public Keyword getEmptyKeyword_1() { return cEmptyKeyword_1; }

		//"empty"
		public Keyword getEmptyKeyword_2() { return cEmptyKeyword_2; }
	}

	public class IdOrKeywordElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IdOrKeyword");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cKeywordParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// END HQL stuff
		//IdOrKeyword returns ecore::EString:
		//	ID | Keyword;
		public ParserRule getRule() { return rule; }

		//ID | Keyword
		public Alternatives getAlternatives() { return cAlternatives; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//Keyword
		public RuleCall getKeywordParserRuleCall_1() { return cKeywordParserRuleCall_1; }
	}

	public class KeywordElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Keyword");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAllKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cLengthKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cCharKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cTypeKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cFileKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cTextKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cTitleKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cMaxKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cWhenKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cMemberKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cEndKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cObjectKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cDateKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cThenKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		
		////keywords that can be used as names of fields or functions	
		//Keyword returns ecore::EString:
		//	"all" | "length" | "char" | "type" | "file" | "text" | //MDD keywords
		//	"title" | "max" | "when" | "member" | "end" | "object" | "date" | //HQL keywords
		//	"then";
		public ParserRule getRule() { return rule; }

		//"all" | "length" | "char" | "type" | "file" | "text" | //MDD keywords
		//"title" | "max" | "when" | "member" | "end" | "object" | "date" | //HQL keywords
		//"then"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"all"
		public Keyword getAllKeyword_0() { return cAllKeyword_0; }

		//"length"
		public Keyword getLengthKeyword_1() { return cLengthKeyword_1; }

		//"char"
		public Keyword getCharKeyword_2() { return cCharKeyword_2; }

		//"type"
		public Keyword getTypeKeyword_3() { return cTypeKeyword_3; }

		//"file"
		public Keyword getFileKeyword_4() { return cFileKeyword_4; }

		//"text"
		public Keyword getTextKeyword_5() { return cTextKeyword_5; }

		////MDD keywords
		//"title"
		public Keyword getTitleKeyword_6() { return cTitleKeyword_6; }

		//"max"
		public Keyword getMaxKeyword_7() { return cMaxKeyword_7; }

		//"when"
		public Keyword getWhenKeyword_8() { return cWhenKeyword_8; }

		//"member"
		public Keyword getMemberKeyword_9() { return cMemberKeyword_9; }

		//"end"
		public Keyword getEndKeyword_10() { return cEndKeyword_10; }

		//"object"
		public Keyword getObjectKeyword_11() { return cObjectKeyword_11; }

		//"date"
		public Keyword getDateKeyword_12() { return cDateKeyword_12; }

		////HQL keywords
		//"then"
		public Keyword getThenKeyword_13() { return cThenKeyword_13; }
	}
	
	
	private DataDefinitionElements pDataDefinition;
	private DeclarationElements pDeclaration;
	private FieldDeclarationElements pFieldDeclaration;
	private ModifiersElements pModifiers;
	private FieldTypeElements pFieldType;
	private IntEnumElements pIntEnum;
	private CharEnumElements pCharEnum;
	private EnumValueElements pEnumValue;
	private CharTypeElements pCharType;
	private PointerTypeElements pPointerType;
	private SetTypeElements pSetType;
	private SubFieldDeclarationElements pSubFieldDeclaration;
	private TypeElements pType;
	private TitleDeclarationElements pTitleDeclaration;
	private IncludeDeclarationElements pIncludeDeclaration;
	private TypeDeclarationElements pTypeDeclaration;
	private ValidationRuleDeclarationElements pValidationRuleDeclaration;
	private ComparisonValidationRuleDeclarationElements pComparisonValidationRuleDeclaration;
	private ComparisonExpressionElements pComparisonExpression;
	private ComparisonPartElements pComparisonPart;
	private UpperFunctionElements pUpperFunction;
	private LowerFunctionElements pLowerFunction;
	private OperatorElements pOperator;
	private DateConstantElements pDateConstant;
	private DateFunctionElements pDateFunction;
	private DateFunctionArgumentElements pDateFunctionArgument;
	private DateFunctionArgumentMemberElements pDateFunctionArgumentMember;
	private RangeValidationRuleDeclarationElements pRangeValidationRuleDeclaration;
	private RegexValidationRuleDeclarationElements pRegexValidationRuleDeclaration;
	private REGEXElements pREGEX;
	private RangeElements pRange;
	private RangeBoundElements pRangeBound;
	private UniquenessValidationRuleDeclarationElements pUniquenessValidationRuleDeclaration;
	private ErrorMessageElements pErrorMessage;
	private NativeValidationRuleDeclarationElements pNativeValidationRuleDeclaration;
	private FunctionDeclarationElements pFunctionDeclaration;
	private FunctionArgumentDeclarationElements pFunctionArgumentDeclaration;
	private FunctionArgumentBodyElements pFunctionArgumentBody;
	private FunctionCallElements pFunctionCall;
	private FieldPathElements pFieldPath;
	private FieldReferenceElements pFieldReference;
	private FunctionArgumentsElements pFunctionArguments;
	private FunctionBodyElements pFunctionBody;
	private StatementElements pStatement;
	private UnionRuleElements pUnionRule;
	private QueryRuleElements pQueryRule;
	private SelectFromElements pSelectFrom;
	private SelectClauseElements pSelectClause;
	private NewExpressionElements pNewExpression;
	private SelectObjectElements pSelectObject;
	private FromClauseElements pFromClause;
	private FromJoinElements pFromJoin;
	private WithClauseElements pWithClause;
	private FromRangeElements pFromRange;
	private FromClassOrOuterQueryPathElements pFromClassOrOuterQueryPath;
	private InCollectionElementsDeclarationElements pInCollectionElementsDeclaration;
	private PropertyFetchElements pPropertyFetch;
	private GroupByClauseElements pGroupByClause;
	private OrderByClauseElements pOrderByClause;
	private OrderElementElements pOrderElement;
	private AscendingOrDescendingElements pAscendingOrDescending;
	private HavingClauseElements pHavingClause;
	private WhereClauseElements pWhereClause;
	private SelectedPropertiesListElements pSelectedPropertiesList;
	private AliasedExpressionElements pAliasedExpression;
	private ExpressionElements pExpression;
	private LogicalOrExpressionElements pLogicalOrExpression;
	private LogicalAndExpressionElements pLogicalAndExpression;
	private NegatedExpressionElements pNegatedExpression;
	private EqualityExpressionElements pEqualityExpression;
	private RelationalExpressionElements pRelationalExpression;
	private LikeEscapeElements pLikeEscape;
	private BetweenListElements pBetweenList;
	private ConcatenationElements pConcatenation;
	private AdditiveExpressionElements pAdditiveExpression;
	private MultiplyExpressionElements pMultiplyExpression;
	private UnaryExpressionElements pUnaryExpression;
	private CaseExpressionElements pCaseExpression;
	private WhenClauseElements pWhenClause;
	private AltWhenClauseElements pAltWhenClause;
	private ElseClauseElements pElseClause;
	private QuantifiedExpressionElements pQuantifiedExpression;
	private AtomElements pAtom;
	private PrimaryExpressionElements pPrimaryExpression;
	private ExpressionOrVectorElements pExpressionOrVector;
	private VectorExprElements pVectorExpr;
	private IdentPrimaryElements pIdentPrimary;
	private AggregateElements pAggregate;
	private CollectionExprElements pCollectionExpr;
	private CompoundExprElements pCompoundExpr;
	private ExprListElements pExprList;
	private ConstantElements pConstant;
	private PathElements pPath;
	private IdentifierElements pIdentifier;
	private NumberElements pNumber;
	private SELECTElements pSELECT;
	private DISTINCTElements pDISTINCT;
	private NEWElements pNEW;
	private OBJECTElements pOBJECT;
	private FROMElements pFROM;
	private LEFTElements pLEFT;
	private RIGHTElements pRIGHT;
	private OUTERElements pOUTER;
	private FULLElements pFULL;
	private INNERElements pINNER;
	private JOINElements pJOIN;
	private FETCHElements pFETCH;
	private WITHElements pWITH;
	private INElements pIN;
	private CLASSElements pCLASS;
	private IN_CLASSElements pIN_CLASS;
	private ELEMENTSElements pELEMENTS;
	private IN_ELEMENTSElements pIN_ELEMENTS;
	private ASElements pAS;
	private PROPERTIESElements pPROPERTIES;
	private GROUP_BYElements pGROUP_BY;
	private ORDER_BYElements pORDER_BY;
	private BYElements pBY;
	private ASCElements pASC;
	private DESCElements pDESC;
	private HAVINGElements pHAVING;
	private WHEREElements pWHERE;
	private ORElements pOR;
	private ANDElements pAND;
	private NOTElements pNOT;
	private ISElements pIS;
	private BETWEENElements pBETWEEN;
	private LIKEElements pLIKE;
	private MEMBERElements pMEMBER;
	private OFElements pOF;
	private ESCAPEElements pESCAPE;
	private CASEElements pCASE;
	private ENDElements pEND;
	private WHENElements pWHEN;
	private THENElements pTHEN;
	private ELSEElements pELSE;
	private SOMEElements pSOME;
	private EXISTSElements pEXISTS;
	private ALLElements pALL;
	private ANYElements pANY;
	private SUMElements pSUM;
	private AVGElements pAVG;
	private MAXElements pMAX;
	private MINElements pMIN;
	private COUNTElements pCOUNT;
	private INDICESElements pINDICES;
	private TRAILINGElements pTRAILING;
	private LEADINGElements pLEADING;
	private BOTHElements pBOTH;
	private NULLElements pNULL;
	private TRUEElements pTRUE;
	private FALSEElements pFALSE;
	private EMPTYElements pEMPTY;
	private IdOrKeywordElements pIdOrKeyword;
	private KeywordElements pKeyword;
	private TerminalRule tLINEBREAK;
	private TerminalRule tID;
	private TerminalRule tSIGNED_INT;
	private TerminalRule tHEX;
	private TerminalRule tINT;
	private TerminalRule tFIELDCOMMENT;
	private TerminalRule tSL_COMMENT;
	private TerminalRule tWS;
	private TerminalRule tSTRING;
	
	private final GrammarProvider grammarProvider;

	@Inject
	public MDDGrammarAccess(GrammarProvider grammarProvider) {
		this.grammarProvider = grammarProvider;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	
	//DataDefinition:
	//	LINEBREAK* d+=Declaration? (LINEBREAK+ d+=Declaration)* LINEBREAK*;
	public DataDefinitionElements getDataDefinitionAccess() {
		return (pDataDefinition != null) ? pDataDefinition : (pDataDefinition = new DataDefinitionElements());
	}
	
	public ParserRule getDataDefinitionRule() {
		return getDataDefinitionAccess().getRule();
	}

	//Declaration:
	//	(FieldDeclaration | TitleDeclaration | TypeDeclaration | IncludeDeclaration | ValidationRuleDeclaration |
	//	FunctionDeclaration | NativeValidationRuleDeclaration | SubFieldDeclaration) fieldComment=FIELDCOMMENT?;
	public DeclarationElements getDeclarationAccess() {
		return (pDeclaration != null) ? pDeclaration : (pDeclaration = new DeclarationElements());
	}
	
	public ParserRule getDeclarationRule() {
		return getDeclarationAccess().getRule();
	}

	/// *extendedDeclaration:
	//	Declaration |
	//	 FIELDCOMMENT? LINEBREAK*;* //////// Field Declaration 
	//FieldDeclaration:
	//	name=IdOrKeyword "=" (modifiers=Modifiers typedef=FieldType)?;
	public FieldDeclarationElements getFieldDeclarationAccess() {
		return (pFieldDeclaration != null) ? pFieldDeclaration : (pFieldDeclaration = new FieldDeclarationElements());
	}
	
	public ParserRule getFieldDeclarationRule() {
		return getFieldDeclarationAccess().getRule();
	}

	//Modifiers:
	//	unique?="unique"? & fixed?="fixed"? & (notNull?="not" "null")? & (notEmpty?="not" "empty")?;
	public ModifiersElements getModifiersAccess() {
		return (pModifiers != null) ? pModifiers : (pModifiers = new ModifiersElements());
	}
	
	public ParserRule getModifiersRule() {
		return getModifiersAccess().getRule();
	}

	//FieldType:
	//	CharType | CharEnum | "set" CharEnum | IntEnum | "set" IntEnum | {FieldType} type=("int" | "real" | "boolean" | "text"
	//	| "binary" | "file" | "date") | PointerType | SetType | typeDec=[TypeDeclaration];
	public FieldTypeElements getFieldTypeAccess() {
		return (pFieldType != null) ? pFieldType : (pFieldType = new FieldTypeElements());
	}
	
	public ParserRule getFieldTypeRule() {
		return getFieldTypeAccess().getRule();
	}

	//IntEnum:
	//	name="int" "{" values+=EnumValue ("," values+=EnumValue)* "}";
	public IntEnumElements getIntEnumAccess() {
		return (pIntEnum != null) ? pIntEnum : (pIntEnum = new IntEnumElements());
	}
	
	public ParserRule getIntEnumRule() {
		return getIntEnumAccess().getRule();
	}

	//CharEnum:
	//	name="char" "{" values+=STRING ("," values+=STRING)* "}";
	public CharEnumElements getCharEnumAccess() {
		return (pCharEnum != null) ? pCharEnum : (pCharEnum = new CharEnumElements());
	}
	
	public ParserRule getCharEnumRule() {
		return getCharEnumAccess().getRule();
	}

	/// * New syntax to be introduced in mak 0.9
	//EnumType:
	//  'enum' ('{'  values+=EnumValue (',' values+=EnumValue)* '}'); 
	//
	//SetEnumType:
	//  'setEnum' ('{'  values+=EnumValue (',' values+=EnumValue)* '}');* /EnumValue:
	//	name=STRING "=" value=(INT | SIGNED_INT) decpricated?="deprecated"?;
	public EnumValueElements getEnumValueAccess() {
		return (pEnumValue != null) ? pEnumValue : (pEnumValue = new EnumValueElements());
	}
	
	public ParserRule getEnumValueRule() {
		return getEnumValueAccess().getRule();
	}

	//CharType:
	//	{CharType} "char" ("[" length=INT? "]")?;
	public CharTypeElements getCharTypeAccess() {
		return (pCharType != null) ? pCharType : (pCharType = new CharTypeElements());
	}
	
	public ParserRule getCharTypeRule() {
		return getCharTypeAccess().getRule();
	}

	//PointerType:
	//	{PointerType} "ptr" ref=[DataDefinition|Type]?;
	public PointerTypeElements getPointerTypeAccess() {
		return (pPointerType != null) ? pPointerType : (pPointerType = new PointerTypeElements());
	}
	
	public ParserRule getPointerTypeRule() {
		return getPointerTypeAccess().getRule();
	}

	//SetType:
	//	{SetType} "set" ref=[DataDefinition|Type]?;
	public SetTypeElements getSetTypeAccess() {
		return (pSetType != null) ? pSetType : (pSetType = new SetTypeElements());
	}
	
	public ParserRule getSetTypeRule() {
		return getSetTypeAccess().getRule();
	}

	//SubFieldDeclaration:
	//	subFieldOf=[FieldDeclaration] "->" d=Declaration;
	public SubFieldDeclarationElements getSubFieldDeclarationAccess() {
		return (pSubFieldDeclaration != null) ? pSubFieldDeclaration : (pSubFieldDeclaration = new SubFieldDeclarationElements());
	}
	
	public ParserRule getSubFieldDeclarationRule() {
		return getSubFieldDeclarationAccess().getRule();
	}

	//Type returns ecore::EString:
	//	IdOrKeyword ("." IdOrKeyword)*;
	public TypeElements getTypeAccess() {
		return (pType != null) ? pType : (pType = new TypeElements());
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}

	//// !title = field or function
	//TitleDeclaration:
	//	"!" "title" "=" (field=FieldPath | function=FunctionCall);
	public TitleDeclarationElements getTitleDeclarationAccess() {
		return (pTitleDeclaration != null) ? pTitleDeclaration : (pTitleDeclaration = new TitleDeclarationElements());
	}
	
	public ParserRule getTitleDeclarationRule() {
		return getTitleDeclarationAccess().getRule();
	}

	//// !include = general.Address
	//IncludeDeclaration:
	//	"!" "include" "=" importedNamespace=[DataDefinition|Type];
	public IncludeDeclarationElements getIncludeDeclarationAccess() {
		return (pIncludeDeclaration != null) ? pIncludeDeclaration : (pIncludeDeclaration = new IncludeDeclarationElements());
	}
	
	public ParserRule getIncludeDeclarationRule() {
		return getIncludeDeclarationAccess().getRule();
	}

	//// !type.genDef = ...
	//TypeDeclaration:
	//	"!" "type" "." name=ID "=" fieldType=FieldType;
	public TypeDeclarationElements getTypeDeclarationAccess() {
		return (pTypeDeclaration != null) ? pTypeDeclaration : (pTypeDeclaration = new TypeDeclarationElements());
	}
	
	public ParserRule getTypeDeclarationRule() {
		return getTypeDeclarationAccess().getRule();
	}

	/////// Validation Rules
	//ValidationRuleDeclaration:
	//	(RangeValidationRuleDeclaration | UniquenessValidationRuleDeclaration | ComparisonValidationRuleDeclaration |
	//	RegexValidationRuleDeclaration) errorMessage=ErrorMessage;
	public ValidationRuleDeclarationElements getValidationRuleDeclarationAccess() {
		return (pValidationRuleDeclaration != null) ? pValidationRuleDeclaration : (pValidationRuleDeclaration = new ValidationRuleDeclarationElements());
	}
	
	public ParserRule getValidationRuleDeclarationRule() {
		return getValidationRuleDeclarationAccess().getRule();
	}

	//ComparisonValidationRuleDeclaration:
	//	name="compare" args=FunctionArguments "{" comparisonExp=ComparisonExpression "}";
	public ComparisonValidationRuleDeclarationElements getComparisonValidationRuleDeclarationAccess() {
		return (pComparisonValidationRuleDeclaration != null) ? pComparisonValidationRuleDeclaration : (pComparisonValidationRuleDeclaration = new ComparisonValidationRuleDeclarationElements());
	}
	
	public ParserRule getComparisonValidationRuleDeclarationRule() {
		return getComparisonValidationRuleDeclarationAccess().getRule();
	}

	////////// COMPARISON EXPRESSION
	//ComparisonExpression:
	//	lhs=ComparisonPart o=Operator rhs=ComparisonPart;
	public ComparisonExpressionElements getComparisonExpressionAccess() {
		return (pComparisonExpression != null) ? pComparisonExpression : (pComparisonExpression = new ComparisonExpressionElements());
	}
	
	public ParserRule getComparisonExpressionRule() {
		return getComparisonExpressionAccess().getRule();
	}

	//ComparisonPart:
	//	field=FieldPath | n= //Number
	//	INT | df=DateFunction | u=UpperFunction | l=LowerFunction | d=DateConstant;
	public ComparisonPartElements getComparisonPartAccess() {
		return (pComparisonPart != null) ? pComparisonPart : (pComparisonPart = new ComparisonPartElements());
	}
	
	public ParserRule getComparisonPartRule() {
		return getComparisonPartAccess().getRule();
	}

	//// here we pass only the type name of the argument, with the function as type
	//UpperFunction:
	//	"upper" "(" field=FieldPath ")";
	public UpperFunctionElements getUpperFunctionAccess() {
		return (pUpperFunction != null) ? pUpperFunction : (pUpperFunction = new UpperFunctionElements());
	}
	
	public ParserRule getUpperFunctionRule() {
		return getUpperFunctionAccess().getRule();
	}

	//// here we pass only the type name of the argument, with the function as type
	//LowerFunction:
	//	"lower" "(" field=FieldPath ")";
	public LowerFunctionElements getLowerFunctionAccess() {
		return (pLowerFunction != null) ? pLowerFunction : (pLowerFunction = new LowerFunctionElements());
	}
	
	public ParserRule getLowerFunctionRule() {
		return getLowerFunctionAccess().getRule();
	}

	//Operator returns ecore::EString:
	//	"=" | "<" | ">" | "<=" | ">=" | "!=" | "^=" | "<>" | "like";
	public OperatorElements getOperatorAccess() {
		return (pOperator != null) ? pOperator : (pOperator = new OperatorElements());
	}
	
	public ParserRule getOperatorRule() {
		return getOperatorAccess().getRule();
	}

	//DateConstant returns ecore::EString:
	//	"$now" | "$today";
	public DateConstantElements getDateConstantAccess() {
		return (pDateConstant != null) ? pDateConstant : (pDateConstant = new DateConstantElements());
	}
	
	public ParserRule getDateConstantRule() {
		return getDateConstantAccess().getRule();
	}

	//DateFunction returns ecore::EString:
	//	"date" "(" DateFunctionArgument ("," DateFunctionArgument)* ")";
	public DateFunctionElements getDateFunctionAccess() {
		return (pDateFunction != null) ? pDateFunction : (pDateFunction = new DateFunctionElements());
	}
	
	public ParserRule getDateFunctionRule() {
		return getDateFunctionAccess().getRule();
	}

	//DateFunctionArgument returns ecore::EString:
	//	DateFunctionArgumentMember (("+" | "-") DateFunctionArgumentMember)?;
	public DateFunctionArgumentElements getDateFunctionArgumentAccess() {
		return (pDateFunctionArgument != null) ? pDateFunctionArgument : (pDateFunctionArgument = new DateFunctionArgumentElements());
	}
	
	public ParserRule getDateFunctionArgumentRule() {
		return getDateFunctionArgumentAccess().getRule();
	}

	//DateFunctionArgumentMember returns ecore::EString: //Number
	//	INT | DateConstant;
	public DateFunctionArgumentMemberElements getDateFunctionArgumentMemberAccess() {
		return (pDateFunctionArgumentMember != null) ? pDateFunctionArgumentMember : (pDateFunctionArgumentMember = new DateFunctionArgumentMemberElements());
	}
	
	public ParserRule getDateFunctionArgumentMemberRule() {
		return getDateFunctionArgumentMemberAccess().getRule();
	}

	////////// RANGE DEFINITION
	//RangeValidationRuleDeclaration:
	//	name=("range" | "length") "(" arg=FieldReference ")" "{" range=Range "}";
	public RangeValidationRuleDeclarationElements getRangeValidationRuleDeclarationAccess() {
		return (pRangeValidationRuleDeclaration != null) ? pRangeValidationRuleDeclaration : (pRangeValidationRuleDeclaration = new RangeValidationRuleDeclarationElements());
	}
	
	public ParserRule getRangeValidationRuleDeclarationRule() {
		return getRangeValidationRuleDeclarationAccess().getRule();
	}

	//RegexValidationRuleDeclaration:
	//	name="matches" "(" arg=FieldReference ")" "{" exp=REGEX "}";
	public RegexValidationRuleDeclarationElements getRegexValidationRuleDeclarationAccess() {
		return (pRegexValidationRuleDeclaration != null) ? pRegexValidationRuleDeclaration : (pRegexValidationRuleDeclaration = new RegexValidationRuleDeclarationElements());
	}
	
	public ParserRule getRegexValidationRuleDeclarationRule() {
		return getRegexValidationRuleDeclarationAccess().getRule();
	}

	//REGEX returns ecore::EString:
	//	STRING;
	public REGEXElements getREGEXAccess() {
		return (pREGEX != null) ? pREGEX : (pREGEX = new REGEXElements());
	}
	
	public ParserRule getREGEXRule() {
		return getREGEXAccess().getRule();
	}

	//// range(age) {18..99}  
	//Range:
	//	f=RangeBound ".." t=RangeBound;
	public RangeElements getRangeAccess() {
		return (pRange != null) ? pRange : (pRange = new RangeElements());
	}
	
	public ParserRule getRangeRule() {
		return getRangeAccess().getRule();
	}

	//// [1..?] [?..5]
	//RangeBound returns ecore::EString:
	//	INT | "?";
	public RangeBoundElements getRangeBoundAccess() {
		return (pRangeBound != null) ? pRangeBound : (pRangeBound = new RangeBoundElements());
	}
	
	public ParserRule getRangeBoundRule() {
		return getRangeBoundAccess().getRule();
	}

	//// unique(field1, field2) : "These need to be unique"
	//UniquenessValidationRuleDeclaration:
	//	name="unique" args=FunctionArguments;
	public UniquenessValidationRuleDeclarationElements getUniquenessValidationRuleDeclarationAccess() {
		return (pUniquenessValidationRuleDeclaration != null) ? pUniquenessValidationRuleDeclaration : (pUniquenessValidationRuleDeclaration = new UniquenessValidationRuleDeclarationElements());
	}
	
	public ParserRule getUniquenessValidationRuleDeclarationRule() {
		return getUniquenessValidationRuleDeclarationAccess().getRule();
	}

	//ErrorMessage:
	//	":" message=STRING;
	public ErrorMessageElements getErrorMessageAccess() {
		return (pErrorMessage != null) ? pErrorMessage : (pErrorMessage = new ErrorMessageElements());
	}
	
	public ParserRule getErrorMessageRule() {
		return getErrorMessageAccess().getRule();
	}

	//NativeValidationRuleDeclaration:
	//	field=[FieldDeclaration] "." type=("unique" | "notNull" | "NaN" | "notEmpty" | "notInt" | "notReal" | "notBoolean")
	//	"=" message=STRING;
	public NativeValidationRuleDeclarationElements getNativeValidationRuleDeclarationAccess() {
		return (pNativeValidationRuleDeclaration != null) ? pNativeValidationRuleDeclaration : (pNativeValidationRuleDeclaration = new NativeValidationRuleDeclarationElements());
	}
	
	public ParserRule getNativeValidationRuleDeclarationRule() {
		return getNativeValidationRuleDeclarationAccess().getRule();
	}

	/////// Functions
	//FunctionDeclaration:
	//	(b=ID "%")? name=ID arg=FunctionArgumentDeclaration body=FunctionBody m=ErrorMessage?;
	public FunctionDeclarationElements getFunctionDeclarationAccess() {
		return (pFunctionDeclaration != null) ? pFunctionDeclaration : (pFunctionDeclaration = new FunctionDeclarationElements());
	}
	
	public ParserRule getFunctionDeclarationRule() {
		return getFunctionDeclarationAccess().getRule();
	}

	//FunctionArgumentDeclaration:
	//	{FunctionArgumentDeclaration} "(" f+=FunctionArgumentBody? ("," f+=FunctionArgumentBody)* ")";
	public FunctionArgumentDeclarationElements getFunctionArgumentDeclarationAccess() {
		return (pFunctionArgumentDeclaration != null) ? pFunctionArgumentDeclaration : (pFunctionArgumentDeclaration = new FunctionArgumentDeclarationElements());
	}
	
	public ParserRule getFunctionArgumentDeclarationRule() {
		return getFunctionArgumentDeclarationAccess().getRule();
	}

	//// TODO: fix this so that function label can show param type instead of the name
	//// ugly fix until the syntax change
	////	FieldType arg=(ID|Keyword)
	//FunctionArgumentBody:
	//	(CharType | IntEnum | "set" IntEnum | CharEnum | "set" CharEnum | "int" | "real" | "boolean" | "text" | "binary" |
	//	"file" | "date" | "ptr" Type | "set" Type) name=IdOrKeyword;
	public FunctionArgumentBodyElements getFunctionArgumentBodyAccess() {
		return (pFunctionArgumentBody != null) ? pFunctionArgumentBody : (pFunctionArgumentBody = new FunctionArgumentBodyElements());
	}
	
	public ParserRule getFunctionArgumentBodyRule() {
		return getFunctionArgumentBodyAccess().getRule();
	}

	//FunctionCall:
	//	function=[FunctionDeclaration] f=FunctionArguments;
	public FunctionCallElements getFunctionCallAccess() {
		return (pFunctionCall != null) ? pFunctionCall : (pFunctionCall = new FunctionCallElements());
	}
	
	public ParserRule getFunctionCallRule() {
		return getFunctionCallAccess().getRule();
	}

	//FieldPath:
	//	field=[FieldDeclaration|IdOrKeyword] ("." subField=FieldPath)?;
	public FieldPathElements getFieldPathAccess() {
		return (pFieldPath != null) ? pFieldPath : (pFieldPath = new FieldPathElements());
	}
	
	public ParserRule getFieldPathRule() {
		return getFieldPathAccess().getRule();
	}

	//FieldReference:
	//	field=[FieldDeclaration|IdOrKeyword];
	public FieldReferenceElements getFieldReferenceAccess() {
		return (pFieldReference != null) ? pFieldReference : (pFieldReference = new FieldReferenceElements());
	}
	
	public ParserRule getFieldReferenceRule() {
		return getFieldReferenceAccess().getRule();
	}

	//FunctionArguments:
	//	{FunctionArguments} "(" (args+=FieldPath ("," args+=FieldPath)*)? ")";
	public FunctionArgumentsElements getFunctionArgumentsAccess() {
		return (pFunctionArguments != null) ? pFunctionArguments : (pFunctionArguments = new FunctionArgumentsElements());
	}
	
	public ParserRule getFunctionArgumentsRule() {
		return getFunctionArgumentsAccess().getRule();
	}

	//FunctionBody:
	//	"{" (s=Statement | e=Expression) "}";
	public FunctionBodyElements getFunctionBodyAccess() {
		return (pFunctionBody != null) ? pFunctionBody : (pFunctionBody = new FunctionBodyElements());
	}
	
	public ParserRule getFunctionBodyRule() {
		return getFunctionBodyAccess().getRule();
	}

	/////// HQL stuff
	//Statement:
	//	QueryRule;
	public StatementElements getStatementAccess() {
		return (pStatement != null) ? pStatement : (pStatement = new StatementElements());
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}

	//UnionRule:
	//	q+=QueryRule ("union" q+=QueryRule)*;
	public UnionRuleElements getUnionRuleAccess() {
		return (pUnionRule != null) ? pUnionRule : (pUnionRule = new UnionRuleElements());
	}
	
	public ParserRule getUnionRuleRule() {
		return getUnionRuleAccess().getRule();
	}

	////## query:
	////##     [SelectClause] FromClause [WhereClause] [GroupByClause] [HavingClause] [OrderByClause];
	//QueryRule:
	//	SelectFrom where=WhereClause? groupBy=GroupByClause? orderBy=OrderByClause?;
	public QueryRuleElements getQueryRuleAccess() {
		return (pQueryRule != null) ? pQueryRule : (pQueryRule = new QueryRuleElements());
	}
	
	public ParserRule getQueryRuleRule() {
		return getQueryRuleAccess().getRule();
	}

	//SelectFrom:
	//	{SelectFrom} s=SelectClause? from=FromClause?;
	public SelectFromElements getSelectFromAccess() {
		return (pSelectFrom != null) ? pSelectFrom : (pSelectFrom = new SelectFromElements());
	}
	
	public ParserRule getSelectFromRule() {
		return getSelectFromAccess().getRule();
	}

	////## SelectClause:
	////##     SELECT DISTINCT? SelectedPropertiesList | ( NEW className OPEN SelectedPropertiesList CLOSE );
	//SelectClause:
	//	{SelectClause} SELECT DISTINCT? (s=SelectedPropertiesList | n=NewExpression | SelectObject);
	public SelectClauseElements getSelectClauseAccess() {
		return (pSelectClause != null) ? pSelectClause : (pSelectClause = new SelectClauseElements());
	}
	
	public ParserRule getSelectClauseRule() {
		return getSelectClauseAccess().getRule();
	}

	//NewExpression:
	//	NEW p=Path "(" s=SelectedPropertiesList ")";
	public NewExpressionElements getNewExpressionAccess() {
		return (pNewExpression != null) ? pNewExpression : (pNewExpression = new NewExpressionElements());
	}
	
	public ParserRule getNewExpressionRule() {
		return getNewExpressionAccess().getRule();
	}

	//SelectObject returns ecore::EString:
	//	OBJECT "(" Identifier ")";
	public SelectObjectElements getSelectObjectAccess() {
		return (pSelectObject != null) ? pSelectObject : (pSelectObject = new SelectObjectElements());
	}
	
	public ParserRule getSelectObjectRule() {
		return getSelectObjectAccess().getRule();
	}

	////## FromClause:
	////##    FROM className AS? Identifier (  ( ',' className AS? Identifier ) | ( joinType Path AS? Identifier ) )*;
	//// NOTE: This *must* begin with the "FROM" token, otherwise the sub-query rule will be ambiguous
	//// with the expression rule.
	//// Also note: after a comma weak keywords are allowed and should be treated as identifiers.
	//FromClause:
	//	FROM fromRange+=FromRange (fromJoin+=FromJoin | "," fromRange+=FromRange)*;
	public FromClauseElements getFromClauseAccess() {
		return (pFromClause != null) ? pFromClause : (pFromClause = new FromClauseElements());
	}
	
	public ParserRule getFromClauseRule() {
		return getFromClauseAccess().getRule();
	}

	////## joinType:
	////##     ( ( 'left'|'right' 'outer'? ) | 'full' | 'inner' )? JOIN FETCH?;
	//FromJoin:
	//	((LEFT | RIGHT) OUTER? | FULL | INNER)? JOIN FETCH? FromClassOrOuterQueryPath w=WithClause?;
	public FromJoinElements getFromJoinAccess() {
		return (pFromJoin != null) ? pFromJoin : (pFromJoin = new FromJoinElements());
	}
	
	public ParserRule getFromJoinRule() {
		return getFromJoinAccess().getRule();
	}

	//WithClause:
	//	WITH e=Expression;
	public WithClauseElements getWithClauseAccess() {
		return (pWithClause != null) ? pWithClause : (pWithClause = new WithClauseElements());
	}
	
	public ParserRule getWithClauseRule() {
		return getWithClauseAccess().getRule();
	}

	//FromRange:
	//	FromClassOrOuterQueryPath | alias=Identifier IN_CLASS p=Path | IN "(" p=Path ")" alias=Identifier |
	//	InCollectionElementsDeclaration;
	public FromRangeElements getFromRangeAccess() {
		return (pFromRange != null) ? pFromRange : (pFromRange = new FromRangeElements());
	}
	
	public ParserRule getFromRangeRule() {
		return getFromRangeAccess().getRule();
	}

	//FromClassOrOuterQueryPath:
	//	{FromClassOrOuterQueryPath} path=Path (AS? name=Identifier)? propertyFetch=PropertyFetch?;
	public FromClassOrOuterQueryPathElements getFromClassOrOuterQueryPathAccess() {
		return (pFromClassOrOuterQueryPath != null) ? pFromClassOrOuterQueryPath : (pFromClassOrOuterQueryPath = new FromClassOrOuterQueryPathElements());
	}
	
	public ParserRule getFromClassOrOuterQueryPathRule() {
		return getFromClassOrOuterQueryPathAccess().getRule();
	}

	//InCollectionElementsDeclaration:
	//	alias=Identifier IN_ELEMENTS "(" p=Path ")";
	public InCollectionElementsDeclarationElements getInCollectionElementsDeclarationAccess() {
		return (pInCollectionElementsDeclaration != null) ? pInCollectionElementsDeclaration : (pInCollectionElementsDeclaration = new InCollectionElementsDeclarationElements());
	}
	
	public ParserRule getInCollectionElementsDeclarationRule() {
		return getInCollectionElementsDeclarationAccess().getRule();
	}

	//PropertyFetch returns ecore::EString:
	//	FETCH ALL PROPERTIES;
	public PropertyFetchElements getPropertyFetchAccess() {
		return (pPropertyFetch != null) ? pPropertyFetch : (pPropertyFetch = new PropertyFetchElements());
	}
	
	public ParserRule getPropertyFetchRule() {
		return getPropertyFetchAccess().getRule();
	}

	////## GroupByClause:
	////##     GROUP_BY Path ( ',' Path )*;
	//GroupByClause:
	//	GROUP_BY e+=Expression ("," e+=Expression)* h=HavingClause?;
	public GroupByClauseElements getGroupByClauseAccess() {
		return (pGroupByClause != null) ? pGroupByClause : (pGroupByClause = new GroupByClauseElements());
	}
	
	public ParserRule getGroupByClauseRule() {
		return getGroupByClauseAccess().getRule();
	}

	////## OrderByClause:
	////##     ORDER_BY SelectedPropertiesList;
	//OrderByClause:
	//	ORDER_BY o+=OrderElement ("," o+=OrderElement)*;
	public OrderByClauseElements getOrderByClauseAccess() {
		return (pOrderByClause != null) ? pOrderByClause : (pOrderByClause = new OrderByClauseElements());
	}
	
	public ParserRule getOrderByClauseRule() {
		return getOrderByClauseAccess().getRule();
	}

	//OrderElement:
	//	Expression AscendingOrDescending?;
	public OrderElementElements getOrderElementAccess() {
		return (pOrderElement != null) ? pOrderElement : (pOrderElement = new OrderElementElements());
	}
	
	public ParserRule getOrderElementRule() {
		return getOrderElementAccess().getRule();
	}

	//AscendingOrDescending returns ecore::EString:
	//	ASC | DESC;
	public AscendingOrDescendingElements getAscendingOrDescendingAccess() {
		return (pAscendingOrDescending != null) ? pAscendingOrDescending : (pAscendingOrDescending = new AscendingOrDescendingElements());
	}
	
	public ParserRule getAscendingOrDescendingRule() {
		return getAscendingOrDescendingAccess().getRule();
	}

	////## HavingClause:
	////##     HAVING logicalExpression;
	//HavingClause:
	//	HAVING e=Expression;
	public HavingClauseElements getHavingClauseAccess() {
		return (pHavingClause != null) ? pHavingClause : (pHavingClause = new HavingClauseElements());
	}
	
	public ParserRule getHavingClauseRule() {
		return getHavingClauseAccess().getRule();
	}

	////## WhereClause:
	////##     WHERE logicalExpression;
	//WhereClause:
	//	WHERE e=Expression;
	public WhereClauseElements getWhereClauseAccess() {
		return (pWhereClause != null) ? pWhereClause : (pWhereClause = new WhereClauseElements());
	}
	
	public ParserRule getWhereClauseRule() {
		return getWhereClauseAccess().getRule();
	}

	////## SelectedPropertiesList:
	////##     ( Path | Aggregate ) ( ',' Path | Aggregate )*;
	//SelectedPropertiesList:
	//	a+=AliasedExpression ("," a+=AliasedExpression)*;
	public SelectedPropertiesListElements getSelectedPropertiesListAccess() {
		return (pSelectedPropertiesList != null) ? pSelectedPropertiesList : (pSelectedPropertiesList = new SelectedPropertiesListElements());
	}
	
	public ParserRule getSelectedPropertiesListRule() {
		return getSelectedPropertiesListAccess().getRule();
	}

	//AliasedExpression:
	//	Expression (AS id=Identifier)?;
	public AliasedExpressionElements getAliasedExpressionAccess() {
		return (pAliasedExpression != null) ? pAliasedExpression : (pAliasedExpression = new AliasedExpressionElements());
	}
	
	public ParserRule getAliasedExpressionRule() {
		return getAliasedExpressionAccess().getRule();
	}

	//// expressions
	//// Note that most of these expressions follow the pattern
	////   thisLevelExpression :
	////       nextHigherPrecedenceExpression
	////           (OPERATOR nextHigherPrecedenceExpression)*
	//// which is a standard recursive definition for a parsing an expression.
	////
	//// Operator precedence in HQL
	//// lowest  --> ( 7)  OR
	////             ( 6)  AND, NOT
	////             ( 5)  equality: ==, <>, =, is
	////             ( 4)  relational: <, <=, >, >=,
	////                   LIKE, NOT LIKE, BETWEEN, NOT BETWEEN, IN, NOT IN
	////             ( 3)  addition and subtraction: +(binary) -(binary)
	////             ( 2)  multiplication: * / %, concatenate: ||
	//// highest --> ( 1)  +(unary) -(unary)
	////                   []   () (method call)  . (dot -- identifier qualification)
	////                   aggregate function
	////                   ()  (explicit parenthesis)
	////
	//// Note that the above precedence levels map to the rules below...
	//// Once you have a precedence chart, writing the appropriate rules as below
	//// is usually very straightfoward
	//// Main expression rule
	//Expression:
	//	LogicalOrExpression;
	public ExpressionElements getExpressionAccess() {
		return (pExpression != null) ? pExpression : (pExpression = new ExpressionElements());
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//// level 7 - OR
	//LogicalOrExpression:
	//	l+=LogicalAndExpression (OR l+=LogicalAndExpression)*;
	public LogicalOrExpressionElements getLogicalOrExpressionAccess() {
		return (pLogicalOrExpression != null) ? pLogicalOrExpression : (pLogicalOrExpression = new LogicalOrExpressionElements());
	}
	
	public ParserRule getLogicalOrExpressionRule() {
		return getLogicalOrExpressionAccess().getRule();
	}

	//// level 6 - AND, NOT
	//LogicalAndExpression:
	//	n+=NegatedExpression (AND n+=NegatedExpression)*;
	public LogicalAndExpressionElements getLogicalAndExpressionAccess() {
		return (pLogicalAndExpression != null) ? pLogicalAndExpression : (pLogicalAndExpression = new LogicalAndExpressionElements());
	}
	
	public ParserRule getLogicalAndExpressionRule() {
		return getLogicalAndExpressionAccess().getRule();
	}

	//// NOT nodes aren't generated.  Instead, the operator in the sub-tree will be
	//// negated, if possible.   Expressions without a NOT parent are passed through.
	//// Weak keywords can appear in an expression, so look ahead.
	//NegatedExpression:
	//	NOT n=NegatedExpression | EqualityExpression;
	public NegatedExpressionElements getNegatedExpressionAccess() {
		return (pNegatedExpression != null) ? pNegatedExpression : (pNegatedExpression = new NegatedExpressionElements());
	}
	
	public ParserRule getNegatedExpressionRule() {
		return getNegatedExpressionAccess().getRule();
	}

	////## OP: EQ | LT | GT | LE | GE | NE | SQL_NE | LIKE;
	//// level 5 - EQ, NE
	//EqualityExpression:
	//	r+=RelationalExpression (("=" | IS NOT? | "!=" | "<>") r+=RelationalExpression)*;
	public EqualityExpressionElements getEqualityExpressionAccess() {
		return (pEqualityExpression != null) ? pEqualityExpression : (pEqualityExpression = new EqualityExpressionElements());
	}
	
	public ParserRule getEqualityExpressionRule() {
		return getEqualityExpressionAccess().getRule();
	}

	//// level 4 - LT, GT, LE, GE, LIKE, NOT LIKE, BETWEEN, NOT BETWEEN
	//// NOTE: The NOT prefix for LIKE and BETWEEN will be represented in the
	//// token type.  When traversing the AST, use the token type, and not the
	//// token text to interpret the semantics of these nodes.
	//RelationalExpression:
	//	Concatenation ((("<" | ">" | "<=" | ">=") a+=AdditiveExpression)* // Disable node production for the optional 'not'.
	//	| NOT? (IN i=CompoundExpr // Represent the optional NOT prefix using the token type by
	//	// testing 'n' and setting the token type accordingly.
	//	| BETWEEN b=BetweenList | LIKE c=Concatenation l=LikeEscape | MEMBER OF? p=Path));
	public RelationalExpressionElements getRelationalExpressionAccess() {
		return (pRelationalExpression != null) ? pRelationalExpression : (pRelationalExpression = new RelationalExpressionElements());
	}
	
	public ParserRule getRelationalExpressionRule() {
		return getRelationalExpressionAccess().getRule();
	}

	//LikeEscape:
	//	{LikeEscape} (ESCAPE c=Concatenation)?;
	public LikeEscapeElements getLikeEscapeAccess() {
		return (pLikeEscape != null) ? pLikeEscape : (pLikeEscape = new LikeEscapeElements());
	}
	
	public ParserRule getLikeEscapeRule() {
		return getLikeEscapeAccess().getRule();
	}

	//BetweenList:
	//	c+=Concatenation AND c+=Concatenation;
	public BetweenListElements getBetweenListAccess() {
		return (pBetweenList != null) ? pBetweenList : (pBetweenList = new BetweenListElements());
	}
	
	public ParserRule getBetweenListRule() {
		return getBetweenListAccess().getRule();
	}

	////level 4 - string concatenation
	//Concatenation:
	//	AdditiveExpression ("||" a+=AdditiveExpression ("||" a+=AdditiveExpression)*)?;
	public ConcatenationElements getConcatenationAccess() {
		return (pConcatenation != null) ? pConcatenation : (pConcatenation = new ConcatenationElements());
	}
	
	public ParserRule getConcatenationRule() {
		return getConcatenationAccess().getRule();
	}

	//// level 3 - binary plus and minus
	//AdditiveExpression:
	//	m+=MultiplyExpression (("+" | "-") m+=MultiplyExpression)*;
	public AdditiveExpressionElements getAdditiveExpressionAccess() {
		return (pAdditiveExpression != null) ? pAdditiveExpression : (pAdditiveExpression = new AdditiveExpressionElements());
	}
	
	public ParserRule getAdditiveExpressionRule() {
		return getAdditiveExpressionAccess().getRule();
	}

	//// level 2 - binary multiply and divide
	//MultiplyExpression:
	//	u+=UnaryExpression (("*" | "/") u+=UnaryExpression)*;
	public MultiplyExpressionElements getMultiplyExpressionAccess() {
		return (pMultiplyExpression != null) ? pMultiplyExpression : (pMultiplyExpression = new MultiplyExpressionElements());
	}
	
	public ParserRule getMultiplyExpressionRule() {
		return getMultiplyExpressionAccess().getRule();
	}

	//// level 1 - unary minus, unary plus, not
	//UnaryExpression:
	//	"-" u=UnaryExpression | "+" u=UnaryExpression | CaseExpression | QuantifiedExpression | Atom;
	public UnaryExpressionElements getUnaryExpressionAccess() {
		return (pUnaryExpression != null) ? pUnaryExpression : (pUnaryExpression = new UnaryExpressionElements());
	}
	
	public ParserRule getUnaryExpressionRule() {
		return getUnaryExpressionAccess().getRule();
	}

	//CaseExpression:
	//	CASE w+=WhenClause+ e=ElseClause? END | CASE u=UnaryExpression a+=AltWhenClause+ e=ElseClause? END;
	public CaseExpressionElements getCaseExpressionAccess() {
		return (pCaseExpression != null) ? pCaseExpression : (pCaseExpression = new CaseExpressionElements());
	}
	
	public ParserRule getCaseExpressionRule() {
		return getCaseExpressionAccess().getRule();
	}

	//WhenClause:
	//	WHEN whenExpr=Expression THEN thenExpr=UnaryExpression;
	public WhenClauseElements getWhenClauseAccess() {
		return (pWhenClause != null) ? pWhenClause : (pWhenClause = new WhenClauseElements());
	}
	
	public ParserRule getWhenClauseRule() {
		return getWhenClauseAccess().getRule();
	}

	//AltWhenClause:
	//	WHEN w=UnaryExpression THEN t=UnaryExpression;
	public AltWhenClauseElements getAltWhenClauseAccess() {
		return (pAltWhenClause != null) ? pAltWhenClause : (pAltWhenClause = new AltWhenClauseElements());
	}
	
	public ParserRule getAltWhenClauseRule() {
		return getAltWhenClauseAccess().getRule();
	}

	//ElseClause:
	//	ELSE u=UnaryExpression;
	public ElseClauseElements getElseClauseAccess() {
		return (pElseClause != null) ? pElseClause : (pElseClause = new ElseClauseElements());
	}
	
	public ParserRule getElseClauseRule() {
		return getElseClauseAccess().getRule();
	}

	//QuantifiedExpression:
	//	{QuantifiedExpression} (SOME | EXISTS | ALL | ANY) (Identifier | CollectionExpr | "(" s=UnionRule ")");
	public QuantifiedExpressionElements getQuantifiedExpressionAccess() {
		return (pQuantifiedExpression != null) ? pQuantifiedExpression : (pQuantifiedExpression = new QuantifiedExpressionElements());
	}
	
	public ParserRule getQuantifiedExpressionRule() {
		return getQuantifiedExpressionAccess().getRule();
	}

	//// level 0 - expression atom
	//// ident qualifier ('.' ident ), array index ( [ expr ] ),
	//// method call ( '.' ident '(' ExprList ') )
	//Atom:
	//	{Atom} (prime=PrimaryExpression ("." Identifier ("(" e+=ExprList ")")? | "[" exp+=Expression "]")*);
	public AtomElements getAtomAccess() {
		return (pAtom != null) ? pAtom : (pAtom = new AtomElements());
	}
	
	public ParserRule getAtomRule() {
		return getAtomAccess().getRule();
	}

	//// level 0 - the basic element of an expression
	//PrimaryExpression:
	//	IdentPrimary ("." CLASS)? | Constant | ":" Identifier | "(" (ExpressionOrVector | UnionRule) ")" | "?" INT?;
	public PrimaryExpressionElements getPrimaryExpressionAccess() {
		return (pPrimaryExpression != null) ? pPrimaryExpression : (pPrimaryExpression = new PrimaryExpressionElements());
	}
	
	public ParserRule getPrimaryExpressionRule() {
		return getPrimaryExpressionAccess().getRule();
	}

	//// This parses normal expression and a list of expressions separated by commas.  If a comma is encountered
	//// a parent VECTOR_EXPR node will be created for the list.
	//ExpressionOrVector:
	//	Expression v=VectorExpr?;
	public ExpressionOrVectorElements getExpressionOrVectorAccess() {
		return (pExpressionOrVector != null) ? pExpressionOrVector : (pExpressionOrVector = new ExpressionOrVectorElements());
	}
	
	public ParserRule getExpressionOrVectorRule() {
		return getExpressionOrVectorAccess().getRule();
	}

	//VectorExpr:
	//	"," e+=Expression ("," e+=Expression)*;
	public VectorExprElements getVectorExprAccess() {
		return (pVectorExpr != null) ? pVectorExpr : (pVectorExpr = new VectorExprElements());
	}
	
	public ParserRule getVectorExprRule() {
		return getVectorExprAccess().getRule();
	}

	//// identifier, followed by member refs (dot ident), or method calls.
	//// NOTE: handleDotIdent() is called immediately after the first IDENT is recognized because
	//// the method looks a head to find keywords after '.' and turns them into identifiers.
	//IdentPrimary:
	//	{IdentPrimary} (Identifier ("." Identifier | "." ELEMENTS | "." OBJECT)* ("(" e=ExprList ")")?) | Aggregate;
	public IdentPrimaryElements getIdentPrimaryAccess() {
		return (pIdentPrimary != null) ? pIdentPrimary : (pIdentPrimary = new IdentPrimaryElements());
	}
	
	public ParserRule getIdentPrimaryRule() {
		return getIdentPrimaryAccess().getRule();
	}

	////## aggregate:
	////##     ( aggregateFunction OPEN Path CLOSE ) | ( COUNT OPEN '*' CLOSE ) | ( COUNT OPEN (DISTINCT | ALL) Path CLOSE );
	////## aggregateFunction:
	////##     COUNT | 'sum' | 'avg' | 'max' | 'min';
	//Aggregate:
	//	{Aggregate} (SUM | AVG | MAX | MIN) "(" a=AdditiveExpression ")" // Special case for count - It's 'parameters' can be keywords.
	//	| {Aggregate} COUNT "(" ("*" | (DISTINCT | ALL)? (Path | CollectionExpr)) ")" | CollectionExpr;
	public AggregateElements getAggregateAccess() {
		return (pAggregate != null) ? pAggregate : (pAggregate = new AggregateElements());
	}
	
	public ParserRule getAggregateRule() {
		return getAggregateAccess().getRule();
	}

	////## collection: ( OPEN query CLOSE ) | ( 'elements'|'indices' OPEN Path CLOSE );
	//CollectionExpr returns ecore::EString:
	//	(ELEMENTS | INDICES) "(" Path ")";
	public CollectionExprElements getCollectionExprAccess() {
		return (pCollectionExpr != null) ? pCollectionExpr : (pCollectionExpr = new CollectionExprElements());
	}
	
	public ParserRule getCollectionExprRule() {
		return getCollectionExprAccess().getRule();
	}

	//// NOTE: CompoundExpr can be a 'Path' where the last token in the path is '.elements' or '.indicies'
	//CompoundExpr:
	//	CollectionExpr | Path | "(" (e+=Expression ("," e+=Expression)* | s=UnionRule) ")";
	public CompoundExprElements getCompoundExprAccess() {
		return (pCompoundExpr != null) ? pCompoundExpr : (pCompoundExpr = new CompoundExprElements());
	}
	
	public ParserRule getCompoundExprRule() {
		return getCompoundExprAccess().getRule();
	}

	//ExprList:
	//	(TRAILING | LEADING | BOTH)? (e+=Expression (("," e+=Expression)+ | FROM e+=Expression | AS id=Identifier)? | FROM
	//	e+=Expression)?;
	public ExprListElements getExprListAccess() {
		return (pExprList != null) ? pExprList : (pExprList = new ExprListElements());
	}
	
	public ParserRule getExprListRule() {
		return getExprListAccess().getRule();
	}

	//Constant returns ecore::EString:
	//	Number | STRING | NULL | TRUE | FALSE | EMPTY;
	public ConstantElements getConstantAccess() {
		return (pConstant != null) ? pConstant : (pConstant = new ConstantElements());
	}
	
	public ParserRule getConstantRule() {
		return getConstantAccess().getRule();
	}

	////## QuantifiedExpression: 'exists' | ( expression 'in' ) | ( Expression OP 'any' | 'some' ) collection;
	////## compoundPath: Path ( OPEN_BRACKET Expression CLOSE_BRACKET ( '.' Path )? )*;
	////## Path: Identifier ( '.' Identifier )*;
	//Path returns ecore::EString:
	//	Identifier ("." Identifier)*;
	public PathElements getPathAccess() {
		return (pPath != null) ? pPath : (pPath = new PathElements());
	}
	
	public ParserRule getPathRule() {
		return getPathAccess().getRule();
	}

	//Identifier returns ecore::EString:
	//	"$"? ID | "e" | "f" | // To allow number terminals as function arguments
	//	"d" | "upper" | "lower" | "$now" | "$today" | "date" | "title" | "type" | "include" | //MDD keywords that can appear in Query Functions
	//	"length" | END | WHEN | FROM | MEMBER;
	public IdentifierElements getIdentifierAccess() {
		return (pIdentifier != null) ? pIdentifier : (pIdentifier = new IdentifierElements());
	}
	
	public ParserRule getIdentifierRule() {
		return getIdentifierAccess().getRule();
	}

	//Number returns ecore::EFloat:
	//	"." (INT ("e" ("+" | "-")? INT)? ("f" | "d")?)? | (HEX | INT | SIGNED_INT) ("l" | ("." INT? ("e" ("+" | "-")? INT)?
	//	("f" | "d")? | "e" ("+" | "-")? INT ("f" | "d")? | "f" | "d"))?;
	public NumberElements getNumberAccess() {
		return (pNumber != null) ? pNumber : (pNumber = new NumberElements());
	}
	
	public ParserRule getNumberRule() {
		return getNumberAccess().getRule();
	}

	//SELECT returns ecore::EString:
	//	"SELECT" | "Select" | "select";
	public SELECTElements getSELECTAccess() {
		return (pSELECT != null) ? pSELECT : (pSELECT = new SELECTElements());
	}
	
	public ParserRule getSELECTRule() {
		return getSELECTAccess().getRule();
	}

	//DISTINCT returns ecore::EString:
	//	"DISTINCT" | "Distinct" | "distinct";
	public DISTINCTElements getDISTINCTAccess() {
		return (pDISTINCT != null) ? pDISTINCT : (pDISTINCT = new DISTINCTElements());
	}
	
	public ParserRule getDISTINCTRule() {
		return getDISTINCTAccess().getRule();
	}

	//NEW returns ecore::EString:
	//	"NEW" | "New" | "new";
	public NEWElements getNEWAccess() {
		return (pNEW != null) ? pNEW : (pNEW = new NEWElements());
	}
	
	public ParserRule getNEWRule() {
		return getNEWAccess().getRule();
	}

	//OBJECT returns ecore::EString:
	//	"OBJECT" | "Object" | "object";
	public OBJECTElements getOBJECTAccess() {
		return (pOBJECT != null) ? pOBJECT : (pOBJECT = new OBJECTElements());
	}
	
	public ParserRule getOBJECTRule() {
		return getOBJECTAccess().getRule();
	}

	//FROM returns ecore::EString:
	//	"FROM" | "From" | "from";
	public FROMElements getFROMAccess() {
		return (pFROM != null) ? pFROM : (pFROM = new FROMElements());
	}
	
	public ParserRule getFROMRule() {
		return getFROMAccess().getRule();
	}

	//LEFT returns ecore::EString:
	//	"LEFT" | "Left" | "left";
	public LEFTElements getLEFTAccess() {
		return (pLEFT != null) ? pLEFT : (pLEFT = new LEFTElements());
	}
	
	public ParserRule getLEFTRule() {
		return getLEFTAccess().getRule();
	}

	//RIGHT returns ecore::EString:
	//	"RIGHT" | "Right" | "right";
	public RIGHTElements getRIGHTAccess() {
		return (pRIGHT != null) ? pRIGHT : (pRIGHT = new RIGHTElements());
	}
	
	public ParserRule getRIGHTRule() {
		return getRIGHTAccess().getRule();
	}

	//OUTER returns ecore::EString:
	//	"OUTER" | "Outer" | "outer";
	public OUTERElements getOUTERAccess() {
		return (pOUTER != null) ? pOUTER : (pOUTER = new OUTERElements());
	}
	
	public ParserRule getOUTERRule() {
		return getOUTERAccess().getRule();
	}

	//FULL returns ecore::EString:
	//	"FULL" | "Full" | "full";
	public FULLElements getFULLAccess() {
		return (pFULL != null) ? pFULL : (pFULL = new FULLElements());
	}
	
	public ParserRule getFULLRule() {
		return getFULLAccess().getRule();
	}

	//INNER returns ecore::EString:
	//	"INNER" | "Inner" | "inner";
	public INNERElements getINNERAccess() {
		return (pINNER != null) ? pINNER : (pINNER = new INNERElements());
	}
	
	public ParserRule getINNERRule() {
		return getINNERAccess().getRule();
	}

	//JOIN returns ecore::EString:
	//	"JOIN" | "Join" | "join";
	public JOINElements getJOINAccess() {
		return (pJOIN != null) ? pJOIN : (pJOIN = new JOINElements());
	}
	
	public ParserRule getJOINRule() {
		return getJOINAccess().getRule();
	}

	//FETCH returns ecore::EString:
	//	"FETCH" | "Fetch" | "fetch";
	public FETCHElements getFETCHAccess() {
		return (pFETCH != null) ? pFETCH : (pFETCH = new FETCHElements());
	}
	
	public ParserRule getFETCHRule() {
		return getFETCHAccess().getRule();
	}

	//WITH returns ecore::EString:
	//	"WITH" | "With" | "with";
	public WITHElements getWITHAccess() {
		return (pWITH != null) ? pWITH : (pWITH = new WITHElements());
	}
	
	public ParserRule getWITHRule() {
		return getWITHAccess().getRule();
	}

	//IN returns ecore::EString:
	//	"IN" | "In" | "in";
	public INElements getINAccess() {
		return (pIN != null) ? pIN : (pIN = new INElements());
	}
	
	public ParserRule getINRule() {
		return getINAccess().getRule();
	}

	//CLASS returns ecore::EString:
	//	"CLASS" | "Class" | "class";
	public CLASSElements getCLASSAccess() {
		return (pCLASS != null) ? pCLASS : (pCLASS = new CLASSElements());
	}
	
	public ParserRule getCLASSRule() {
		return getCLASSAccess().getRule();
	}

	//IN_CLASS returns ecore::EString:
	//	IN CLASS;
	public IN_CLASSElements getIN_CLASSAccess() {
		return (pIN_CLASS != null) ? pIN_CLASS : (pIN_CLASS = new IN_CLASSElements());
	}
	
	public ParserRule getIN_CLASSRule() {
		return getIN_CLASSAccess().getRule();
	}

	//ELEMENTS returns ecore::EString:
	//	"ELEMENTS" | "Elements" | "elements";
	public ELEMENTSElements getELEMENTSAccess() {
		return (pELEMENTS != null) ? pELEMENTS : (pELEMENTS = new ELEMENTSElements());
	}
	
	public ParserRule getELEMENTSRule() {
		return getELEMENTSAccess().getRule();
	}

	//IN_ELEMENTS returns ecore::EString:
	//	IN ELEMENTS;
	public IN_ELEMENTSElements getIN_ELEMENTSAccess() {
		return (pIN_ELEMENTS != null) ? pIN_ELEMENTS : (pIN_ELEMENTS = new IN_ELEMENTSElements());
	}
	
	public ParserRule getIN_ELEMENTSRule() {
		return getIN_ELEMENTSAccess().getRule();
	}

	//AS returns ecore::EString:
	//	"AS" | "As" | "as";
	public ASElements getASAccess() {
		return (pAS != null) ? pAS : (pAS = new ASElements());
	}
	
	public ParserRule getASRule() {
		return getASAccess().getRule();
	}

	//PROPERTIES returns ecore::EString:
	//	"PROPERTIES" | "Properties" | "properties";
	public PROPERTIESElements getPROPERTIESAccess() {
		return (pPROPERTIES != null) ? pPROPERTIES : (pPROPERTIES = new PROPERTIESElements());
	}
	
	public ParserRule getPROPERTIESRule() {
		return getPROPERTIESAccess().getRule();
	}

	//GROUP_BY returns ecore::EString:
	//	("GROUP" | "Group" | "group") BY;
	public GROUP_BYElements getGROUP_BYAccess() {
		return (pGROUP_BY != null) ? pGROUP_BY : (pGROUP_BY = new GROUP_BYElements());
	}
	
	public ParserRule getGROUP_BYRule() {
		return getGROUP_BYAccess().getRule();
	}

	//ORDER_BY returns ecore::EString:
	//	("ORDER" | "Order" | "order") BY;
	public ORDER_BYElements getORDER_BYAccess() {
		return (pORDER_BY != null) ? pORDER_BY : (pORDER_BY = new ORDER_BYElements());
	}
	
	public ParserRule getORDER_BYRule() {
		return getORDER_BYAccess().getRule();
	}

	//BY returns ecore::EString:
	//	"BY" | "By" | "by";
	public BYElements getBYAccess() {
		return (pBY != null) ? pBY : (pBY = new BYElements());
	}
	
	public ParserRule getBYRule() {
		return getBYAccess().getRule();
	}

	//ASC returns ecore::EString:
	//	"ASC" | "Asc" | "asc" | "ASCENDING" | "Ascending" | "ascending";
	public ASCElements getASCAccess() {
		return (pASC != null) ? pASC : (pASC = new ASCElements());
	}
	
	public ParserRule getASCRule() {
		return getASCAccess().getRule();
	}

	//DESC returns ecore::EString:
	//	"DESC" | "Desc" | "desc" | "DESCENDING" | "Descending" | "descending";
	public DESCElements getDESCAccess() {
		return (pDESC != null) ? pDESC : (pDESC = new DESCElements());
	}
	
	public ParserRule getDESCRule() {
		return getDESCAccess().getRule();
	}

	//HAVING returns ecore::EString:
	//	"HAVING" | "Having" | "having";
	public HAVINGElements getHAVINGAccess() {
		return (pHAVING != null) ? pHAVING : (pHAVING = new HAVINGElements());
	}
	
	public ParserRule getHAVINGRule() {
		return getHAVINGAccess().getRule();
	}

	//WHERE returns ecore::EString:
	//	"WHERE" | "Where" | "where";
	public WHEREElements getWHEREAccess() {
		return (pWHERE != null) ? pWHERE : (pWHERE = new WHEREElements());
	}
	
	public ParserRule getWHERERule() {
		return getWHEREAccess().getRule();
	}

	//OR returns ecore::EString:
	//	"OR" | "Or" | "or";
	public ORElements getORAccess() {
		return (pOR != null) ? pOR : (pOR = new ORElements());
	}
	
	public ParserRule getORRule() {
		return getORAccess().getRule();
	}

	//AND returns ecore::EString:
	//	"AND" | "And" | "and";
	public ANDElements getANDAccess() {
		return (pAND != null) ? pAND : (pAND = new ANDElements());
	}
	
	public ParserRule getANDRule() {
		return getANDAccess().getRule();
	}

	//NOT returns ecore::EString:
	//	"NOT" | "Not" | "not";
	public NOTElements getNOTAccess() {
		return (pNOT != null) ? pNOT : (pNOT = new NOTElements());
	}
	
	public ParserRule getNOTRule() {
		return getNOTAccess().getRule();
	}

	//IS returns ecore::EString:
	//	"IS" | "Is" | "is";
	public ISElements getISAccess() {
		return (pIS != null) ? pIS : (pIS = new ISElements());
	}
	
	public ParserRule getISRule() {
		return getISAccess().getRule();
	}

	//BETWEEN returns ecore::EString:
	//	"BETWEEN" | "Between" | "between";
	public BETWEENElements getBETWEENAccess() {
		return (pBETWEEN != null) ? pBETWEEN : (pBETWEEN = new BETWEENElements());
	}
	
	public ParserRule getBETWEENRule() {
		return getBETWEENAccess().getRule();
	}

	//LIKE returns ecore::EString:
	//	"LIKE" | "Like" | "like";
	public LIKEElements getLIKEAccess() {
		return (pLIKE != null) ? pLIKE : (pLIKE = new LIKEElements());
	}
	
	public ParserRule getLIKERule() {
		return getLIKEAccess().getRule();
	}

	//MEMBER returns ecore::EString:
	//	"MEMBER" | "Member" | "member";
	public MEMBERElements getMEMBERAccess() {
		return (pMEMBER != null) ? pMEMBER : (pMEMBER = new MEMBERElements());
	}
	
	public ParserRule getMEMBERRule() {
		return getMEMBERAccess().getRule();
	}

	//OF returns ecore::EString:
	//	"OF" | "Of" | "of";
	public OFElements getOFAccess() {
		return (pOF != null) ? pOF : (pOF = new OFElements());
	}
	
	public ParserRule getOFRule() {
		return getOFAccess().getRule();
	}

	//ESCAPE returns ecore::EString:
	//	"ESCAPE" | "Escape" | "escape";
	public ESCAPEElements getESCAPEAccess() {
		return (pESCAPE != null) ? pESCAPE : (pESCAPE = new ESCAPEElements());
	}
	
	public ParserRule getESCAPERule() {
		return getESCAPEAccess().getRule();
	}

	//CASE returns ecore::EString:
	//	"CASE" | "Case" | "case";
	public CASEElements getCASEAccess() {
		return (pCASE != null) ? pCASE : (pCASE = new CASEElements());
	}
	
	public ParserRule getCASERule() {
		return getCASEAccess().getRule();
	}

	//END returns ecore::EString:
	//	"END" | "End" | "end";
	public ENDElements getENDAccess() {
		return (pEND != null) ? pEND : (pEND = new ENDElements());
	}
	
	public ParserRule getENDRule() {
		return getENDAccess().getRule();
	}

	//WHEN returns ecore::EString:
	//	"WHEN" | "When" | "when";
	public WHENElements getWHENAccess() {
		return (pWHEN != null) ? pWHEN : (pWHEN = new WHENElements());
	}
	
	public ParserRule getWHENRule() {
		return getWHENAccess().getRule();
	}

	//THEN returns ecore::EString:
	//	"THEN" | "Then" | "then";
	public THENElements getTHENAccess() {
		return (pTHEN != null) ? pTHEN : (pTHEN = new THENElements());
	}
	
	public ParserRule getTHENRule() {
		return getTHENAccess().getRule();
	}

	//ELSE returns ecore::EString:
	//	"ELSE" | "Else" | "else";
	public ELSEElements getELSEAccess() {
		return (pELSE != null) ? pELSE : (pELSE = new ELSEElements());
	}
	
	public ParserRule getELSERule() {
		return getELSEAccess().getRule();
	}

	//SOME returns ecore::EString:
	//	"SOME" | "Some" | "some";
	public SOMEElements getSOMEAccess() {
		return (pSOME != null) ? pSOME : (pSOME = new SOMEElements());
	}
	
	public ParserRule getSOMERule() {
		return getSOMEAccess().getRule();
	}

	//EXISTS returns ecore::EString:
	//	"EXISTS" | "Exists" | "exists";
	public EXISTSElements getEXISTSAccess() {
		return (pEXISTS != null) ? pEXISTS : (pEXISTS = new EXISTSElements());
	}
	
	public ParserRule getEXISTSRule() {
		return getEXISTSAccess().getRule();
	}

	//ALL returns ecore::EString:
	//	"ALL" | "All" | "all";
	public ALLElements getALLAccess() {
		return (pALL != null) ? pALL : (pALL = new ALLElements());
	}
	
	public ParserRule getALLRule() {
		return getALLAccess().getRule();
	}

	//ANY returns ecore::EString:
	//	"ANY" | "Any" | "any";
	public ANYElements getANYAccess() {
		return (pANY != null) ? pANY : (pANY = new ANYElements());
	}
	
	public ParserRule getANYRule() {
		return getANYAccess().getRule();
	}

	//SUM returns ecore::EString:
	//	"SUM" | "Sum" | "sum";
	public SUMElements getSUMAccess() {
		return (pSUM != null) ? pSUM : (pSUM = new SUMElements());
	}
	
	public ParserRule getSUMRule() {
		return getSUMAccess().getRule();
	}

	//AVG returns ecore::EString:
	//	"AVG" | "Avg" | "avg";
	public AVGElements getAVGAccess() {
		return (pAVG != null) ? pAVG : (pAVG = new AVGElements());
	}
	
	public ParserRule getAVGRule() {
		return getAVGAccess().getRule();
	}

	//MAX returns ecore::EString:
	//	"MAX" | "Max" | "max";
	public MAXElements getMAXAccess() {
		return (pMAX != null) ? pMAX : (pMAX = new MAXElements());
	}
	
	public ParserRule getMAXRule() {
		return getMAXAccess().getRule();
	}

	//MIN returns ecore::EString:
	//	"MIN" | "Min" | "min";
	public MINElements getMINAccess() {
		return (pMIN != null) ? pMIN : (pMIN = new MINElements());
	}
	
	public ParserRule getMINRule() {
		return getMINAccess().getRule();
	}

	//COUNT returns ecore::EString:
	//	"COUNT" | "Count" | "count";
	public COUNTElements getCOUNTAccess() {
		return (pCOUNT != null) ? pCOUNT : (pCOUNT = new COUNTElements());
	}
	
	public ParserRule getCOUNTRule() {
		return getCOUNTAccess().getRule();
	}

	//INDICES returns ecore::EString:
	//	"INDICES" | "Indices" | "indices";
	public INDICESElements getINDICESAccess() {
		return (pINDICES != null) ? pINDICES : (pINDICES = new INDICESElements());
	}
	
	public ParserRule getINDICESRule() {
		return getINDICESAccess().getRule();
	}

	//TRAILING returns ecore::EString:
	//	"TRAILING" | "Trailing" | "trailing";
	public TRAILINGElements getTRAILINGAccess() {
		return (pTRAILING != null) ? pTRAILING : (pTRAILING = new TRAILINGElements());
	}
	
	public ParserRule getTRAILINGRule() {
		return getTRAILINGAccess().getRule();
	}

	//LEADING returns ecore::EString:
	//	"LEADING" | "Leading" | "leading";
	public LEADINGElements getLEADINGAccess() {
		return (pLEADING != null) ? pLEADING : (pLEADING = new LEADINGElements());
	}
	
	public ParserRule getLEADINGRule() {
		return getLEADINGAccess().getRule();
	}

	//BOTH returns ecore::EString:
	//	"BOTH" | "Both" | "both";
	public BOTHElements getBOTHAccess() {
		return (pBOTH != null) ? pBOTH : (pBOTH = new BOTHElements());
	}
	
	public ParserRule getBOTHRule() {
		return getBOTHAccess().getRule();
	}

	//NULL returns ecore::EString:
	//	"NULL" | "Null" | "null";
	public NULLElements getNULLAccess() {
		return (pNULL != null) ? pNULL : (pNULL = new NULLElements());
	}
	
	public ParserRule getNULLRule() {
		return getNULLAccess().getRule();
	}

	//TRUE returns ecore::EString:
	//	"TRUE" | "True" | "true";
	public TRUEElements getTRUEAccess() {
		return (pTRUE != null) ? pTRUE : (pTRUE = new TRUEElements());
	}
	
	public ParserRule getTRUERule() {
		return getTRUEAccess().getRule();
	}

	//FALSE returns ecore::EString:
	//	"FALSE" | "False" | "false";
	public FALSEElements getFALSEAccess() {
		return (pFALSE != null) ? pFALSE : (pFALSE = new FALSEElements());
	}
	
	public ParserRule getFALSERule() {
		return getFALSEAccess().getRule();
	}

	//EMPTY returns ecore::EString:
	//	"EMPTY" | "Empty" | "empty";
	public EMPTYElements getEMPTYAccess() {
		return (pEMPTY != null) ? pEMPTY : (pEMPTY = new EMPTYElements());
	}
	
	public ParserRule getEMPTYRule() {
		return getEMPTYAccess().getRule();
	}

	//// END HQL stuff
	//IdOrKeyword returns ecore::EString:
	//	ID | Keyword;
	public IdOrKeywordElements getIdOrKeywordAccess() {
		return (pIdOrKeyword != null) ? pIdOrKeyword : (pIdOrKeyword = new IdOrKeywordElements());
	}
	
	public ParserRule getIdOrKeywordRule() {
		return getIdOrKeywordAccess().getRule();
	}

	////keywords that can be used as names of fields or functions	
	//Keyword returns ecore::EString:
	//	"all" | "length" | "char" | "type" | "file" | "text" | //MDD keywords
	//	"title" | "max" | "when" | "member" | "end" | "object" | "date" | //HQL keywords
	//	"then";
	public KeywordElements getKeywordAccess() {
		return (pKeyword != null) ? pKeyword : (pKeyword = new KeywordElements());
	}
	
	public ParserRule getKeywordRule() {
		return getKeywordAccess().getRule();
	}

	//terminal LINEBREAK:
	//	"\n" | "\r" "\n" | "\r";
	public TerminalRule getLINEBREAKRule() {
		return (tLINEBREAK != null) ? tLINEBREAK : (tLINEBREAK = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LINEBREAK"));
	} 

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return (tID != null) ? tID : (tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ID"));
	} 

	//terminal SIGNED_INT returns ecore::EInt:
	//	("-" | "+") INT;
	public TerminalRule getSIGNED_INTRule() {
		return (tSIGNED_INT != null) ? tSIGNED_INT : (tSIGNED_INT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SIGNED_INT"));
	} 

	//terminal HEX returns ecore::EInt:
	//	"0x" ("0".."9" | "a".."f")+;
	public TerminalRule getHEXRule() {
		return (tHEX != null) ? tHEX : (tHEX = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "HEX"));
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return (tINT != null) ? tINT : (tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INT"));
	} 

	//terminal FIELDCOMMENT:
	//	";" !("\n" | "\r")*;
	public TerminalRule getFIELDCOMMENTRule() {
		return (tFIELDCOMMENT != null) ? tFIELDCOMMENT : (tFIELDCOMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "FIELDCOMMENT"));
	} 

	//terminal SL_COMMENT:
	//	"#" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return (tSL_COMMENT != null) ? tSL_COMMENT : (tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SL_COMMENT"));
	} 

	//terminal WS:
	//	" " | "\t" | "\r" "\n" | "\n" | "\r";
	public TerminalRule getWSRule() {
		return (tWS != null) ? tWS : (tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS"));
	} 

	////terminal STRING
	////	: '"'->'"'; 
	////	
	////terminal HQL_STRING
	////	: "'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|"'") )* "'"
	////	;
	//terminal STRING: //		:'"'(	('\\' ( 'n' | 'r' | 't' | 'b' | 'f' | '"' | '\'' | '\\'
	////	        		|   ('u')+ ('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F') 
	////	        			('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F')
	////	        		//|   '0'..'3'('0'..'7')*
	////	        		//|   '4'..'7' ('0'..'7')? 
	////	        		)
	////	        	)
	////	        |!('"'|'\\'|'\n'|'\r'))* '"'
	//	"\"" ("\\" "\"" | !"\"")* "\"" | "\'" ("\\" ("b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return (tSTRING != null) ? tSTRING : (tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "STRING"));
	} 
}
